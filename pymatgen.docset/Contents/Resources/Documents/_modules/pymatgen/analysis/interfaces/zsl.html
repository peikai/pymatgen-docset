
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pymatgen.analysis.interfaces.zsl &#8212; pymatgen 2022.0.17 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/basic.css" />
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
 
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33990148-1']);
  _gaq.push(['_trackPageview']);
</script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">pymatgen 2022.0.17 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">pymatgen.analysis.interfaces.zsl</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <h1>Source code for pymatgen.analysis.interfaces.zsl</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) Pymatgen Development Team.</span>
<span class="c1"># Distributed under the terms of the MIT License.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module implements the Zur and McGill lattice matching algorithm</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">List</span>

<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">monty.json</span> <span class="kn">import</span> <span class="n">MSONable</span>


<div class="viewcode-block" id="ZSLMatch"><a class="viewcode-back" href="../../../../pymatgen.analysis.interfaces.zsl.html#pymatgen.analysis.interfaces.zsl.ZSLMatch">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">ZSLMatch</span><span class="p">(</span><span class="n">MSONable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A match from the Zur and McGill Algorithm. The super_lattice vectors are listed</span>
<span class="sd">    as _sl_vectors. These are reduced according to the algorithm in the paper which</span>
<span class="sd">    effectively a rotation in 3D space. Use the match_transformation property to get</span>
<span class="sd">    the appropriate transformation matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">film_sl_vectors</span><span class="p">:</span> <span class="n">List</span>
    <span class="n">substrate_sl_vectors</span><span class="p">:</span> <span class="n">List</span>
    <span class="n">film_vectors</span><span class="p">:</span> <span class="n">List</span>
    <span class="n">substrate_vectors</span><span class="p">:</span> <span class="n">List</span>
    <span class="n">film_transformation</span><span class="p">:</span> <span class="n">List</span>
    <span class="n">substrate_transformation</span><span class="p">:</span> <span class="n">List</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">match_area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The area of the match between the substrate and film super lattice vectors&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">vec_area</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">film_sl_vectors</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">match_transformation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The tranformation matrix to conver the film super lattice vectors to the substrate&quot;&quot;&quot;</span>
        <span class="c1"># Generate 3D lattice vectors for film super lattice</span>
        <span class="n">film_matrix</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">film_sl_vectors</span><span class="p">)</span>
        <span class="n">film_matrix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">film_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">film_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="c1"># Generate 3D lattice vectors for substrate super lattice</span>
        <span class="c1"># Out of plane substrate super lattice has to be same length as</span>
        <span class="c1"># Film out of plane vector to ensure no extra deformation in that</span>
        <span class="c1"># direction</span>
        <span class="n">substrate_matrix</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">substrate_sl_vectors</span><span class="p">)</span>
        <span class="n">temp_sub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">substrate_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">substrate_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">temp_sub</span> <span class="o">=</span> <span class="n">temp_sub</span> <span class="o">*</span> <span class="n">fast_norm</span><span class="p">(</span><span class="n">film_matrix</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">fast_norm</span><span class="p">(</span><span class="n">temp_sub</span><span class="p">)</span>
        <span class="n">substrate_matrix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp_sub</span><span class="p">)</span>

        <span class="n">transform_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">film_matrix</span><span class="p">,</span> <span class="n">substrate_matrix</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">transform_matrix</span></div>


<div class="viewcode-block" id="ZSLGenerator"><a class="viewcode-back" href="../../../../pymatgen.analysis.interfaces.zsl.html#pymatgen.analysis.interfaces.zsl.ZSLGenerator">[docs]</a><span class="k">class</span> <span class="nc">ZSLGenerator</span><span class="p">(</span><span class="n">MSONable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class generate matching interface super lattices based on the methodology</span>
<span class="sd">    of lattice vector matching for heterostructural interfaces proposed by</span>
<span class="sd">    Zur and McGill:</span>
<span class="sd">    Journal of Applied Physics 55 (1984), 378 ; doi: 10.1063/1.333084</span>
<span class="sd">    The process of generating all possible matching super lattices is:</span>
<span class="sd">    1.) Reduce the surface lattice vectors and calculate area for the surfaces</span>
<span class="sd">    2.) Generate all super lattice transformations within a maximum allowed area</span>
<span class="sd">        limit that give nearly equal area super-lattices for the two</span>
<span class="sd">        surfaces - generate_sl_transformation_sets</span>
<span class="sd">    3.) For each superlattice set:</span>
<span class="sd">        1.) Reduce super lattice vectors</span>
<span class="sd">        2.) Check length and angle between film and substrate super lattice</span>
<span class="sd">            vectors to determine if the super lattices are the nearly same</span>
<span class="sd">            and therefore coincident - get_equiv_transformations</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">max_area_ratio_tol</span><span class="o">=</span><span class="mf">0.09</span><span class="p">,</span>
        <span class="n">max_area</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span>
        <span class="n">max_length_tol</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span>
        <span class="n">max_angle_tol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
        <span class="n">bidirectional</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Intialize a Zur Super Lattice Generator for a specific film and</span>
<span class="sd">            substrate</span>
<span class="sd">        Args:</span>
<span class="sd">            max_area_ratio_tol(float): Max tolerance on ratio of</span>
<span class="sd">                super-lattices to consider equal</span>
<span class="sd">            max_area(float): max super lattice area to generate in search</span>
<span class="sd">            max_length_tol: maximum length tolerance in checking if two</span>
<span class="sd">                vectors are of nearly the same length</span>
<span class="sd">            max_angle_tol: maximum angle tolerance in checking of two sets</span>
<span class="sd">                of vectors have nearly the same angle between them</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_area_ratio_tol</span> <span class="o">=</span> <span class="n">max_area_ratio_tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_area</span> <span class="o">=</span> <span class="n">max_area</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_length_tol</span> <span class="o">=</span> <span class="n">max_length_tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_angle_tol</span> <span class="o">=</span> <span class="n">max_angle_tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bidirectional</span> <span class="o">=</span> <span class="n">bidirectional</span>

<div class="viewcode-block" id="ZSLGenerator.is_same_vectors"><a class="viewcode-back" href="../../../../pymatgen.analysis.interfaces.zsl.html#pymatgen.analysis.interfaces.zsl.ZSLGenerator.is_same_vectors">[docs]</a>    <span class="k">def</span> <span class="nf">is_same_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vec_set1</span><span class="p">,</span> <span class="n">vec_set2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine if two sets of vectors are the same within length and angle</span>
<span class="sd">        tolerances</span>
<span class="sd">        Args:</span>
<span class="sd">            vec_set1(array[array]): an array of two vectors</span>
<span class="sd">            vec_set2(array[array]): second array of two vectors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bidirectional</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bidirectional_same_vectors</span><span class="p">(</span><span class="n">vec_set1</span><span class="p">,</span> <span class="n">vec_set2</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unidirectional_is_same_vectors</span><span class="p">(</span><span class="n">vec_set1</span><span class="p">,</span> <span class="n">vec_set2</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_unidirectional_is_same_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vec_set1</span><span class="p">,</span> <span class="n">vec_set2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine if two sets of vectors are the same within length and angle</span>
<span class="sd">        tolerances</span>
<span class="sd">        Args:</span>
<span class="sd">            vec_set1(array[array]): an array of two vectors</span>
<span class="sd">            vec_set2(array[array]): second array of two vectors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">rel_strain</span><span class="p">(</span><span class="n">vec_set1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vec_set2</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_length_tol</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">rel_strain</span><span class="p">(</span><span class="n">vec_set1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">vec_set2</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_length_tol</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">rel_angle</span><span class="p">(</span><span class="n">vec_set1</span><span class="p">,</span> <span class="n">vec_set2</span><span class="p">))</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_angle_tol</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_bidirectional_same_vectors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vec_set1</span><span class="p">,</span> <span class="n">vec_set2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Bidirectional version of above matching constraint check&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unidirectional_is_same_vectors</span><span class="p">(</span><span class="n">vec_set1</span><span class="p">,</span> <span class="n">vec_set2</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unidirectional_is_same_vectors</span><span class="p">(</span>
            <span class="n">vec_set2</span><span class="p">,</span> <span class="n">vec_set1</span>
        <span class="p">)</span>

<div class="viewcode-block" id="ZSLGenerator.generate_sl_transformation_sets"><a class="viewcode-back" href="../../../../pymatgen.analysis.interfaces.zsl.html#pymatgen.analysis.interfaces.zsl.ZSLGenerator.generate_sl_transformation_sets">[docs]</a>    <span class="k">def</span> <span class="nf">generate_sl_transformation_sets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">film_area</span><span class="p">,</span> <span class="n">substrate_area</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates transformation sets for film/substrate pair given the</span>
<span class="sd">        area of the unit cell area for the film and substrate. The</span>
<span class="sd">        transformation sets map the film and substrate unit cells to super</span>
<span class="sd">        lattices with a maximum area</span>
<span class="sd">        Args:</span>
<span class="sd">            film_area(int): the unit cell area for the film</span>
<span class="sd">            substrate_area(int): the unit cell area for the substrate</span>
<span class="sd">        Returns:</span>
<span class="sd">            transformation_sets: a set of transformation_sets defined as:</span>
<span class="sd">                1.) the transformation matricies for the film to create a</span>
<span class="sd">                super lattice of area i*film area</span>
<span class="sd">                2.) the tranformation matricies for the substrate to create</span>
<span class="sd">                a super lattice of area j*film area</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">transformation_indicies</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_area</span> <span class="o">/</span> <span class="n">film_area</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_area</span> <span class="o">/</span> <span class="n">substrate_area</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">film_area</span> <span class="o">/</span> <span class="n">substrate_area</span> <span class="o">-</span> <span class="nb">float</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">/</span> <span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_area_ratio_tol</span>
        <span class="p">]</span> <span class="o">+</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_area</span> <span class="o">/</span> <span class="n">film_area</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_area</span> <span class="o">/</span> <span class="n">substrate_area</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">substrate_area</span> <span class="o">/</span> <span class="n">film_area</span> <span class="o">-</span> <span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="n">j</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_area_ratio_tol</span>
        <span class="p">]</span>
        <span class="n">transformation_indicies</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">transformation_indicies</span><span class="p">))</span>

        <span class="c1"># Sort sets by the square of the matching area and yield in order</span>
        <span class="c1"># from smallest to largest</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">transformation_indicies</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">gen_sl_transform_matricies</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">gen_sl_transform_matricies</span><span class="p">(</span><span class="n">j</span><span class="p">))</span></div>

<div class="viewcode-block" id="ZSLGenerator.get_equiv_transformations"><a class="viewcode-back" href="../../../../pymatgen.analysis.interfaces.zsl.html#pymatgen.analysis.interfaces.zsl.ZSLGenerator.get_equiv_transformations">[docs]</a>    <span class="k">def</span> <span class="nf">get_equiv_transformations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transformation_sets</span><span class="p">,</span> <span class="n">film_vectors</span><span class="p">,</span> <span class="n">substrate_vectors</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies the transformation_sets to the film and substrate vectors</span>
<span class="sd">        to generate super-lattices and checks if they matches.</span>
<span class="sd">        Returns all matching vectors sets.</span>
<span class="sd">        Args:</span>
<span class="sd">            transformation_sets(array): an array of transformation sets:</span>
<span class="sd">                each transformation set is an array with the (i,j)</span>
<span class="sd">                indicating the area multipes of the film and subtrate it</span>
<span class="sd">                corresponds to, an array with all possible transformations</span>
<span class="sd">                for the film area multiple i and another array for the</span>
<span class="sd">                substrate area multiple j.</span>
<span class="sd">            film_vectors(array): film vectors to generate super lattices</span>
<span class="sd">            substrate_vectors(array): substrate vectors to generate super</span>
<span class="sd">                lattices</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">film_transformations</span><span class="p">,</span> <span class="n">substrate_transformations</span><span class="p">)</span> <span class="ow">in</span> <span class="n">transformation_sets</span><span class="p">:</span>
            <span class="c1"># Apply transformations and reduce using Zur reduce methodology</span>
            <span class="n">films</span> <span class="o">=</span> <span class="p">[</span><span class="n">reduce_vectors</span><span class="p">(</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">film_vectors</span><span class="p">))</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">film_transformations</span><span class="p">]</span>

            <span class="n">substrates</span> <span class="o">=</span> <span class="p">[</span><span class="n">reduce_vectors</span><span class="p">(</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">substrate_vectors</span><span class="p">))</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">substrate_transformations</span><span class="p">]</span>

            <span class="c1"># Check if equivalant super lattices</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">f_trans</span><span class="p">,</span> <span class="n">s_trans</span><span class="p">),</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">product</span><span class="p">(</span><span class="n">film_transformations</span><span class="p">,</span> <span class="n">substrate_transformations</span><span class="p">),</span>
                <span class="n">product</span><span class="p">(</span><span class="n">films</span><span class="p">,</span> <span class="n">substrates</span><span class="p">),</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_same_vectors</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">f_trans</span><span class="p">,</span> <span class="n">s_trans</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">film_vectors</span><span class="p">,</span> <span class="n">substrate_vectors</span><span class="p">,</span> <span class="n">lowest</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">ZSLMatch</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Runs the ZSL algorithm to generate all possible matching</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">film_area</span> <span class="o">=</span> <span class="n">vec_area</span><span class="p">(</span><span class="o">*</span><span class="n">film_vectors</span><span class="p">)</span>
        <span class="n">substrate_area</span> <span class="o">=</span> <span class="n">vec_area</span><span class="p">(</span><span class="o">*</span><span class="n">substrate_vectors</span><span class="p">)</span>

        <span class="c1"># Generate all super lattice comnbinations for a given set of miller</span>
        <span class="c1"># indicies</span>
        <span class="n">transformation_sets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_sl_transformation_sets</span><span class="p">(</span><span class="n">film_area</span><span class="p">,</span> <span class="n">substrate_area</span><span class="p">)</span>

        <span class="c1"># Check each super-lattice pair to see if they match</span>
        <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_equiv_transformations</span><span class="p">(</span><span class="n">transformation_sets</span><span class="p">,</span> <span class="n">film_vectors</span><span class="p">,</span> <span class="n">substrate_vectors</span><span class="p">):</span>
            <span class="c1"># Yield the match area, the miller indicies,</span>
            <span class="k">yield</span> <span class="n">ZSLMatch</span><span class="p">(</span>
                <span class="n">film_sl_vectors</span><span class="o">=</span><span class="n">match</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">substrate_sl_vectors</span><span class="o">=</span><span class="n">match</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">film_vectors</span><span class="o">=</span><span class="n">film_vectors</span><span class="p">,</span>
                <span class="n">substrate_vectors</span><span class="o">=</span><span class="n">substrate_vectors</span><span class="p">,</span>
                <span class="n">film_transformation</span><span class="o">=</span><span class="n">match</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                <span class="n">substrate_transformation</span><span class="o">=</span><span class="n">match</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="c1"># Just want lowest match per direction</span>
            <span class="k">if</span> <span class="n">lowest</span><span class="p">:</span>
                <span class="k">break</span></div>


<div class="viewcode-block" id="gen_sl_transform_matricies"><a class="viewcode-back" href="../../../../pymatgen.analysis.interfaces.zsl.html#pymatgen.analysis.interfaces.zsl.gen_sl_transform_matricies">[docs]</a><span class="k">def</span> <span class="nf">gen_sl_transform_matricies</span><span class="p">(</span><span class="n">area_multiple</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates the transformation matricies that convert a set of 2D</span>
<span class="sd">    vectors into a super lattice of integer area multiple as proven</span>
<span class="sd">    in Cassels:</span>

<span class="sd">    Cassels, John William Scott. An introduction to the geometry of</span>
<span class="sd">    numbers. Springer Science &amp; Business Media, 2012.</span>

<span class="sd">    Args:</span>
<span class="sd">        area_multiple(int): integer multiple of unit cell area for super</span>
<span class="sd">        lattice area</span>

<span class="sd">    Returns:</span>
<span class="sd">        matrix_list: transformation matricies to covert unit vectors to</span>
<span class="sd">        super lattice vectors</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">area_multiple</span> <span class="o">/</span> <span class="n">i</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">get_factors</span><span class="p">(</span><span class="n">area_multiple</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">area_multiple</span> <span class="o">//</span> <span class="n">i</span><span class="p">)</span>
    <span class="p">]</span></div>


<div class="viewcode-block" id="rel_strain"><a class="viewcode-back" href="../../../../pymatgen.analysis.interfaces.zsl.html#pymatgen.analysis.interfaces.zsl.rel_strain">[docs]</a><span class="k">def</span> <span class="nf">rel_strain</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate relative strain between two vectors</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">fast_norm</span><span class="p">(</span><span class="n">vec2</span><span class="p">)</span> <span class="o">/</span> <span class="n">fast_norm</span><span class="p">(</span><span class="n">vec1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="rel_angle"><a class="viewcode-back" href="../../../../pymatgen.analysis.interfaces.zsl.html#pymatgen.analysis.interfaces.zsl.rel_angle">[docs]</a><span class="k">def</span> <span class="nf">rel_angle</span><span class="p">(</span><span class="n">vec_set1</span><span class="p">,</span> <span class="n">vec_set2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the relative angle between two vector sets</span>

<span class="sd">    Args:</span>
<span class="sd">        vec_set1(array[array]): an array of two vectors</span>
<span class="sd">        vec_set2(array[array]): second array of two vectors</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">vec_angle</span><span class="p">(</span><span class="n">vec_set2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vec_set2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">vec_angle</span><span class="p">(</span><span class="n">vec_set1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vec_set1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="fast_norm"><a class="viewcode-back" href="../../../../pymatgen.analysis.interfaces.zsl.html#pymatgen.analysis.interfaces.zsl.fast_norm">[docs]</a><span class="k">def</span> <span class="nf">fast_norm</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Much faster variant of numpy linalg norm</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span></div>


<div class="viewcode-block" id="vec_angle"><a class="viewcode-back" href="../../../../pymatgen.analysis.interfaces.zsl.html#pymatgen.analysis.interfaces.zsl.vec_angle">[docs]</a><span class="k">def</span> <span class="nf">vec_angle</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate angle between two vectors</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cosang</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">sinang</span> <span class="o">=</span> <span class="n">fast_norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">sinang</span><span class="p">,</span> <span class="n">cosang</span><span class="p">)</span></div>


<div class="viewcode-block" id="vec_area"><a class="viewcode-back" href="../../../../pymatgen.analysis.interfaces.zsl.html#pymatgen.analysis.interfaces.zsl.vec_area">[docs]</a><span class="k">def</span> <span class="nf">vec_area</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Area of lattice plane defined by two vectors</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">fast_norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span></div>


<div class="viewcode-block" id="reduce_vectors"><a class="viewcode-back" href="../../../../pymatgen.analysis.interfaces.zsl.html#pymatgen.analysis.interfaces.zsl.reduce_vectors">[docs]</a><span class="k">def</span> <span class="nf">reduce_vectors</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate independent and unique basis vectors based on the</span>
<span class="sd">    methodology of Zur and McGill</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">reduce_vectors</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="n">b</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fast_norm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">fast_norm</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">reduce_vectors</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fast_norm</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">fast_norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">reduce_vectors</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">fast_norm</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">fast_norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">reduce_vectors</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span></div>


<div class="viewcode-block" id="get_factors"><a class="viewcode-back" href="../../../../pymatgen.analysis.interfaces.zsl.html#pymatgen.analysis.interfaces.zsl.get_factors">[docs]</a><span class="k">def</span> <span class="nf">get_factors</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate all factors of n</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">x</span></div>
</pre></div>

            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">pymatgen 2022.0.17 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">pymatgen.analysis.interfaces.zsl</a></li> 
      </ul>
    </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2011, Pymatgen Development Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.3.2.
    </div>
<div class="footer">This page uses <a href="http://analytics.google.com/">
Google Analytics</a> to collect statistics. You can disable it by blocking
the JavaScript coming from www.google-analytics.com.
<script type="text/javascript">
  (function() {
    var ga = document.createElement('script');
    ga.src = ('https:' == document.location.protocol ?
              'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    ga.setAttribute('async', 'true');
    document.documentElement.firstChild.appendChild(ga);
  })();
</script>
</div>

  </body>
</html>