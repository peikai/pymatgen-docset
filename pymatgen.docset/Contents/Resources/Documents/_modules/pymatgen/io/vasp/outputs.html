<!DOCTYPE html>

<html lang="en" data-content_root="../../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pymatgen.io.vasp.outputs &#8212; pymatgen 2025.1.24 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/basic.css?v=5c69cfe2" />
    <script src="../../../../_static/documentation_options.js?v=d2bc030c"></script>
    <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">pymatgen 2025.1.24 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">pymatgen.io.vasp.outputs</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <h1>Source code for pymatgen.io.vasp.outputs</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Classes for reading/manipulating/writing VASP output files.&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">hashlib</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">re</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">xml.etree.ElementTree</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ET</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Iterable</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">glob</span><span class="w"> </span><span class="kn">import</span> <span class="n">glob</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">io</span><span class="w"> </span><span class="kn">import</span> <span class="n">StringIO</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">cast</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">monty.io</span><span class="w"> </span><span class="kn">import</span> <span class="n">reverse_readfile</span><span class="p">,</span> <span class="n">zopen</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">monty.json</span><span class="w"> </span><span class="kn">import</span> <span class="n">MSONable</span><span class="p">,</span> <span class="n">jsanitize</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">monty.os.path</span><span class="w"> </span><span class="kn">import</span> <span class="n">zpath</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">monty.re</span><span class="w"> </span><span class="kn">import</span> <span class="n">regrep</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tqdm</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">pymatgen.core</span><span class="w"> </span><span class="kn">import</span> <span class="n">Composition</span><span class="p">,</span> <span class="n">Element</span><span class="p">,</span> <span class="n">Lattice</span><span class="p">,</span> <span class="n">Structure</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pymatgen.core.trajectory</span><span class="w"> </span><span class="kn">import</span> <span class="n">Trajectory</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pymatgen.core.units</span><span class="w"> </span><span class="kn">import</span> <span class="n">unitized</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pymatgen.electronic_structure.bandstructure</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">BandStructure</span><span class="p">,</span>
    <span class="n">BandStructureSymmLine</span><span class="p">,</span>
    <span class="n">get_reconstructed_band_structure</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pymatgen.electronic_structure.core</span><span class="w"> </span><span class="kn">import</span> <span class="n">Magmom</span><span class="p">,</span> <span class="n">Orbital</span><span class="p">,</span> <span class="n">OrbitalType</span><span class="p">,</span> <span class="n">Spin</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pymatgen.electronic_structure.dos</span><span class="w"> </span><span class="kn">import</span> <span class="n">CompleteDos</span><span class="p">,</span> <span class="n">Dos</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pymatgen.entries.computed_entries</span><span class="w"> </span><span class="kn">import</span> <span class="n">ComputedEntry</span><span class="p">,</span> <span class="n">ComputedStructureEntry</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pymatgen.io.common</span><span class="w"> </span><span class="kn">import</span> <span class="n">VolumetricData</span> <span class="k">as</span> <span class="n">BaseVolumetricData</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pymatgen.io.core</span><span class="w"> </span><span class="kn">import</span> <span class="n">ParseError</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pymatgen.io.vasp.inputs</span><span class="w"> </span><span class="kn">import</span> <span class="n">Incar</span><span class="p">,</span> <span class="n">Kpoints</span><span class="p">,</span> <span class="n">Poscar</span><span class="p">,</span> <span class="n">Potcar</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pymatgen.io.wannier90</span><span class="w"> </span><span class="kn">import</span> <span class="n">Unk</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pymatgen.util.io_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">clean_lines</span><span class="p">,</span> <span class="n">micro_pyawk</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pymatgen.util.num</span><span class="w"> </span><span class="kn">import</span> <span class="n">make_symmetric_matrix_from_upper_tri</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pymatgen.util.typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Kpoint</span><span class="p">,</span> <span class="n">Tuple3Floats</span><span class="p">,</span> <span class="n">Vector3D</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Callable</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">TypeAlias</span>

    <span class="c1"># Avoid name conflict with pymatgen.core.Element</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">xml.etree.ElementTree</span><span class="w"> </span><span class="kn">import</span> <span class="n">Element</span> <span class="k">as</span> <span class="n">XML_Element</span>

    <span class="kn">from</span><span class="w"> </span><span class="nn">numpy.typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">NDArray</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">typing_extensions</span><span class="w"> </span><span class="kn">import</span> <span class="n">Self</span>

    <span class="kn">from</span><span class="w"> </span><span class="nn">pymatgen.util.typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">PathLike</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_parse_parameters</span><span class="p">(</span><span class="n">val_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function to convert a Vasprun parameter into the proper type.</span>
<span class="sd">    Boolean, int and float types are converted.</span>

<span class="sd">    Args:</span>
<span class="sd">        val_type: Value type parsed from vasprun.xml.</span>
<span class="sd">        val: Actual string value parsed for vasprun.xml.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">val_type</span> <span class="o">==</span> <span class="s2">&quot;logical&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">val</span> <span class="o">==</span> <span class="s2">&quot;T&quot;</span>
    <span class="k">if</span> <span class="n">val_type</span> <span class="o">==</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">val_type</span> <span class="o">==</span> <span class="s2">&quot;string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">val</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_parse_v_parameters</span><span class="p">(</span>
    <span class="n">val_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">val</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">filename</span><span class="p">:</span> <span class="n">PathLike</span><span class="p">,</span>
    <span class="n">param_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function to convert a Vasprun array-type parameter into</span>
<span class="sd">    the proper type. Boolean, int and float types are converted.</span>

<span class="sd">    Args:</span>
<span class="sd">        val_type: Value type parsed from vasprun.xml.</span>
<span class="sd">        val: Actual string value parsed for vasprun.xml.</span>
<span class="sd">        filename: Fullpath of vasprun.xml. Used for robust error handling.</span>
<span class="sd">            e.g. if vasprun.xml contains *** for some Incar parameters,</span>
<span class="sd">            the code will try to read from an INCAR file present in the same</span>
<span class="sd">            directory.</span>
<span class="sd">        param_name: Name of parameter.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Parsed value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">err</span> <span class="o">=</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Error in parsing vasprun.xml&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">val_type</span> <span class="o">==</span> <span class="s2">&quot;logical&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">i</span> <span class="o">==</span> <span class="s2">&quot;T&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">val</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>

    <span class="k">if</span> <span class="n">val_type</span> <span class="o">==</span> <span class="s2">&quot;string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">val</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">val_type</span> <span class="o">==</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ints</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">val</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="c1"># Fix an error in vasprun where</span>
            <span class="c1"># sometimes LDAUL/J is displayed as 2****</span>
            <span class="n">ints</span> <span class="o">=</span> <span class="n">_parse_from_incar</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">param_name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ints</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">err</span> <span class="kn">from</span><span class="w"> </span><span class="nn">exc</span>

        <span class="k">return</span> <span class="n">ints</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">floats</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">val</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>
    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
        <span class="c1"># Fix an error in vasprun where</span>
        <span class="c1"># sometimes MAGMOM is displayed as 2****</span>
        <span class="n">floats</span> <span class="o">=</span> <span class="n">_parse_from_incar</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">param_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">floats</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">err</span> <span class="kn">from</span><span class="w"> </span><span class="nn">exc</span>

    <span class="k">return</span> <span class="n">floats</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_parse_vasp_array</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
    <span class="k">if</span> <span class="n">elem</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;logical&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[[</span><span class="n">i</span> <span class="o">==</span> <span class="s2">&quot;T&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">[[</span><span class="n">_vasprun_float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_parse_from_incar</span><span class="p">(</span><span class="n">filename</span><span class="p">:</span> <span class="n">PathLike</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper function to parse a parameter from the INCAR.&quot;&quot;&quot;</span>
    <span class="n">dirname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">dirname</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;INCAR&quot;</span><span class="p">,</span> <span class="n">fn</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;INCAR found. Using </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> from INCAR.&quot;</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">incar</span> <span class="o">=</span> <span class="n">Incar</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span> <span class="n">fn</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">incar</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">None</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_vasprun_float</span><span class="p">(</span><span class="n">flt</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Large numbers are often represented as ********* in the vasprun.</span>
<span class="sd">    This function parses these values as np.nan.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">flt</span><span class="p">)</span>

    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="n">flt</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">flt</span><span class="p">)</span>
        <span class="n">_flt</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">flt</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">_flt</span> <span class="o">==</span> <span class="s2">&quot;*&quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">_flt</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Float overflow (*******) encountered in vasprun&quot;</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">raise</span>


<div class="viewcode-block" id="KpointOptProps">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.KpointOptProps">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">KpointOptProps</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Simple container class to store KPOINTS_OPT data in a separate namespace. Used by Vasprun.&quot;&quot;&quot;</span>

    <span class="n">tdos</span><span class="p">:</span> <span class="n">Dos</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">idos</span><span class="p">:</span> <span class="n">Dos</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">pdos</span><span class="p">:</span> <span class="nb">list</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">efermi</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">eigenvalues</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">projected_eigenvalues</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">projected_magnetisation</span><span class="p">:</span> <span class="n">NDArray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">kpoints</span><span class="p">:</span> <span class="n">Kpoints</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">actual_kpoints</span><span class="p">:</span> <span class="nb">list</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">actual_kpoints_weights</span><span class="p">:</span> <span class="nb">list</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">dos_has_errors</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="Vasprun">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Vasprun">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Vasprun</span><span class="p">(</span><span class="n">MSONable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Vastly improved cElementTree-based parser for vasprun.xml files. Uses</span>
<span class="sd">    iterparse to support incremental parsing of large files.</span>
<span class="sd">    Speedup over Dom is at least 2x for smallish files (~1 Mb) to orders of</span>
<span class="sd">    magnitude for larger files (~10 Mb).</span>

<span class="sd">    **VASP results**</span>

<span class="sd">    Attributes:</span>
<span class="sd">        ionic_steps (list): All ionic steps in the run as a list of {&quot;structure&quot;: structure at end of run,</span>
<span class="sd">            &quot;electronic_steps&quot;: {All electronic step data in vasprun file}, &quot;stresses&quot;: stress matrix}.</span>
<span class="sd">        tdos (Dos): Total dos calculated at the end of run. Note that this is rounded to 4 decimal</span>
<span class="sd">            places by VASP.</span>
<span class="sd">        idos (Dos): Integrated dos calculated at the end of run. Rounded to 4 decimal places by VASP.</span>
<span class="sd">        pdos (list): List of list of PDos objects. Access as pdos[atomindex][orbitalindex].</span>
<span class="sd">        efermi (float): Fermi energy.</span>
<span class="sd">        eigenvalues (dict): Final eigenvalues as a dict of {(spin, kpoint index):[[eigenvalue, occu]]}.</span>
<span class="sd">            The kpoint index is 0-based (unlike the 1-based indexing in VASP).</span>
<span class="sd">        projected_eigenvalues (dict): Final projected eigenvalues as a dict of {spin: nd-array}.</span>
<span class="sd">            To access a particular value, you need to do</span>
<span class="sd">            Vasprun.projected_eigenvalues[spin][kpoint index][band index][atom index][orbital_index].</span>
<span class="sd">            The kpoint, band and atom indices are 0-based (unlike the 1-based indexing in VASP).</span>
<span class="sd">        projected_magnetisation (NDArray): Final projected magnetization as a numpy array with the</span>
<span class="sd">            shape (nkpoints, nbands, natoms, norbitals, 3). Where the last axis is the contribution in the</span>
<span class="sd">            3 Cartesian directions. This attribute is only set if spin-orbit coupling (LSORBIT = True) or</span>
<span class="sd">            non-collinear magnetism (LNONCOLLINEAR = True) is turned on in the INCAR.</span>
<span class="sd">        dielectric_data (dict): Dictionary, with the tag comment as key, containing other variants of</span>
<span class="sd">            the real and imaginary part of the dielectric constant (e.g., computed by RPA) in function of</span>
<span class="sd">            the energy (frequency). Optical properties (e.g. absorption coefficient) can be obtained through this.</span>
<span class="sd">            The data is given as a tuple of 3 values containing each of them the energy, the real part tensor,</span>
<span class="sd">            and the imaginary part tensor ([energies],[[real_partxx,real_partyy,real_partzz,real_partxy,</span>
<span class="sd">            real_partyz,real_partxz]],[[imag_partxx,imag_partyy,imag_partzz,imag_partxy, imag_partyz, imag_partxz]]).</span>
<span class="sd">            The data can be the current, density or freq_dependent (BSE) dielectric data.</span>
<span class="sd">        nionic_steps (int): The total number of ionic steps. This number is always equal to the total number</span>
<span class="sd">            of steps in the actual run even if ionic_step_skip is used.</span>
<span class="sd">        force_constants (NDArray): Force constants computed in phonon DFPT run(IBRION = 8).</span>
<span class="sd">            The data is a 4D array of shape (natoms, natoms, 3, 3).</span>
<span class="sd">        normalmode_eigenvals (NDArray): Normal mode frequencies. 1D array of size 3*natoms.</span>
<span class="sd">        normalmode_eigenvecs (NDArray): Normal mode eigen vectors. 3D array of shape (3*natoms, natoms, 3).</span>
<span class="sd">        md_data (list): Available only for ML MD runs, i.e., INCAR with ML_LMLFF = .TRUE. md_data is a list of</span>
<span class="sd">            dict with the following format: [{&#39;energy&#39;: {&#39;e_0_energy&#39;: -525.07195568, &#39;e_fr_energy&#39;: -525.07195568,</span>
<span class="sd">            &#39;e_wo_entrp&#39;: -525.07195568, &#39;kinetic&#39;: 3.17809233, &#39;lattice kinetic&#39;: 0.0, &#39;nosekinetic&#39;: 1.323e-5,</span>
<span class="sd">            &#39;nosepot&#39;: 0.0, &#39;total&#39;: -521.89385012}, &#39;forces&#39;: [[0.17677989, 0.48309874, 1.85806696], ...],</span>
<span class="sd">            &#39;structure&#39;: Structure object}].</span>
<span class="sd">        incar (Incar): Incar object for parameters specified in INCAR file.</span>
<span class="sd">        parameters (Incar): Incar object with parameters that VASP actually used, including all defaults.</span>
<span class="sd">        kpoints (Kpoints): Kpoints object for KPOINTS specified in run.</span>
<span class="sd">        actual_kpoints (list): List of actual kpoints, e.g. [[0.25, 0.125, 0.08333333], [-0.25, 0.125, 0.08333333],</span>
<span class="sd">            [0.25, 0.375, 0.08333333], ....].</span>
<span class="sd">        actual_kpoints_weights (list): List of kpoint weights, e.g. [0.04166667, 0.04166667, 0.04166667, 0.04166667,</span>
<span class="sd">            0.04166667, ....].</span>
<span class="sd">        atomic_symbols (list): List of atomic symbols, e.g. [&quot;Li&quot;, &quot;Fe&quot;, &quot;Fe&quot;, &quot;P&quot;, &quot;P&quot;, &quot;P&quot;].</span>
<span class="sd">        potcar_symbols (list): List of POTCAR symbols. e.g. [&quot;PAW_PBE Li 17Jan2003&quot;, &quot;PAW_PBE Fe 06Sep2000&quot;, ..].</span>
<span class="sd">        kpoints_opt_props (object): Object whose attributes are the data from KPOINTS_OPT (if present,</span>
<span class="sd">            else None). Attributes of the same name have the same format and meaning as Vasprun (or they are</span>
<span class="sd">            None if absent). Attributes are: tdos, idos, pdos, efermi, eigenvalues, projected_eigenvalues,</span>
<span class="sd">            projected magnetisation, kpoints, actual_kpoints, actual_kpoints_weights, dos_has_errors.</span>

<span class="sd">    Author: Shyue Ping Ong</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filename</span><span class="p">:</span> <span class="n">PathLike</span><span class="p">,</span>
        <span class="n">ionic_step_skip</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ionic_step_offset</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">parse_dos</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">parse_eigen</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">parse_projected_eigen</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">parse_potcar_file</span><span class="p">:</span> <span class="n">PathLike</span> <span class="o">|</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">occu_tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">,</span>
        <span class="n">separate_spins</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">exception_on_bad_xml</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            filename (str): Filename to parse</span>
<span class="sd">            ionic_step_skip (int): If ionic_step_skip is a number &gt; 1,</span>
<span class="sd">                only every ionic_step_skip ionic steps will be read for</span>
<span class="sd">                structure and energies. This is very useful if you are parsing</span>
<span class="sd">                very large vasprun.xml files and you are not interested in every</span>
<span class="sd">                single ionic step. Note that the final energies may not be the</span>
<span class="sd">                actual final energy in the vasprun.</span>
<span class="sd">            ionic_step_offset (int): Used together with ionic_step_skip. If set,</span>
<span class="sd">                the first ionic step read will be offset by the amount of</span>
<span class="sd">                ionic_step_offset. For example, if you want to start reading</span>
<span class="sd">                every 10th structure but only from the 3rd structure onwards,</span>
<span class="sd">                set ionic_step_skip to 10 and ionic_step_offset to 3. Main use</span>
<span class="sd">                case is when doing statistical structure analysis with</span>
<span class="sd">                extremely long time scale multiple VASP calculations of</span>
<span class="sd">                varying numbers of steps.</span>
<span class="sd">            parse_dos (bool): Whether to parse the dos. Defaults to True. Set</span>
<span class="sd">                to False to shave off significant time from the parsing if you</span>
<span class="sd">                are not interested in getting those data.</span>
<span class="sd">                Note that the DOS output from VASP is rounded to 4 decimal places,</span>
<span class="sd">                which can give some slight inaccuracies.</span>
<span class="sd">            parse_eigen (bool): Whether to parse the eigenvalues. Defaults to</span>
<span class="sd">                True. Set to False to shave off significant time from the</span>
<span class="sd">                parsing if you are not interested in getting those data.</span>
<span class="sd">            parse_projected_eigen (bool): Whether to parse the projected</span>
<span class="sd">                eigenvalues and magnetization. Defaults to False. Set to True to obtain</span>
<span class="sd">                projected eigenvalues and magnetization. **Note that this can take an</span>
<span class="sd">                extreme amount of time and memory.** So use this wisely.</span>
<span class="sd">            parse_potcar_file (bool | PathLike): Whether to parse the potcar file to read</span>
<span class="sd">                the potcar hashes for the potcar_spec attribute. Defaults to True,</span>
<span class="sd">                where no hashes will be determined and the potcar_spec dictionaries</span>
<span class="sd">                will read {&quot;symbol&quot;: ElSymbol, &quot;hash&quot;: None}. By Default, looks in</span>
<span class="sd">                the same directory as the vasprun.xml, with same extensions as</span>
<span class="sd">                Vasprun.xml. If a path is provided, look at that path.</span>
<span class="sd">            occu_tol (float): Sets the minimum tol for the determination of the</span>
<span class="sd">                vbm and cbm. Usually the default of 1e-8 works well enough,</span>
<span class="sd">                but there may be pathological cases.</span>
<span class="sd">            separate_spins (bool): Whether the band gap, CBM, and VBM should be</span>
<span class="sd">                reported for each individual spin channel. Defaults to False,</span>
<span class="sd">                which computes the eigenvalue band properties independent of</span>
<span class="sd">                the spin orientation. If True, the calculation must be spin-polarized.</span>
<span class="sd">            exception_on_bad_xml (bool): Whether to throw a ParseException if a</span>
<span class="sd">                malformed XML is detected. Default to True, which ensures only</span>
<span class="sd">                proper vasprun.xml are parsed. You can set to False if you want</span>
<span class="sd">                partial results (e.g., if you are monitoring a calculation during a</span>
<span class="sd">                run), but use the results with care. A warning is issued.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ionic_step_skip</span> <span class="o">=</span> <span class="n">ionic_step_skip</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ionic_step_offset</span> <span class="o">=</span> <span class="n">ionic_step_offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">occu_tol</span> <span class="o">=</span> <span class="n">occu_tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">separate_spins</span> <span class="o">=</span> <span class="n">separate_spins</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exception_on_bad_xml</span> <span class="o">=</span> <span class="n">exception_on_bad_xml</span>

        <span class="k">with</span> <span class="n">zopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;rt&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ionic_step_skip</span> <span class="ow">or</span> <span class="n">ionic_step_offset</span><span class="p">:</span>
                <span class="c1"># Remove parts of the xml file and parse the string</span>
                <span class="n">content</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
                <span class="n">steps</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">content</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;&lt;calculation&gt;&quot;</span><span class="p">)</span>

                <span class="c1"># The text before the first &lt;calculation&gt; is the preamble!</span>
                <span class="n">preamble</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">steps</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nionic_steps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span>
                <span class="n">new_steps</span> <span class="o">=</span> <span class="n">steps</span><span class="p">[</span><span class="n">ionic_step_offset</span> <span class="p">::</span> <span class="nb">int</span><span class="p">(</span><span class="n">ionic_step_skip</span> <span class="ow">or</span> <span class="mi">1</span><span class="p">)]</span>

                <span class="c1"># Add the tailing information in the last step from the run</span>
                <span class="n">to_parse</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&lt;calculation&gt;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">new_steps</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">steps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">new_steps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">to_parse</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">preamble</span><span class="si">}</span><span class="s2">&lt;calculation&gt;</span><span class="si">{</span><span class="n">to_parse</span><span class="si">}{</span><span class="n">steps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;&lt;/calculation&gt;&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">to_parse</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">preamble</span><span class="si">}</span><span class="s2">&lt;calculation&gt;</span><span class="si">{</span><span class="n">to_parse</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span>
                    <span class="n">StringIO</span><span class="p">(</span><span class="n">to_parse</span><span class="p">),</span>
                    <span class="n">parse_dos</span><span class="o">=</span><span class="n">parse_dos</span><span class="p">,</span>
                    <span class="n">parse_eigen</span><span class="o">=</span><span class="n">parse_eigen</span><span class="p">,</span>
                    <span class="n">parse_projected_eigen</span><span class="o">=</span><span class="n">parse_projected_eigen</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span>
                    <span class="n">file</span><span class="p">,</span>
                    <span class="n">parse_dos</span><span class="o">=</span><span class="n">parse_dos</span><span class="p">,</span>
                    <span class="n">parse_eigen</span><span class="o">=</span><span class="n">parse_eigen</span><span class="p">,</span>
                    <span class="n">parse_projected_eigen</span><span class="o">=</span><span class="n">parse_projected_eigen</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nionic_steps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ionic_steps</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">parse_potcar_file</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_potcar_spec</span><span class="p">(</span><span class="n">parse_potcar_file</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_charge_from_potcar</span><span class="p">(</span><span class="n">parse_potcar_file</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">incar</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ALGO&quot;</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;Chi&quot;</span><span class="p">,</span> <span class="s2">&quot;Bse&quot;</span><span class="p">}</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">converged</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;IBRION&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2"> is an unconverged VASP run.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;Electronic convergence reached: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">converged_electronic</span><span class="si">}</span><span class="s2">.</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;Ionic convergence reached: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">converged_ionic</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="n">msg</span><span class="p">,</span>
                <span class="n">UnconvergedVASPWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_parse</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">stream</span><span class="p">,</span>
        <span class="n">parse_dos</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">parse_eigen</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">parse_projected_eigen</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">efermi</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">projected_eigenvalues</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">projected_magnetisation</span><span class="p">:</span> <span class="n">NDArray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">incar</span><span class="p">:</span> <span class="n">Incar</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kpoints_opt_props</span><span class="p">:</span> <span class="n">KpointOptProps</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">ionic_steps</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">md_data</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">parsed_header</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">in_kpoints_opt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># When parsing XML, start tags tell us when we have entered a block</span>
            <span class="c1"># while end tags are when we have actually read the data.</span>
            <span class="c1"># To know if a particular tag is nested within another block,</span>
            <span class="c1"># we have to read the start tags (otherwise we will only learn of</span>
            <span class="c1"># the nesting after we have left the data behind).</span>
            <span class="c1"># When parsing KPOINTS_OPT data, some of the tags in vasprun.xml</span>
            <span class="c1"># can only be distinguished from their regular counterparts by</span>
            <span class="c1"># whether they are nested within another block. This is why we</span>
            <span class="c1"># must read both start and end tags and have flags to tell us</span>
            <span class="c1"># when we have entered or left a block. (2024-01-26)</span>
            <span class="k">for</span> <span class="n">event</span><span class="p">,</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">ET</span><span class="o">.</span><span class="n">iterparse</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">events</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">,</span> <span class="s2">&quot;end&quot;</span><span class="p">]):</span>
                <span class="n">tag</span> <span class="o">=</span> <span class="n">elem</span><span class="o">.</span><span class="n">tag</span>
                <span class="k">if</span> <span class="n">event</span> <span class="o">==</span> <span class="s2">&quot;start&quot;</span><span class="p">:</span>
                    <span class="c1"># The start event tells us when we have entered blocks</span>
                    <span class="k">if</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;calculation&quot;</span><span class="p">:</span>
                        <span class="n">parsed_header</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">elif</span> <span class="n">tag</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;eigenvalues_kpoints_opt&quot;</span><span class="p">,</span> <span class="s2">&quot;projected_kpoints_opt&quot;</span><span class="p">):</span>
                        <span class="n">in_kpoints_opt</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="k">else</span><span class="p">:</span>  <span class="c1"># event == &quot;end&quot;:</span>
                    <span class="c1"># The end event happens when we have read a block, so have</span>
                    <span class="c1"># its data.</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">parsed_header</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;generator&quot;</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">generator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_params</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;incar&quot;</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">incar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_params</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;kpoints&quot;</span><span class="p">:</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;kpoints&quot;</span><span class="p">):</span>
                                <span class="p">(</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">kpoints</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">actual_kpoints</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">actual_kpoints_weights</span><span class="p">,</span>
                                <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_kpoints</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;parameters&quot;</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_params</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;structure&quot;</span> <span class="ow">and</span> <span class="n">elem</span><span class="o">.</span><span class="n">attrib</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;initialpos&quot;</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">initial_structure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_structure</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">final_structure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_structure</span>
                        <span class="k">elif</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;atominfo&quot;</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">atomic_symbols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">potcar_symbols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_atominfo</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">potcar_spec</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                                <span class="p">{</span><span class="s2">&quot;titel&quot;</span><span class="p">:</span> <span class="n">titel</span><span class="p">,</span> <span class="s2">&quot;hash&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;summary_stats&quot;</span><span class="p">:</span> <span class="p">{}}</span> <span class="k">for</span> <span class="n">titel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">potcar_symbols</span>
                            <span class="p">]</span>

                    <span class="k">if</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;calculation&quot;</span><span class="p">:</span>
                        <span class="n">parsed_header</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;LCHIMAG&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                            <span class="n">ionic_steps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parse_ionic_step</span><span class="p">(</span><span class="n">elem</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">ionic_steps</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parse_chemical_shielding</span><span class="p">(</span><span class="n">elem</span><span class="p">))</span>

                    <span class="k">elif</span> <span class="n">parse_dos</span> <span class="ow">and</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;dos&quot;</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">elem</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;comment&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;kpoints_opt&quot;</span><span class="p">:</span>
                            <span class="n">kpoints_opt_props</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kpoints_opt_props</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kpoints_opt_props</span> <span class="ow">or</span> <span class="n">KpointOptProps</span><span class="p">()</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="p">(</span>
                                    <span class="n">kpoints_opt_props</span><span class="o">.</span><span class="n">tdos</span><span class="p">,</span>
                                    <span class="n">kpoints_opt_props</span><span class="o">.</span><span class="n">idos</span><span class="p">,</span>
                                    <span class="n">kpoints_opt_props</span><span class="o">.</span><span class="n">pdos</span><span class="p">,</span>
                                <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_dos</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
                                <span class="n">kpoints_opt_props</span><span class="o">.</span><span class="n">efermi</span> <span class="o">=</span> <span class="n">kpoints_opt_props</span><span class="o">.</span><span class="n">tdos</span><span class="o">.</span><span class="n">efermi</span>
                                <span class="n">kpoints_opt_props</span><span class="o">.</span><span class="n">dos_has_errors</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                                <span class="n">kpoints_opt_props</span><span class="o">.</span><span class="n">dos_has_errors</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">tdos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">idos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_dos</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">efermi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tdos</span><span class="o">.</span><span class="n">efermi</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">dos_has_errors</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">dos_has_errors</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="k">elif</span> <span class="n">parse_eigen</span> <span class="ow">and</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;eigenvalues&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">in_kpoints_opt</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_eigen</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>

                    <span class="k">elif</span> <span class="n">parse_projected_eigen</span> <span class="ow">and</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;projected&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">in_kpoints_opt</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">projected_eigenvalues</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">projected_magnetisation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_projected_eigen</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>

                    <span class="k">elif</span> <span class="n">tag</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;eigenvalues_kpoints_opt&quot;</span><span class="p">,</span> <span class="s2">&quot;projected_kpoints_opt&quot;</span><span class="p">):</span>
                        <span class="n">in_kpoints_opt</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kpoints_opt_props</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">kpoints_opt_props</span> <span class="o">=</span> <span class="n">KpointOptProps</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">parse_eigen</span><span class="p">:</span>
                            <span class="c1"># projected_kpoints_opt includes occupation information whereas</span>
                            <span class="c1"># eigenvalues_kpoints_opt doesn&#39;t.</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">kpoints_opt_props</span><span class="o">.</span><span class="n">eigenvalues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_eigen</span><span class="p">(</span><span class="n">elem</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;eigenvalues&quot;</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;eigenvalues_kpoints_opt&quot;</span><span class="p">:</span>
                            <span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">kpoints_opt_props</span><span class="o">.</span><span class="n">kpoints</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">kpoints_opt_props</span><span class="o">.</span><span class="n">actual_kpoints</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">kpoints_opt_props</span><span class="o">.</span><span class="n">actual_kpoints_weights</span><span class="p">,</span>
                            <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_kpoints</span><span class="p">(</span><span class="n">elem</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;kpoints&quot;</span><span class="p">))</span>
                        <span class="k">elif</span> <span class="n">parse_projected_eigen</span><span class="p">:</span>  <span class="c1"># and tag == &quot;projected_kpoints_opt&quot;: (implied)</span>
                            <span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">kpoints_opt_props</span><span class="o">.</span><span class="n">projected_eigenvalues</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">kpoints_opt_props</span><span class="o">.</span><span class="n">projected_magnetisation</span><span class="p">,</span>
                            <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_projected_eigen</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>

                    <span class="k">elif</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;dielectricfunction&quot;</span><span class="p">:</span>
                        <span class="n">label</span> <span class="o">=</span> <span class="n">elem</span><span class="o">.</span><span class="n">attrib</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;comment&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">incar</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ALGO&quot;</span><span class="p">,</span> <span class="s2">&quot;Normal&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;Bse&quot;</span><span class="p">:</span>
                                <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;freq_dependent&quot;</span>
                            <span class="k">elif</span> <span class="s2">&quot;density&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_data</span><span class="p">:</span>
                                <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;density&quot;</span>
                            <span class="k">elif</span> <span class="s2">&quot;velocity&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_data</span><span class="p">:</span>
                                <span class="c1"># &quot;velocity-velocity&quot; is also named</span>
                                <span class="c1"># &quot;current-current&quot; in OUTCAR</span>
                                <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;velocity&quot;</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                                    <span class="s2">&quot;Additional unlabelled dielectric data in vasprun.xml are stored as unlabelled.&quot;</span><span class="p">,</span>
                                    <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                <span class="p">)</span>
                                <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;unlabelled&quot;</span>
                        <span class="c1"># VASP 6+ has labels for the density and current</span>
                        <span class="c1"># derived dielectric constants</span>

                        <span class="k">if</span> <span class="n">label</span> <span class="o">==</span> <span class="s2">&quot;density-density&quot;</span><span class="p">:</span>
                            <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;density&quot;</span>
                        <span class="k">elif</span> <span class="n">label</span> <span class="o">==</span> <span class="s2">&quot;current-current&quot;</span><span class="p">:</span>
                            <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;velocity&quot;</span>

                        <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_data</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_diel</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>

                    <span class="k">elif</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;varray&quot;</span> <span class="ow">and</span> <span class="n">elem</span><span class="o">.</span><span class="n">attrib</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;opticaltransitions&quot;</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">optical_transition</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">_parse_vasp_array</span><span class="p">(</span><span class="n">elem</span><span class="p">))</span>

                    <span class="k">elif</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;structure&quot;</span> <span class="ow">and</span> <span class="n">elem</span><span class="o">.</span><span class="n">attrib</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;finalpos&quot;</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">final_structure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_structure</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>

                    <span class="k">elif</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;dynmat&quot;</span><span class="p">:</span>
                        <span class="n">hessian</span><span class="p">,</span> <span class="n">eigenvalues</span><span class="p">,</span> <span class="n">eigenvectors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_dynmat</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
                        <span class="c1"># n_atoms is not the total number of atoms, only those for which force constants were calculated</span>
                        <span class="c1"># https://github.com/materialsproject/pymatgen/issues/3084</span>
                        <span class="n">n_atoms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">hessian</span><span class="p">)</span> <span class="o">//</span> <span class="mi">3</span>
                        <span class="n">hessian</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hessian</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">force_constants</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_atoms</span><span class="p">,</span> <span class="n">n_atoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;double&quot;</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_atoms</span><span class="p">):</span>
                            <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_atoms</span><span class="p">):</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">force_constants</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">hessian</span><span class="p">[</span><span class="n">ii</span> <span class="o">*</span> <span class="mi">3</span> <span class="p">:</span> <span class="p">(</span><span class="n">ii</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="n">jj</span> <span class="o">*</span> <span class="mi">3</span> <span class="p">:</span> <span class="p">(</span><span class="n">jj</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">]</span>  <span class="c1"># type: ignore[call-overload]</span>
                        <span class="n">phonon_eigenvectors</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">ev</span> <span class="ow">in</span> <span class="n">eigenvectors</span><span class="p">:</span>
                            <span class="n">phonon_eigenvectors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ev</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_atoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">normalmode_eigenvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">eigenvalues</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">normalmode_eigenvecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">phonon_eigenvectors</span><span class="p">)</span>

                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">incar</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ML_LMLFF&quot;</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;structure&quot;</span> <span class="ow">and</span> <span class="n">elem</span><span class="o">.</span><span class="n">attrib</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">md_data</span><span class="o">.</span><span class="n">append</span><span class="p">({})</span>
                            <span class="n">md_data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;structure&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_structure</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;varray&quot;</span> <span class="ow">and</span> <span class="n">elem</span><span class="o">.</span><span class="n">attrib</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;forces&quot;</span><span class="p">:</span>
                            <span class="n">md_data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;forces&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_parse_vasp_array</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;varray&quot;</span> <span class="ow">and</span> <span class="n">elem</span><span class="o">.</span><span class="n">attrib</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;stress&quot;</span><span class="p">:</span>
                            <span class="n">md_data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;stress&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_parse_vasp_array</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;energy&quot;</span><span class="p">:</span>
                            <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]:</span> <span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">text</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">elem</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">)}</span>
                            <span class="k">if</span> <span class="s2">&quot;kinetic&quot;</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
                                <span class="n">md_data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;energy&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]:</span> <span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">text</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">elem</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">)}</span>

        <span class="k">except</span> <span class="n">ET</span><span class="o">.</span><span class="n">ParseError</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exception_on_bad_xml</span><span class="p">:</span>
                <span class="k">raise</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;XML is malformed. Parsing has stopped but partial data is available.&quot;</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ionic_steps</span> <span class="o">=</span> <span class="n">ionic_steps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">md_data</span> <span class="o">=</span> <span class="n">md_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vasp_version</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="p">[</span><span class="s2">&quot;version&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">structures</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Structure</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;List of Structures for each ionic step.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">step</span><span class="p">[</span><span class="s2">&quot;structure&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ionic_steps</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">epsilon_static</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The static part of the dielectric constant.</span>
<span class="sd">        Present only when it&#39;s a DFPT run (LEPSILON=TRUE).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ionic_steps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;epsilon&quot;</span><span class="p">,</span> <span class="p">[])</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">epsilon_static_wolfe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The static part of the dielectric constant without any local</span>
<span class="sd">        field effects. Present only when it&#39;s a DFPT run (LEPSILON=TRUE).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ionic_steps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;epsilon_rpa&quot;</span><span class="p">,</span> <span class="p">[])</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">epsilon_ionic</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The ionic part of the static dielectric constant.</span>
<span class="sd">        Present when it&#39;s a DFPT run (LEPSILON=TRUE) and IBRION=5, 6, 7 or 8.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ionic_steps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;epsilon_ion&quot;</span><span class="p">,</span> <span class="p">[])</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dielectric</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">list</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The real and imaginary part of the dielectric constant (e.g.,</span>
<span class="sd">        computed by RPA) in function of the energy (frequency).</span>
<span class="sd">        Optical properties (e.g. absorption coefficient) can be obtained through this.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The data is given as a tuple of 3 for the energy, the real part</span>
<span class="sd">            tensor, and the imaginary part tensor:</span>
<span class="sd">            ([energies], [[real_partxx, real_partyy, real_partzz, real_partxy,</span>
<span class="sd">            real_partyz, real_partxz]], [[imag_partxx, imag_partyy, imag_partzz,</span>
<span class="sd">            imag_partxy, imag_partyz, imag_partxz]]).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_data</span><span class="p">[</span><span class="s2">&quot;density&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">optical_absorption_coeff</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The optical absorption coefficient from the dielectric constants.</span>
<span class="sd">        Note that this method is only implemented for optical properties</span>
<span class="sd">        calculated with GGA and BSE.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">diel_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;freq_dependent&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_data</span><span class="p">[</span><span class="s2">&quot;density&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">diel_data</span><span class="p">:</span>
            <span class="n">real_avg</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">diel_data</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">][:</span><span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="mi">3</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">diel_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]))]</span>
            <span class="n">imag_avg</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">diel_data</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">][:</span><span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="mi">3</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">diel_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]))]</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">optical_absorb_coeff</span><span class="p">(</span><span class="n">freq</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">real</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">imag</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;Calculate optical absorption coefficient,</span>
<span class="sd">                the unit is cm^-1.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="n">hc</span> <span class="o">=</span> <span class="mf">1.23984</span> <span class="o">*</span> <span class="mf">1e-4</span>  <span class="c1"># plank constant times speed of light, in the unit of eV*cm</span>
                <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="mf">3.14159</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">real</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">imag</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">real</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">hc</span> <span class="o">*</span> <span class="n">freq</span>

            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span>
                <span class="n">itertools</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span>
                    <span class="n">optical_absorb_coeff</span><span class="p">,</span>
                    <span class="nb">zip</span><span class="p">(</span>
                        <span class="n">diel_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                        <span class="n">real_avg</span><span class="p">,</span>
                        <span class="n">imag_avg</span><span class="p">,</span>
                        <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="p">),</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">converged_electronic</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether electronic step converged in the final ionic step.&quot;&quot;&quot;</span>
        <span class="n">final_elec_steps</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">|</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ionic_steps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;electronic_steps&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">incar</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ALGO&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;chi&quot;</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="p">)</span>
        <span class="c1"># In a response function run there is no ionic steps, there is no SCF step</span>
        <span class="k">if</span> <span class="n">final_elec_steps</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;there is no ionic step in response function ALGO=CHI.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">incar</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;LEPSILON&quot;</span><span class="p">):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">to_check</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;e_wo_entrp&quot;</span><span class="p">,</span> <span class="s2">&quot;e_fr_energy&quot;</span><span class="p">,</span> <span class="s2">&quot;e_0_energy&quot;</span><span class="p">}</span>
            <span class="k">while</span> <span class="nb">set</span><span class="p">(</span><span class="n">final_elec_steps</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="o">==</span> <span class="n">to_check</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;NELM&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">incar</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ALGO&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;Exact&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">incar</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;NELM&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">final_elec_steps</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;NELM&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">converged_ionic</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether ionic step convergence has been reached, i.e. VASP</span>
<span class="sd">        exited before reaching the max ionic steps for a relaxation run.</span>
<span class="sd">        In case IBRION=0 (MD) or EDIFFG=0, returns True if the max ionic</span>
<span class="sd">        steps are reached.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nsw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;NSW&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">ibrion</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;IBRION&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">nsw</span> <span class="ow">in</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ibrion</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">nsw</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">md_n_steps</span> <span class="o">==</span> <span class="n">nsw</span>

        <span class="c1"># Context re EDIFFG: the use case for EDIFFG=0 is to ensure a relaxation runs for</span>
        <span class="c1"># NSW steps (the non-AIMD way to generate a relaxation trajectory with DFT). In</span>
        <span class="c1"># that case, user isn&#39;t worried about convergence w.r.t. forces or energy. The</span>
        <span class="c1"># next if statement prevents custodian from trying to correct the calc because</span>
        <span class="c1"># Vasprun.converged_ionic = False.</span>
        <span class="n">ediffg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;EDIFFG&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ibrion</span> <span class="ow">in</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span> <span class="ow">and</span> <span class="n">ediffg</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">nsw</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">nsw</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ionic_steps</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">nsw</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ionic_steps</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">nsw</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">converged</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether a relaxation run has both ionically and</span>
<span class="sd">        electronically converged.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">converged_electronic</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">converged_ionic</span>

    <span class="nd">@property</span>
    <span class="nd">@unitized</span><span class="p">(</span><span class="s2">&quot;eV&quot;</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">final_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Final energy from the VASP run.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">final_istep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ionic_steps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">total_energy</span> <span class="o">=</span> <span class="n">final_istep</span><span class="p">[</span><span class="s2">&quot;e_0_energy&quot;</span><span class="p">]</span>

            <span class="c1"># Fix a bug in vasprun.xml.</span>
            <span class="c1"># See https://www.vasp.at/forum/viewtopic.php?f=3&amp;t=16942</span>
            <span class="n">final_estep</span> <span class="o">=</span> <span class="n">final_istep</span><span class="p">[</span><span class="s2">&quot;electronic_steps&quot;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">electronic_energy_diff</span> <span class="o">=</span> <span class="n">final_estep</span><span class="p">[</span><span class="s2">&quot;e_0_energy&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">final_estep</span><span class="p">[</span><span class="s2">&quot;e_fr_energy&quot;</span><span class="p">]</span>
            <span class="n">total_energy_bugfix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">electronic_energy_diff</span> <span class="o">+</span> <span class="n">final_istep</span><span class="p">[</span><span class="s2">&quot;e_fr_energy&quot;</span><span class="p">],</span> <span class="mi">8</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">total_energy</span> <span class="o">-</span> <span class="n">total_energy_bugfix</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-7</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">total_energy_bugfix</span>

            <span class="k">return</span> <span class="n">total_energy</span>

        <span class="k">except</span> <span class="p">(</span><span class="ne">IndexError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Calculation does not have a total energy. Possibly a GW or similar kind of run. Infinity is returned.&quot;</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">complete_dos</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CompleteDos</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A CompleteDos object which incorporates the total DOS and all projected DOS.&quot;&quot;&quot;</span>
        <span class="n">final_struct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_structure</span>
        <span class="n">pdoss</span> <span class="o">=</span> <span class="p">{</span><span class="n">final_struct</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">pdos</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pdos</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdos</span><span class="p">)}</span>
        <span class="k">return</span> <span class="n">CompleteDos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">final_structure</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tdos</span><span class="p">,</span> <span class="n">pdoss</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">complete_dos_normalized</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CompleteDos</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A CompleteDos object which incorporates the total DOS and all projected DOS.</span>
<span class="sd">        Normalized by the volume of the unit cell with units of states/eV/unit cell</span>
<span class="sd">        volume.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">final_struct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_structure</span>
        <span class="n">pdoss</span> <span class="o">=</span> <span class="p">{</span><span class="n">final_struct</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">pdos</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pdos</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdos</span><span class="p">)}</span>
        <span class="k">return</span> <span class="n">CompleteDos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">final_structure</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tdos</span><span class="p">,</span> <span class="n">pdoss</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">hubbards</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Hubbard U values used for a GGA+U run, otherwise an empty dict.&quot;&quot;&quot;</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">potcar_symbols</span><span class="p">]</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">incar</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;LDAU&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{}</span>

        <span class="n">us</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">incar</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;LDAUU&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;LDAUU&quot;</span><span class="p">))</span>
        <span class="n">js</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">incar</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;LDAUJ&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;LDAUJ&quot;</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">js</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">us</span><span class="p">):</span>
            <span class="n">js</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">us</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">us</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">symbols</span><span class="p">[</span><span class="n">idx</span><span class="p">]:</span> <span class="n">us</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">js</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">))}</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">us</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">sum</span><span class="p">(</span><span class="n">js</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span>

        <span class="k">raise</span> <span class="n">VaspParseError</span><span class="p">(</span><span class="s2">&quot;Length of U value parameters and atomic symbols are mismatched&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">run_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The run type. Currently detects GGA, metaGGA, HF, HSE, B3LYP,</span>
<span class="sd">        and hybrid functionals based on relevant INCAR tags. LDA is assigned if</span>
<span class="sd">        PAW POTCARs are used and no other functional is detected.</span>

<span class="sd">        Hubbard U terms and vdW corrections are detected automatically as well.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Care should be taken: if a GGA tag is not specified, VASP will default</span>
        <span class="c1"># to the functional specified by the POTCAR. It is not clear how</span>
        <span class="c1"># VASP handles the &quot;--&quot; value.</span>
        <span class="n">GGA_TYPES</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;RE&quot;</span><span class="p">:</span> <span class="s2">&quot;revPBE&quot;</span><span class="p">,</span>
            <span class="s2">&quot;PE&quot;</span><span class="p">:</span> <span class="s2">&quot;PBE&quot;</span><span class="p">,</span>
            <span class="s2">&quot;PS&quot;</span><span class="p">:</span> <span class="s2">&quot;PBEsol&quot;</span><span class="p">,</span>
            <span class="s2">&quot;RP&quot;</span><span class="p">:</span> <span class="s2">&quot;revPBE+Pad&quot;</span><span class="p">,</span>
            <span class="s2">&quot;AM&quot;</span><span class="p">:</span> <span class="s2">&quot;AM05&quot;</span><span class="p">,</span>
            <span class="s2">&quot;OR&quot;</span><span class="p">:</span> <span class="s2">&quot;optPBE&quot;</span><span class="p">,</span>
            <span class="s2">&quot;BO&quot;</span><span class="p">:</span> <span class="s2">&quot;optB88&quot;</span><span class="p">,</span>
            <span class="s2">&quot;MK&quot;</span><span class="p">:</span> <span class="s2">&quot;optB86b&quot;</span><span class="p">,</span>
            <span class="s2">&quot;--&quot;</span><span class="p">:</span> <span class="s2">&quot;GGA&quot;</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">METAGGA_TYPES</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;TPSS&quot;</span><span class="p">:</span> <span class="s2">&quot;TPSS&quot;</span><span class="p">,</span>
            <span class="s2">&quot;RTPSS&quot;</span><span class="p">:</span> <span class="s2">&quot;revTPSS&quot;</span><span class="p">,</span>
            <span class="s2">&quot;M06L&quot;</span><span class="p">:</span> <span class="s2">&quot;M06-L&quot;</span><span class="p">,</span>
            <span class="s2">&quot;MBJ&quot;</span><span class="p">:</span> <span class="s2">&quot;modified Becke-Johnson&quot;</span><span class="p">,</span>
            <span class="s2">&quot;SCAN&quot;</span><span class="p">:</span> <span class="s2">&quot;SCAN&quot;</span><span class="p">,</span>
            <span class="s2">&quot;R2SCAN&quot;</span><span class="p">:</span> <span class="s2">&quot;R2SCAN&quot;</span><span class="p">,</span>
            <span class="s2">&quot;RSCAN&quot;</span><span class="p">:</span> <span class="s2">&quot;RSCAN&quot;</span><span class="p">,</span>
            <span class="s2">&quot;MS0&quot;</span><span class="p">:</span> <span class="s2">&quot;MadeSimple0&quot;</span><span class="p">,</span>
            <span class="s2">&quot;MS1&quot;</span><span class="p">:</span> <span class="s2">&quot;MadeSimple1&quot;</span><span class="p">,</span>
            <span class="s2">&quot;MS2&quot;</span><span class="p">:</span> <span class="s2">&quot;MadeSimple2&quot;</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">IVDW_TYPES</span> <span class="o">=</span> <span class="p">{</span>
            <span class="mi">0</span><span class="p">:</span> <span class="s2">&quot;no-correction&quot;</span><span class="p">,</span>
            <span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;DFT-D2&quot;</span><span class="p">,</span>
            <span class="mi">10</span><span class="p">:</span> <span class="s2">&quot;DFT-D2&quot;</span><span class="p">,</span>
            <span class="mi">11</span><span class="p">:</span> <span class="s2">&quot;DFT-D3&quot;</span><span class="p">,</span>
            <span class="mi">12</span><span class="p">:</span> <span class="s2">&quot;DFT-D3-BJ&quot;</span><span class="p">,</span>
            <span class="mi">2</span><span class="p">:</span> <span class="s2">&quot;TS&quot;</span><span class="p">,</span>
            <span class="mi">20</span><span class="p">:</span> <span class="s2">&quot;TS&quot;</span><span class="p">,</span>
            <span class="mi">21</span><span class="p">:</span> <span class="s2">&quot;TS-H&quot;</span><span class="p">,</span>
            <span class="mi">202</span><span class="p">:</span> <span class="s2">&quot;MBD&quot;</span><span class="p">,</span>
            <span class="mi">4</span><span class="p">:</span> <span class="s2">&quot;dDsC&quot;</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;AEXX&quot;</span><span class="p">,</span> <span class="mf">1.00</span><span class="p">),</span> <span class="mf">1.00</span><span class="p">):</span>
            <span class="n">run_type</span> <span class="o">=</span> <span class="s2">&quot;HF&quot;</span>
        <span class="k">elif</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;HFSCREEN&quot;</span><span class="p">,</span> <span class="mf">0.30</span><span class="p">),</span> <span class="mf">0.30</span><span class="p">):</span>
            <span class="n">run_type</span> <span class="o">=</span> <span class="s2">&quot;HSE03&quot;</span>
        <span class="k">elif</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;HFSCREEN&quot;</span><span class="p">,</span> <span class="mf">0.20</span><span class="p">),</span> <span class="mf">0.20</span><span class="p">):</span>
            <span class="n">run_type</span> <span class="o">=</span> <span class="s2">&quot;HSE06&quot;</span>
        <span class="k">elif</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;AEXX&quot;</span><span class="p">,</span> <span class="mf">0.20</span><span class="p">),</span> <span class="mf">0.20</span><span class="p">):</span>
            <span class="n">run_type</span> <span class="o">=</span> <span class="s2">&quot;B3LYP&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;LHFCALC&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
            <span class="n">run_type</span> <span class="o">=</span> <span class="s2">&quot;PBEO or other Hybrid Functional&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">incar</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;METAGGA&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">incar</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;METAGGA&quot;</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span>
            <span class="s2">&quot;--&quot;</span><span class="p">,</span>
            <span class="s2">&quot;None&quot;</span><span class="p">,</span>
        <span class="p">}:</span>
            <span class="n">incar_tag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">incar</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;METAGGA&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
            <span class="n">run_type</span> <span class="o">=</span> <span class="n">METAGGA_TYPES</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">incar_tag</span><span class="p">,</span> <span class="n">incar_tag</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;GGA&quot;</span><span class="p">):</span>
            <span class="n">incar_tag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;GGA&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
            <span class="n">run_type</span> <span class="o">=</span> <span class="n">GGA_TYPES</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">incar_tag</span><span class="p">,</span> <span class="n">incar_tag</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">potcar_symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;PAW&quot;</span><span class="p">:</span>
            <span class="n">run_type</span> <span class="o">=</span> <span class="s2">&quot;LDA&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">run_type</span> <span class="o">=</span> <span class="s2">&quot;unknown&quot;</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Unknown run type!&quot;</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_hubbard</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;LDAU&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
            <span class="n">run_type</span> <span class="o">+=</span> <span class="s2">&quot;+U&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;LUSE_VDW&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">run_type</span> <span class="o">+=</span> <span class="s2">&quot;+rVV10&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">incar</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;IVDW&quot;</span><span class="p">)</span> <span class="ow">in</span> <span class="n">IVDW_TYPES</span><span class="p">:</span>
            <span class="n">run_type</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;+vdW-</span><span class="si">{</span><span class="n">IVDW_TYPES</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">incar</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;IVDW&#39;</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">incar</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;IVDW&quot;</span><span class="p">):</span>
            <span class="n">run_type</span> <span class="o">+=</span> <span class="s2">&quot;+vdW-unknown&quot;</span>

        <span class="k">return</span> <span class="n">run_type</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_hubbard</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether is a DFT+U run.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hubbards</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hubbards</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mf">1e-8</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_spin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether is spin-polarized.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ISPIN&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">md_n_steps</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of steps for MD runs.</span>

<span class="sd">        Count all the actual MD steps if ML enabled.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">md_data</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">md_data</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">nionic_steps</span>

<div class="viewcode-block" id="Vasprun.get_computed_entry">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Vasprun.get_computed_entry">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_computed_entry</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">inc_structure</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">parameters</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">entry_id</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ComputedStructureEntry</span> <span class="o">|</span> <span class="n">ComputedEntry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a ComputedEntry or ComputedStructureEntry from the Vasprun.</span>

<span class="sd">        Args:</span>
<span class="sd">            inc_structure (bool): Whether to return ComputedStructureEntries</span>
<span class="sd">                instead of ComputedEntries.</span>
<span class="sd">            parameters (list): Input parameters to include. It has to be one of</span>
<span class="sd">                the properties supported by the Vasprun object. If is None,</span>
<span class="sd">                a default set of parameters that are</span>
<span class="sd">                necessary for typical post-processing will be set.</span>
<span class="sd">            data (dict): Output data to include. Have to be the properties</span>
<span class="sd">                supported by the Vasprun object.</span>
<span class="sd">            entry_id (str): An entry id for the ComputedEntry.</span>
<span class="sd">                Defaults to &quot;vasprun-{current datetime}&quot;</span>

<span class="sd">        Returns:</span>
<span class="sd">            ComputedStructureEntry/ComputedEntry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">entry_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">calc_date</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="p">[</span><span class="s2">&quot;DATE&quot;</span><span class="p">])</span>
            <span class="n">calc_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="p">[</span><span class="s2">&quot;TIME&quot;</span><span class="p">]</span>
            <span class="n">hashed_structure</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">final_structure</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>  <span class="c1"># noqa: S324</span>

            <span class="n">entry_id</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;vasprun-</span><span class="si">{</span><span class="n">calc_date</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">calc_time</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">hashed_structure</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">param_names</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;is_hubbard&quot;</span><span class="p">,</span>
            <span class="s2">&quot;hubbards&quot;</span><span class="p">,</span>
            <span class="s2">&quot;potcar_symbols&quot;</span><span class="p">,</span>
            <span class="s2">&quot;potcar_spec&quot;</span><span class="p">,</span>
            <span class="s2">&quot;run_type&quot;</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">parameters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">param_names</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span><span class="n">param</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">param_names</span><span class="p">}</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">{</span><span class="n">param</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">data</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">inc_structure</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ComputedStructureEntry</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">final_structure</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">final_energy</span><span class="p">,</span>
                <span class="n">parameters</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
                <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                <span class="n">entry_id</span><span class="o">=</span><span class="n">entry_id</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">ComputedEntry</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">final_structure</span><span class="o">.</span><span class="n">composition</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">final_energy</span><span class="p">,</span>
            <span class="n">parameters</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">entry_id</span><span class="o">=</span><span class="n">entry_id</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Vasprun.get_band_structure">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Vasprun.get_band_structure">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_band_structure</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">kpoints_filename</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">efermi</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;smart&quot;</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">line_mode</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">force_hybrid_mode</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_kpoints_opt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BandStructureSymmLine</span> <span class="o">|</span> <span class="n">BandStructure</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the band structure.</span>

<span class="sd">        Args:</span>
<span class="sd">            kpoints_filename: Full path of the KPOINTS file from which</span>
<span class="sd">                the band structure is generated.</span>
<span class="sd">                If None is provided, the code will try to intelligently</span>
<span class="sd">                determine the appropriate KPOINTS file by substituting the</span>
<span class="sd">                filename of the vasprun.xml with KPOINTS (or KPOINTS_OPT).</span>
<span class="sd">                The latter is the default behavior.</span>
<span class="sd">            efermi: The Fermi energy associated with the bandstructure, in eV. By</span>
<span class="sd">                default (None), uses the value reported by VASP in vasprun.xml. To</span>
<span class="sd">                manually set the Fermi energy, pass a float. Pass &#39;smart&#39; to use the</span>
<span class="sd">                `calculate_efermi()` method, which calculates the Fermi level by first</span>
<span class="sd">                checking whether it lies within a small tolerance (by default 0.001 eV)</span>
<span class="sd">                of a band edge) If it does, the Fermi level is placed in the center of</span>
<span class="sd">                the bandgap. Otherwise, the value is identical to the value reported by</span>
<span class="sd">                VASP.</span>
<span class="sd">            line_mode: Force the band structure to be considered as</span>
<span class="sd">                a run along symmetry lines. (Default: False)</span>
<span class="sd">            force_hybrid_mode: Makes it possible to read in self-consistent band</span>
<span class="sd">                structure calculations for every type of functional. (Default: False)</span>
<span class="sd">            ignore_kpoints_opt: Normally, if KPOINTS_OPT data exists, it has</span>
<span class="sd">                the band structure data. Set this flag to ignore it. (Default: False)</span>

<span class="sd">        Returns:</span>
<span class="sd">            BandStructure (or more specifically a BandStructureSymmLine object if the run</span>
<span class="sd">            is detected to be a run along symmetry lines)</span>

<span class="sd">            Two types of runs along symmetry lines are accepted: non-sc with</span>
<span class="sd">            Line-Mode in the KPOINT file or hybrid, self-consistent with a</span>
<span class="sd">            uniform grid+a few kpoints along symmetry lines (explicit KPOINTS</span>
<span class="sd">            file) (it&#39;s not possible to run a non-sc band structure with hybrid</span>
<span class="sd">            functionals). The explicit KPOINTS file needs to have data on the</span>
<span class="sd">            kpoint label as commentary.</span>

<span class="sd">            If VASP was run with KPOINTS_OPT, it reads the data from that</span>
<span class="sd">            file unless told otherwise. This overrides hybrid mode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">use_kpoints_opt</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">ignore_kpoints_opt</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;kpoints_opt_props&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">kpoints_filename</span><span class="p">:</span>
            <span class="n">kpts_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">),</span>
                <span class="s2">&quot;KPOINTS_OPT&quot;</span> <span class="k">if</span> <span class="n">use_kpoints_opt</span> <span class="k">else</span> <span class="s2">&quot;KPOINTS&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">kpoints_filename</span> <span class="o">=</span> <span class="n">zpath</span><span class="p">(</span><span class="n">kpts_path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kpoints_filename</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">kpoints_filename</span><span class="p">)</span> <span class="ow">and</span> <span class="n">line_mode</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;KPOINTS_OPT&quot;</span> <span class="k">if</span> <span class="n">use_kpoints_opt</span> <span class="k">else</span> <span class="s2">&quot;KPOINTS&quot;</span>
            <span class="k">raise</span> <span class="n">VaspParseError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> not found but needed to obtain band structure along symmetry lines.&quot;</span><span class="p">)</span>

        <span class="c1"># Note that we&#39;re using the Fermi energy of the self-consistent grid</span>
        <span class="c1"># run even if we&#39;re reading bands from KPOINTS_OPT.</span>
        <span class="k">if</span> <span class="n">efermi</span> <span class="o">==</span> <span class="s2">&quot;smart&quot;</span><span class="p">:</span>
            <span class="n">e_fermi</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_efermi</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">efermi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">e_fermi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">efermi</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">e_fermi</span> <span class="o">=</span> <span class="n">efermi</span>

        <span class="k">if</span> <span class="n">e_fermi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;e_fermi is None.&quot;</span><span class="p">)</span>

        <span class="n">kpoint_file</span><span class="p">:</span> <span class="n">Kpoints</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">kpoints_filename</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">kpoints_filename</span><span class="p">):</span>
            <span class="n">kpoint_file</span> <span class="o">=</span> <span class="n">Kpoints</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">kpoints_filename</span><span class="p">)</span>
        <span class="n">lattice_new</span> <span class="o">=</span> <span class="n">Lattice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">final_structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">reciprocal_lattice</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">use_kpoints_opt</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kpoints_opt_props</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">kpoints_opt_props</span><span class="o">.</span><span class="n">actual_kpoints</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;KPOINTS_opt or actual_kpoints is None.&quot;</span><span class="p">)</span>
            <span class="n">kpoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kpt</span><span class="p">)</span> <span class="k">for</span> <span class="n">kpt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kpoints_opt_props</span><span class="o">.</span><span class="n">actual_kpoints</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">actual_kpoints</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;actual_kpoints is None.&quot;</span><span class="p">)</span>
            <span class="n">kpoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kpt</span><span class="p">)</span> <span class="k">for</span> <span class="n">kpt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">actual_kpoints</span><span class="p">]</span>

        <span class="n">p_eig_vals</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">[</span><span class="n">Spin</span><span class="p">,</span> <span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">eigenvals</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">[</span><span class="n">Spin</span><span class="p">,</span> <span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="n">n_kpts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">kpoints</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">use_kpoints_opt</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kpoints_opt_props</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;KPOINTS_opt is None.&quot;</span><span class="p">)</span>
            <span class="n">eig_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kpoints_opt_props</span><span class="o">.</span><span class="n">eigenvalues</span>
            <span class="n">projected_eig_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kpoints_opt_props</span><span class="o">.</span><span class="n">projected_eigenvalues</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">eig_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span>
            <span class="n">projected_eig_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projected_eigenvalues</span>

        <span class="k">if</span> <span class="n">eig_vals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Eigenvalues are None.&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">spin</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">eig_vals</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">eigenvals</span><span class="p">[</span><span class="n">spin</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">projected_eig_vals</span><span class="p">:</span>
                <span class="n">proj_eig_vals</span> <span class="o">=</span> <span class="n">projected_eig_vals</span><span class="p">[</span><span class="n">spin</span><span class="p">]</span>
                <span class="c1"># Original axes for self.projected_eigenvalues are kpoints, band, ion, orb.</span>
                <span class="c1"># For BS input, we need band, kpoints, orb, ion.</span>
                <span class="n">proj_eig_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">proj_eig_vals</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Swap kpoint and band axes</span>
                <span class="n">proj_eig_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">proj_eig_vals</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># Swap ion and orb axes</span>

                <span class="n">p_eig_vals</span><span class="p">[</span><span class="n">spin</span><span class="p">]</span> <span class="o">=</span> <span class="n">proj_eig_vals</span>

        <span class="c1"># Check if we have an hybrid band structure computation</span>
        <span class="c1"># for this we look at the presence of the LHFCALC tag</span>
        <span class="c1"># (but hybrid mode is redundant if using kpoints_opt)</span>
        <span class="n">hybrid_band</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;LHFCALC&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">or</span> <span class="mf">0.0</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">actual_kpoints_weights</span><span class="p">:</span>
            <span class="n">hybrid_band</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">kpoint_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">kpoint_file</span><span class="o">.</span><span class="n">style</span> <span class="o">==</span> <span class="n">Kpoints</span><span class="o">.</span><span class="n">supported_modes</span><span class="o">.</span><span class="n">Line_mode</span><span class="p">:</span>
            <span class="n">line_mode</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">line_mode</span><span class="p">:</span>
            <span class="n">labels_dict</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="n">kpoint_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Kpoint file cannot be None for line mode.&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">hybrid_band</span> <span class="ow">or</span> <span class="n">force_hybrid_mode</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">use_kpoints_opt</span><span class="p">:</span>
                <span class="n">start_bs_index</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">actual_kpoints</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">actual_kpoints_weights</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">):</span>
                        <span class="n">start_bs_index</span> <span class="o">=</span> <span class="n">i</span>
                        <span class="k">break</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_bs_index</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">kpoint_file</span><span class="o">.</span><span class="n">kpts</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">kpoint_file</span><span class="o">.</span><span class="n">labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">kpoint_file</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">labels_dict</span><span class="p">[</span><span class="n">kpoint_file</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">kpoint_file</span><span class="o">.</span><span class="n">kpts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="c1"># Remake the data only considering line band structure k-points</span>
                <span class="c1"># (weight = 0.0 kpoints)</span>
                <span class="n">n_bands</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">eigenvals</span><span class="p">[</span><span class="n">Spin</span><span class="o">.</span><span class="n">up</span><span class="p">])</span>
                <span class="n">kpoints</span> <span class="o">=</span> <span class="n">kpoints</span><span class="p">[</span><span class="n">start_bs_index</span><span class="p">:</span><span class="n">n_kpts</span><span class="p">]</span>
                <span class="n">up_eigen</span> <span class="o">=</span> <span class="p">[</span><span class="n">eigenvals</span><span class="p">[</span><span class="n">Spin</span><span class="o">.</span><span class="n">up</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">start_bs_index</span><span class="p">:</span><span class="n">n_kpts</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_bands</span><span class="p">)]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">projected_eigenvalues</span><span class="p">:</span>
                    <span class="n">p_eig_vals</span><span class="p">[</span><span class="n">Spin</span><span class="o">.</span><span class="n">up</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">p_eig_vals</span><span class="p">[</span><span class="n">Spin</span><span class="o">.</span><span class="n">up</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">start_bs_index</span><span class="p">:</span><span class="n">n_kpts</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_bands</span><span class="p">)]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_spin</span><span class="p">:</span>
                    <span class="n">down_eigen</span> <span class="o">=</span> <span class="p">[</span><span class="n">eigenvals</span><span class="p">[</span><span class="n">Spin</span><span class="o">.</span><span class="n">down</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">start_bs_index</span><span class="p">:</span><span class="n">n_kpts</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_bands</span><span class="p">)]</span>
                    <span class="n">eigenvals</span><span class="p">[</span><span class="n">Spin</span><span class="o">.</span><span class="n">up</span><span class="p">]</span> <span class="o">=</span> <span class="n">up_eigen</span>
                    <span class="n">eigenvals</span><span class="p">[</span><span class="n">Spin</span><span class="o">.</span><span class="n">down</span><span class="p">]</span> <span class="o">=</span> <span class="n">down_eigen</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">projected_eigenvalues</span><span class="p">:</span>
                        <span class="n">p_eig_vals</span><span class="p">[</span><span class="n">Spin</span><span class="o">.</span><span class="n">down</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                            <span class="n">p_eig_vals</span><span class="p">[</span><span class="n">Spin</span><span class="o">.</span><span class="n">down</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">start_bs_index</span><span class="p">:</span><span class="n">n_kpts</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_bands</span><span class="p">)</span>
                        <span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">eigenvals</span><span class="p">[</span><span class="n">Spin</span><span class="o">.</span><span class="n">up</span><span class="p">]</span> <span class="o">=</span> <span class="n">up_eigen</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">kpoint_file</span><span class="o">.</span><span class="n">labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s2">&quot;&quot;</span> <span class="ow">in</span> <span class="n">kpoint_file</span><span class="o">.</span><span class="n">labels</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;A band structure along symmetry lines requires a label &quot;</span>
                            <span class="s2">&quot;for each kpoint. Check your KPOINTS file&quot;</span>
                        <span class="p">)</span>
                    <span class="n">labels_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">kpoint_file</span><span class="o">.</span><span class="n">labels</span><span class="p">,</span> <span class="n">kpoint_file</span><span class="o">.</span><span class="n">kpts</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
                <span class="n">labels_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># type: ignore[call-overload]</span>

            <span class="k">return</span> <span class="n">BandStructureSymmLine</span><span class="p">(</span>
                <span class="n">kpoints</span><span class="p">,</span>
                <span class="n">eigenvals</span><span class="p">,</span>
                <span class="n">lattice_new</span><span class="p">,</span>
                <span class="n">e_fermi</span><span class="p">,</span>
                <span class="n">labels_dict</span><span class="p">,</span>  <span class="c1"># type: ignore[arg-type]</span>
                <span class="n">structure</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">final_structure</span><span class="p">,</span>
                <span class="n">projections</span><span class="o">=</span><span class="n">p_eig_vals</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">BandStructure</span><span class="p">(</span>
            <span class="n">kpoints</span><span class="p">,</span>
            <span class="n">eigenvals</span><span class="p">,</span>
            <span class="n">lattice_new</span><span class="p">,</span>
            <span class="n">e_fermi</span><span class="p">,</span>
            <span class="n">structure</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">final_structure</span><span class="p">,</span>
            <span class="n">projections</span><span class="o">=</span><span class="n">p_eig_vals</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">eigenvalue_band_properties</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span>
        <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span>
        <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span>
            <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">bool</span><span class="p">],</span>
        <span class="p">]</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Band properties from the eigenvalues as a tuple,</span>
<span class="sd">        (band gap, cbm, vbm, is_band_gap_direct).</span>
<span class="sd">        In the case of separate_spins=True, the band gap, cbm, vbm, and is_band_gap_direct are each</span>
<span class="sd">        lists of length 2, with index 0 representing the spin-up channel and index 1 representing the</span>
<span class="sd">        spin-down channel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vbm</span> <span class="o">=</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
        <span class="n">vbm_kpoint</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">cbm</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
        <span class="n">cbm_kpoint</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">vbm_spins</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">vbm_spins_kpoints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cbm_spins</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cbm_spins_kpoints</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;eigenvalues is None.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">separate_spins</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The separate_spins flag can only be True if ISPIN = 2&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">eigenvalue</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">separate_spins</span><span class="p">:</span>
                <span class="n">vbm</span> <span class="o">=</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
                <span class="n">cbm</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">kpoint</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">eigenvalue</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">eigenval</span><span class="p">,</span> <span class="n">occu</span> <span class="ow">in</span> <span class="n">val</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">occu</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">occu_tol</span> <span class="ow">and</span> <span class="n">eigenval</span> <span class="o">&gt;</span> <span class="n">vbm</span><span class="p">:</span>
                        <span class="n">vbm</span> <span class="o">=</span> <span class="n">eigenval</span>
                        <span class="n">vbm_kpoint</span> <span class="o">=</span> <span class="n">kpoint</span>
                    <span class="k">elif</span> <span class="n">occu</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">occu_tol</span> <span class="ow">and</span> <span class="n">eigenval</span> <span class="o">&lt;</span> <span class="n">cbm</span><span class="p">:</span>
                        <span class="n">cbm</span> <span class="o">=</span> <span class="n">eigenval</span>
                        <span class="n">cbm_kpoint</span> <span class="o">=</span> <span class="n">kpoint</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">separate_spins</span><span class="p">:</span>
                <span class="n">vbm_spins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vbm</span><span class="p">)</span>
                <span class="n">vbm_spins_kpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vbm_kpoint</span><span class="p">)</span>
                <span class="n">cbm_spins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cbm</span><span class="p">)</span>
                <span class="n">cbm_spins_kpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cbm_kpoint</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">separate_spins</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="p">(</span>
                    <span class="nb">max</span><span class="p">(</span><span class="n">cbm_spins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">vbm_spins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">),</span>
                    <span class="nb">max</span><span class="p">(</span><span class="n">cbm_spins</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">vbm_spins</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">),</span>
                <span class="p">),</span>
                <span class="p">(</span><span class="n">cbm_spins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cbm_spins</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                <span class="p">(</span><span class="n">vbm_spins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vbm_spins</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                <span class="p">(</span>
                    <span class="n">vbm_spins_kpoints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">cbm_spins_kpoints</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">vbm_spins_kpoints</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">cbm_spins_kpoints</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="p">),</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">cbm</span> <span class="o">-</span> <span class="n">vbm</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">cbm</span><span class="p">,</span> <span class="n">vbm</span><span class="p">,</span> <span class="n">vbm_kpoint</span> <span class="o">==</span> <span class="n">cbm_kpoint</span>

<div class="viewcode-block" id="Vasprun.calculate_efermi">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Vasprun.calculate_efermi">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_efermi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the Fermi level using a robust algorithm.</span>

<span class="sd">        Sometimes VASP can set the Fermi level inside a band</span>
<span class="sd">        due to issues in the way band occupancies are handled.</span>
<span class="sd">        This method tries to detect and correct this.</span>

<span class="sd">        More details: https://www.vasp.at/forum/viewtopic.php?f=4&amp;t=17981.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;eigenvalues cannot be None.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">efermi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;efermi cannot be None.&quot;</span><span class="p">)</span>

        <span class="c1"># Drop weights and set shape n_bands, n_kpoints</span>
        <span class="n">all_eigs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">eigs</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">eigs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">crosses_band</span><span class="p">(</span><span class="n">fermi</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="n">eigs_below</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">all_eigs</span> <span class="o">&lt;</span> <span class="n">fermi</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">eigs_above</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">all_eigs</span> <span class="o">&gt;</span> <span class="n">fermi</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">eigs_above</span> <span class="o">&amp;</span> <span class="n">eigs_below</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">get_vbm_cbm</span><span class="p">(</span><span class="n">fermi</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">all_eigs</span><span class="p">[</span><span class="n">all_eigs</span> <span class="o">&lt;</span> <span class="n">fermi</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">all_eigs</span><span class="p">[</span><span class="n">all_eigs</span> <span class="o">&gt;</span> <span class="n">fermi</span><span class="p">])</span>

        <span class="c1"># Fermi level doesn&#39;t cross a band: safe to use VASP Fermi level</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">crosses_band</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">efermi</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">efermi</span>

        <span class="c1"># If the Fermi level crosses a band, check if we are very close to band gap.</span>
        <span class="c1"># If so, then likely this is a VASP tetrahedron bug</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">crosses_band</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">efermi</span> <span class="o">+</span> <span class="n">tol</span><span class="p">):</span>
            <span class="c1"># efermi resides in the valence band</span>
            <span class="c1"># Set Fermi level as average of CBM and VBM</span>
            <span class="n">vbm</span><span class="p">,</span> <span class="n">cbm</span> <span class="o">=</span> <span class="n">get_vbm_cbm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">efermi</span> <span class="o">+</span> <span class="n">tol</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">cbm</span> <span class="o">+</span> <span class="n">vbm</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">crosses_band</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">efermi</span> <span class="o">-</span> <span class="n">tol</span><span class="p">):</span>
            <span class="c1"># efermi resides in the conduction band</span>
            <span class="c1"># Set Fermi level as average of CBM and VBM</span>
            <span class="n">vbm</span><span class="p">,</span> <span class="n">cbm</span> <span class="o">=</span> <span class="n">get_vbm_cbm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">efermi</span> <span class="o">-</span> <span class="n">tol</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">cbm</span> <span class="o">+</span> <span class="n">vbm</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="c1"># If is a metal</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">efermi</span></div>


<div class="viewcode-block" id="Vasprun.get_potcars">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Vasprun.get_potcars">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_potcars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="n">PathLike</span> <span class="o">|</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Potcar</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the POTCAR from the specified path.</span>

<span class="sd">        Args:</span>
<span class="sd">            path (PathLike | bool): If a str or Path, the path to search for POTCARs.</span>
<span class="sd">                If a bool, whether to take the search path from the specified vasprun.xml</span>

<span class="sd">        Returns:</span>
<span class="sd">            Potcar | None: The POTCAR from the specified path or None if not found/no path specified.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Path</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;POTCAR&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="n">potcar_paths</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">path</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># the abspath is needed here in cases where no leading directory is specified,</span>
            <span class="c1"># e.g. Vasprun(&quot;vasprun.xml&quot;). see gh-3586:</span>
            <span class="n">search_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">))</span> <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="kc">True</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

            <span class="n">potcar_paths</span> <span class="o">=</span> <span class="p">[</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">search_path</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">fn</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">search_path</span><span class="p">)</span> <span class="k">if</span> <span class="n">fn</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;POTCAR&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;.spec&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fn</span>
            <span class="p">]</span>

        <span class="k">for</span> <span class="n">potcar_path</span> <span class="ow">in</span> <span class="n">potcar_paths</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">potcar</span> <span class="o">=</span> <span class="n">Potcar</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">potcar_path</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">{</span><span class="n">d</span><span class="o">.</span><span class="n">header</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">potcar</span><span class="p">}</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">potcar_symbols</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">potcar</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">continue</span>

        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;No POTCAR file with matching TITEL fields was found in</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">potcar_paths</span><span class="p">),</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Vasprun.get_trajectory">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Vasprun.get_trajectory">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_trajectory</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Trajectory</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a Trajectory, an alternative representation of self.structures</span>
<span class="sd">        as a single object. Forces are added as site properties.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Trajectory</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">structs</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Structure</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">steps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">md_data</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">ionic_steps</span>
        <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="n">steps</span><span class="p">:</span>
            <span class="n">struct</span> <span class="o">=</span> <span class="n">step</span><span class="p">[</span><span class="s2">&quot;structure&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">struct</span><span class="o">.</span><span class="n">add_site_property</span><span class="p">(</span><span class="s2">&quot;forces&quot;</span><span class="p">,</span> <span class="n">step</span><span class="p">[</span><span class="s2">&quot;forces&quot;</span><span class="p">])</span>
            <span class="n">structs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">struct</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Trajectory</span><span class="o">.</span><span class="n">from_structures</span><span class="p">(</span><span class="n">structs</span><span class="p">,</span> <span class="n">constant_lattice</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="Vasprun.update_potcar_spec">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Vasprun.update_potcar_spec">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update_potcar_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="n">PathLike</span> <span class="o">|</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update the specs based on the POTCARs found.</span>

<span class="sd">        Args:</span>
<span class="sd">            path (PathLike | bool): Path to search for POTCARs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">potcar</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_potcars</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">potcar_spec</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">{</span>
                    <span class="s2">&quot;titel&quot;</span><span class="p">:</span> <span class="n">sym</span><span class="p">,</span>
                    <span class="s2">&quot;hash&quot;</span><span class="p">:</span> <span class="n">ps</span><span class="o">.</span><span class="n">md5_header_hash</span><span class="p">,</span>
                    <span class="s2">&quot;summary_stats&quot;</span><span class="p">:</span> <span class="n">ps</span><span class="o">.</span><span class="n">_summary_stats</span><span class="p">,</span>
                <span class="p">}</span>
                <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">potcar_symbols</span>
                <span class="k">for</span> <span class="n">ps</span> <span class="ow">in</span> <span class="n">potcar</span>
                <span class="k">if</span> <span class="n">ps</span><span class="o">.</span><span class="n">symbol</span> <span class="o">==</span> <span class="n">sym</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">]</span></div>


<div class="viewcode-block" id="Vasprun.update_charge_from_potcar">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Vasprun.update_charge_from_potcar">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update_charge_from_potcar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="n">PathLike</span> <span class="o">|</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update the charge of a structure based on the POTCARs found.</span>

<span class="sd">        Args:</span>
<span class="sd">            path (PathLike | bool): Path to search for POTCARs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">potcar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_potcars</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">potcar</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">incar</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ALGO&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span>
            <span class="s2">&quot;GW0&quot;</span><span class="p">,</span>
            <span class="s2">&quot;G0W0&quot;</span><span class="p">,</span>
            <span class="s2">&quot;GW&quot;</span><span class="p">,</span>
            <span class="s2">&quot;BSE&quot;</span><span class="p">,</span>
            <span class="c1"># VASP renamed the GW tags in v6.</span>
            <span class="s2">&quot;QPGW&quot;</span><span class="p">,</span>
            <span class="s2">&quot;QPGW0&quot;</span><span class="p">,</span>
            <span class="s2">&quot;EVGW&quot;</span><span class="p">,</span>
            <span class="s2">&quot;EVGW0&quot;</span><span class="p">,</span>
            <span class="s2">&quot;GWR&quot;</span><span class="p">,</span>
            <span class="s2">&quot;GW0R&quot;</span><span class="p">,</span>
        <span class="p">}:</span>
            <span class="n">nelect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;NELECT&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">potcar</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_structure</span><span class="o">.</span><span class="n">composition</span><span class="o">.</span><span class="n">element_composition</span><span class="p">):</span>
                <span class="n">potcar_nelect</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">initial_structure</span><span class="o">.</span><span class="n">composition</span><span class="o">.</span><span class="n">element_composition</span><span class="p">[</span><span class="n">ps</span><span class="o">.</span><span class="n">element</span><span class="p">]</span> <span class="o">*</span> <span class="n">ps</span><span class="o">.</span><span class="n">ZVAL</span> <span class="k">for</span> <span class="n">ps</span> <span class="ow">in</span> <span class="n">potcar</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="p">))</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_symbols</span><span class="p">)]</span>
                <span class="n">potcar_nelect</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ps</span><span class="o">.</span><span class="n">ZVAL</span> <span class="o">*</span> <span class="n">num</span> <span class="k">for</span> <span class="n">ps</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">potcar</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
            <span class="n">charge</span> <span class="o">=</span> <span class="n">potcar_nelect</span> <span class="o">-</span> <span class="n">nelect</span>

            <span class="k">for</span> <span class="n">struct</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">structures</span><span class="p">:</span>
                <span class="n">struct</span><span class="o">.</span><span class="n">_charge</span> <span class="o">=</span> <span class="n">charge</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;initial_structure&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">initial_structure</span><span class="o">.</span><span class="n">_charge</span> <span class="o">=</span> <span class="n">charge</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;final_structure&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">final_structure</span><span class="o">.</span><span class="n">_charge</span> <span class="o">=</span> <span class="n">charge</span></div>


<div class="viewcode-block" id="Vasprun.as_dict">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Vasprun.as_dict">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;JSON-serializable dict representation.&quot;&quot;&quot;</span>
        <span class="n">comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_structure</span><span class="o">.</span><span class="n">composition</span>
        <span class="n">unique_symbols</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_symbols</span><span class="p">))</span>
        <span class="n">dct</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;vasp_version&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">vasp_version</span><span class="p">,</span>
            <span class="s2">&quot;has_vasp_completed&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">converged</span><span class="p">,</span>
            <span class="s2">&quot;nsites&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">final_structure</span><span class="p">),</span>
            <span class="s2">&quot;unit_cell_formula&quot;</span><span class="p">:</span> <span class="n">comp</span><span class="o">.</span><span class="n">as_dict</span><span class="p">(),</span>
            <span class="s2">&quot;reduced_cell_formula&quot;</span><span class="p">:</span> <span class="n">Composition</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">reduced_formula</span><span class="p">)</span><span class="o">.</span><span class="n">as_dict</span><span class="p">(),</span>
            <span class="s2">&quot;pretty_formula&quot;</span><span class="p">:</span> <span class="n">comp</span><span class="o">.</span><span class="n">reduced_formula</span><span class="p">,</span>
            <span class="s2">&quot;is_hubbard&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_hubbard</span><span class="p">,</span>
            <span class="s2">&quot;hubbards&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">hubbards</span><span class="p">,</span>
            <span class="s2">&quot;elements&quot;</span><span class="p">:</span> <span class="n">unique_symbols</span><span class="p">,</span>
            <span class="s2">&quot;nelements&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_symbols</span><span class="p">),</span>
            <span class="s2">&quot;run_type&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_type</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">vin</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;incar&quot;</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">incar</span><span class="o">.</span><span class="n">items</span><span class="p">()),</span>
            <span class="s2">&quot;crystal&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_structure</span><span class="o">.</span><span class="n">as_dict</span><span class="p">(),</span>
            <span class="s2">&quot;kpoints&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">kpoints</span><span class="o">.</span><span class="n">as_dict</span><span class="p">(),</span>
        <span class="p">}</span>
        <span class="n">actual_kpts</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">{</span>
                <span class="s2">&quot;abc&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">actual_kpoints</span><span class="p">[</span><span class="n">idx</span><span class="p">]),</span>
                <span class="s2">&quot;weight&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">actual_kpoints_weights</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">actual_kpoints</span><span class="p">))</span>
        <span class="p">]</span>
        <span class="n">vin</span><span class="p">[</span><span class="s2">&quot;kpoints&quot;</span><span class="p">][</span><span class="s2">&quot;actual_points&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">actual_kpts</span>
        <span class="n">vin</span><span class="p">[</span><span class="s2">&quot;nkpoints&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">actual_kpts</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kpt_opt_props</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kpoints_opt_props</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">kpt_opt_props</span><span class="o">.</span><span class="n">kpoints</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="ow">or</span> <span class="n">kpt_opt_props</span><span class="o">.</span><span class="n">actual_kpoints</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="ow">or</span> <span class="n">kpt_opt_props</span><span class="o">.</span><span class="n">actual_kpoints_weights</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;kpt_opt_props.kpoints/actual_kpoints/actual_kpoints_weights cannot be None.&quot;</span><span class="p">)</span>
            <span class="n">vin</span><span class="p">[</span><span class="s2">&quot;kpoints_opt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kpt_opt_props</span><span class="o">.</span><span class="n">kpoints</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span>
            <span class="n">actual_kpts</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">{</span>
                    <span class="s2">&quot;abc&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">kpt_opt_props</span><span class="o">.</span><span class="n">actual_kpoints</span><span class="p">[</span><span class="n">idx</span><span class="p">]),</span>
                    <span class="s2">&quot;weight&quot;</span><span class="p">:</span> <span class="n">kpt_opt_props</span><span class="o">.</span><span class="n">actual_kpoints_weights</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                <span class="p">}</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">kpt_opt_props</span><span class="o">.</span><span class="n">actual_kpoints</span><span class="p">))</span>
            <span class="p">]</span>
            <span class="n">vin</span><span class="p">[</span><span class="s2">&quot;kpoints_opt&quot;</span><span class="p">][</span><span class="s2">&quot;actual_kpoints&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">actual_kpts</span>
            <span class="n">vin</span><span class="p">[</span><span class="s2">&quot;nkpoints_opt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">actual_kpts</span><span class="p">)</span>
        <span class="n">vin</span><span class="p">[</span><span class="s2">&quot;potcar&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">potcar_symbols</span><span class="p">]</span>
        <span class="n">vin</span><span class="p">[</span><span class="s2">&quot;potcar_spec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">potcar_spec</span>
        <span class="n">vin</span><span class="p">[</span><span class="s2">&quot;potcar_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">potcar_symbols</span><span class="p">]</span>
        <span class="n">vin</span><span class="p">[</span><span class="s2">&quot;parameters&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="n">vin</span><span class="p">[</span><span class="s2">&quot;lattice_rec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">reciprocal_lattice</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span>
        <span class="n">dct</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">vin</span>

        <span class="n">n_sites</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">final_structure</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">vout</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;ionic_steps&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ionic_steps</span><span class="p">,</span>
                <span class="s2">&quot;final_energy&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_energy</span><span class="p">,</span>
                <span class="s2">&quot;final_energy_per_atom&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_energy</span> <span class="o">/</span> <span class="n">n_sites</span><span class="p">,</span>
                <span class="s2">&quot;crystal&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_structure</span><span class="o">.</span><span class="n">as_dict</span><span class="p">(),</span>
                <span class="s2">&quot;efermi&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">efermi</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ArithmeticError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="n">vout</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;ionic_steps&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ionic_steps</span><span class="p">,</span>
                <span class="s2">&quot;final_energy&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_energy</span><span class="p">,</span>
                <span class="s2">&quot;final_energy_per_atom&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s2">&quot;crystal&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_structure</span><span class="o">.</span><span class="n">as_dict</span><span class="p">(),</span>
                <span class="s2">&quot;efermi&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">efermi</span><span class="p">,</span>
            <span class="p">}</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">:</span>
            <span class="n">eigen</span> <span class="o">=</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">spin</span><span class="p">):</span> <span class="n">v</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">for</span> <span class="n">spin</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="n">vout</span><span class="p">[</span><span class="s2">&quot;eigenvalues&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">eigen</span>
            <span class="n">gap</span><span class="p">,</span> <span class="n">cbm</span><span class="p">,</span> <span class="n">vbm</span><span class="p">,</span> <span class="n">is_direct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalue_band_properties</span>
            <span class="n">vout</span> <span class="o">|=</span> <span class="p">{</span><span class="s2">&quot;bandgap&quot;</span><span class="p">:</span> <span class="n">gap</span><span class="p">,</span> <span class="s2">&quot;cbm&quot;</span><span class="p">:</span> <span class="n">cbm</span><span class="p">,</span> <span class="s2">&quot;vbm&quot;</span><span class="p">:</span> <span class="n">vbm</span><span class="p">,</span> <span class="s2">&quot;is_gap_direct&quot;</span><span class="p">:</span> <span class="n">is_direct</span><span class="p">}</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">projected_eigenvalues</span><span class="p">:</span>
                <span class="n">vout</span><span class="p">[</span><span class="s2">&quot;projected_eigenvalues&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">spin</span><span class="p">):</span> <span class="n">v</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">for</span> <span class="n">spin</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">projected_eigenvalues</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">}</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">projected_magnetisation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">vout</span><span class="p">[</span><span class="s2">&quot;projected_magnetisation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projected_magnetisation</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">kpt_opt_props</span> <span class="ow">and</span> <span class="n">kpt_opt_props</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">:</span>
            <span class="n">eigen</span> <span class="o">=</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">spin</span><span class="p">):</span> <span class="n">v</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">for</span> <span class="n">spin</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kpt_opt_props</span><span class="o">.</span><span class="n">eigenvalues</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="n">vout</span><span class="p">[</span><span class="s2">&quot;eigenvalues_kpoints_opt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">eigen</span>
            <span class="c1"># TODO: implement kpoints_opt eigenvalue_band_proprties.</span>
            <span class="c1"># gap, cbm, vbm, is_direct = self.eigenvalue_band_properties</span>
            <span class="c1"># vout |= {&quot;bandgap&quot;: gap, &quot;cbm&quot;: cbm, &quot;vbm&quot;: vbm, &quot;is_gap_direct&quot;: is_direct}</span>

            <span class="k">if</span> <span class="n">kpt_opt_props</span><span class="o">.</span><span class="n">projected_eigenvalues</span><span class="p">:</span>
                <span class="n">vout</span><span class="p">[</span><span class="s2">&quot;projected_eigenvalues_kpoints_opt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">spin</span><span class="p">):</span> <span class="n">v</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">for</span> <span class="n">spin</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kpt_opt_props</span><span class="o">.</span><span class="n">projected_eigenvalues</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">}</span>

            <span class="k">if</span> <span class="n">kpt_opt_props</span><span class="o">.</span><span class="n">projected_magnetisation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">vout</span><span class="p">[</span><span class="s2">&quot;projected_magnetisation_kpoints_opt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kpt_opt_props</span><span class="o">.</span><span class="n">projected_magnetisation</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="n">vout</span><span class="p">[</span><span class="s2">&quot;epsilon_static&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon_static</span>
        <span class="n">vout</span><span class="p">[</span><span class="s2">&quot;epsilon_static_wolfe&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon_static_wolfe</span>
        <span class="n">vout</span><span class="p">[</span><span class="s2">&quot;epsilon_ionic&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon_ionic</span>
        <span class="n">dct</span><span class="p">[</span><span class="s2">&quot;output&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">vout</span>
        <span class="k">return</span> <span class="n">jsanitize</span><span class="p">(</span><span class="n">dct</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_parse_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem</span><span class="p">:</span> <span class="n">XML_Element</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Incar</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse INCAR parameters and more.&quot;&quot;&quot;</span>
        <span class="n">params</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">:</span>
            <span class="c1"># VASP 6.4.3 can add trailing whitespace</span>
            <span class="c1"># for example, &lt;i type=&quot;string&quot; name=&quot;GGA    &quot;&gt;PE&lt;/i&gt;</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">attrib</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">tag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="s2">&quot;v&quot;</span><span class="p">}:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_params</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;response functions&quot;</span><span class="p">:</span>
                    <span class="c1"># Delete duplicate fields from &quot;response functions&quot;,</span>
                    <span class="c1"># which overrides the values in the root params.</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params</span><span class="p">}</span>
                <span class="n">params</span> <span class="o">|=</span> <span class="n">p</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">ptype</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">attrib</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">text</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;i&quot;</span><span class="p">:</span>
                        <span class="n">params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">_parse_parameters</span><span class="p">(</span><span class="n">ptype</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">_parse_v_parameters</span><span class="p">(</span><span class="n">ptype</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;RANDOM_SEED&quot;</span><span class="p">:</span>
                        <span class="c1"># Handle the case where RANDOM_SEED &gt; 99999, which results in *****</span>
                        <span class="n">params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span>
        <span class="n">elem</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">Incar</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_parse_atominfo</span><span class="p">(</span><span class="n">elem</span><span class="p">:</span> <span class="n">XML_Element</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse atom symbols and POTCAR symbols.&quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">parse_atomic_symbol</span><span class="p">(</span><span class="n">symbol</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Parse and ensure atomic symbols are valid elements.&quot;&quot;&quot;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">Element</span><span class="p">(</span><span class="n">symbol</span><span class="p">))</span>

            <span class="c1"># vasprun.xml uses &quot;X&quot; instead of &quot;Xe&quot; for Xenon</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">symbol</span> <span class="o">==</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span>
                    <span class="k">return</span> <span class="s2">&quot;Xe&quot;</span>
                <span class="k">if</span> <span class="n">symbol</span> <span class="o">==</span> <span class="s2">&quot;r&quot;</span><span class="p">:</span>
                    <span class="k">return</span> <span class="s2">&quot;Zr&quot;</span>
                <span class="k">raise</span>

        <span class="n">atomic_symbols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">potcar_symbols</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">elem</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;array&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;atoms&quot;</span><span class="p">:</span>
                <span class="n">atomic_symbols</span> <span class="o">=</span> <span class="p">[</span><span class="n">rc</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">rc</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;set&quot;</span><span class="p">)]</span>  <span class="c1"># type: ignore[union-attr]</span>
            <span class="k">elif</span> <span class="n">a</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;atomtypes&quot;</span><span class="p">:</span>
                <span class="n">potcar_symbols</span> <span class="o">=</span> <span class="p">[</span><span class="n">rc</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">)[</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">rc</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;set&quot;</span><span class="p">)]</span>  <span class="c1"># type: ignore[union-attr]</span>

        <span class="n">elem</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">parse_atomic_symbol</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span> <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">atomic_symbols</span><span class="p">],</span> <span class="n">potcar_symbols</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_parse_kpoints</span><span class="p">(</span>
        <span class="n">elem</span><span class="p">:</span> <span class="n">XML_Element</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Kpoints</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">Tuple3Floats</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse Kpoints.&quot;&quot;&quot;</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">elem</span> <span class="k">if</span> <span class="n">elem</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;generation&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">elem</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;generation&quot;</span><span class="p">)</span>
        <span class="n">kpoint</span> <span class="o">=</span> <span class="n">Kpoints</span><span class="p">(</span><span class="s2">&quot;Kpoints from vasprun.xml&quot;</span><span class="p">)</span>
        <span class="n">kpoint</span><span class="o">.</span><span class="n">style</span> <span class="o">=</span> <span class="n">Kpoints</span><span class="o">.</span><span class="n">supported_modes</span><span class="o">.</span><span class="n">from_str</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">attrib</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;param&quot;</span><span class="p">,</span> <span class="s2">&quot;Reciprocal&quot;</span><span class="p">))</span>  <span class="c1"># type: ignore[union-attr]</span>

        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">):</span>  <span class="c1"># type: ignore[union-attr]</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">attrib</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)</span>  <span class="c1"># type: ignore[union-attr]</span>
            <span class="n">tokens</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>  <span class="c1"># type: ignore[union-attr]</span>

            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;divisions&quot;</span><span class="p">:</span>
                <span class="n">kpoint</span><span class="o">.</span><span class="n">kpts</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">cast</span><span class="p">(</span><span class="n">Kpoint</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">)),</span>
                <span class="p">]</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;usershift&quot;</span><span class="p">:</span>
                <span class="n">kpoint</span><span class="o">.</span><span class="n">kpts_shift</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Vector3D</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;genvec1&quot;</span><span class="p">,</span> <span class="s2">&quot;genvec2&quot;</span><span class="p">,</span> <span class="s2">&quot;genvec3&quot;</span><span class="p">,</span> <span class="s2">&quot;shift&quot;</span><span class="p">}:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">kpoint</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">])</span>

        <span class="n">actual_kpoints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">va</span> <span class="ow">in</span> <span class="n">elem</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;varray&quot;</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">va</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;kpointlist&quot;</span><span class="p">:</span>
                <span class="n">actual_kpoints</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="nb">list</span><span class="p">[</span><span class="n">Tuple3Floats</span><span class="p">],</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">_parse_vasp_array</span><span class="p">(</span><span class="n">va</span><span class="p">))))</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;weights&quot;</span><span class="p">:</span>
                <span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">_parse_vasp_array</span><span class="p">(</span><span class="n">va</span><span class="p">)]</span>
        <span class="n">elem</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">kpoint</span><span class="o">.</span><span class="n">style</span> <span class="o">==</span> <span class="n">Kpoints</span><span class="o">.</span><span class="n">supported_modes</span><span class="o">.</span><span class="n">Reciprocal</span><span class="p">:</span>
            <span class="n">kpoint</span> <span class="o">=</span> <span class="n">Kpoints</span><span class="p">(</span>
                <span class="n">comment</span><span class="o">=</span><span class="s2">&quot;Kpoints from vasprun.xml&quot;</span><span class="p">,</span>
                <span class="n">style</span><span class="o">=</span><span class="n">Kpoints</span><span class="o">.</span><span class="n">supported_modes</span><span class="o">.</span><span class="n">Reciprocal</span><span class="p">,</span>
                <span class="n">num_kpts</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">kpoint</span><span class="o">.</span><span class="n">kpts</span><span class="p">),</span>
                <span class="n">kpts</span><span class="o">=</span><span class="n">actual_kpoints</span><span class="p">,</span>
                <span class="n">kpts_weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">kpoint</span><span class="p">,</span> <span class="n">actual_kpoints</span><span class="p">,</span> <span class="n">weights</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_parse_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem</span><span class="p">:</span> <span class="n">XML_Element</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Structure</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse Structure with lattice, positions and selective dynamics info.&quot;&quot;&quot;</span>
        <span class="n">lattice</span> <span class="o">=</span> <span class="n">_parse_vasp_array</span><span class="p">(</span><span class="n">elem</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;crystal&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;varray&quot;</span><span class="p">))</span>  <span class="c1"># type: ignore[union-attr]</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">_parse_vasp_array</span><span class="p">(</span><span class="n">elem</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;varray&quot;</span><span class="p">))</span>
        <span class="n">struct</span> <span class="o">=</span> <span class="n">Structure</span><span class="p">(</span><span class="n">lattice</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atomic_symbols</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
        <span class="n">selective_dyn</span> <span class="o">=</span> <span class="n">elem</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;varray/[@name=&#39;selective&#39;]&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">selective_dyn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">struct</span><span class="o">.</span><span class="n">add_site_property</span><span class="p">(</span><span class="s2">&quot;selective_dynamics&quot;</span><span class="p">,</span> <span class="n">_parse_vasp_array</span><span class="p">(</span><span class="n">selective_dyn</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">struct</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_parse_diel</span><span class="p">(</span><span class="n">elem</span><span class="p">:</span> <span class="n">XML_Element</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">list</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse dielectric properties.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">elem</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;real&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">elem</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;imag&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">imag</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">[</span><span class="n">_vasprun_float</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>  <span class="c1"># type: ignore[union-attr]</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">elem</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;imag&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;array&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;set&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>  <span class="c1"># type: ignore[union-attr]</span>
            <span class="p">]</span>
            <span class="n">real</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">[</span><span class="n">_vasprun_float</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>  <span class="c1"># type: ignore[union-attr]</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">elem</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;real&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;array&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;set&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>  <span class="c1"># type: ignore[union-attr]</span>
            <span class="p">]</span>
            <span class="n">elem</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">imag</span><span class="p">],</span> <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">real</span><span class="p">],</span> <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">imag</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_parse_optical_transition</span><span class="p">(</span><span class="n">elem</span><span class="p">:</span> <span class="n">XML_Element</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse optical transitions.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">va</span> <span class="ow">in</span> <span class="n">elem</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;varray&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">va</span><span class="o">.</span><span class="n">attrib</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;opticaltransitions&quot;</span><span class="p">:</span>
                <span class="c1"># optical transitions array contains oscillator strength and probability of transition</span>
                <span class="n">oscillator_strength</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">_parse_vasp_array</span><span class="p">(</span><span class="n">va</span><span class="p">))[:]</span>
                <span class="n">probability_transition</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">_parse_vasp_array</span><span class="p">(</span><span class="n">va</span><span class="p">))[:,</span> <span class="mi">1</span><span class="p">]</span>

                <span class="k">return</span> <span class="n">oscillator_strength</span><span class="p">,</span> <span class="n">probability_transition</span>

        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Failed to parse optical transitions.&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_parse_chemical_shielding</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem</span><span class="p">:</span> <span class="n">XML_Element</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse NMR chemical shielding.&quot;&quot;&quot;</span>
        <span class="n">istep</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># not all calculations have a structure</span>
        <span class="n">_struct</span> <span class="o">=</span> <span class="n">elem</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;structure&quot;</span><span class="p">)</span>
        <span class="n">struct</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">_struct</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_structure</span><span class="p">(</span><span class="n">_struct</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">va</span> <span class="ow">in</span> <span class="n">elem</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;varray&quot;</span><span class="p">):</span>
            <span class="n">istep</span><span class="p">[</span><span class="n">va</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">_parse_vasp_array</span><span class="p">(</span><span class="n">va</span><span class="p">)</span>
        <span class="n">istep</span><span class="p">[</span><span class="s2">&quot;structure&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">struct</span>
        <span class="n">istep</span><span class="p">[</span><span class="s2">&quot;electronic_steps&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">calculation</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">istep</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">scstep</span> <span class="ow">in</span> <span class="n">elem</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;scstep&quot;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">e_steps_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]:</span> <span class="n">_vasprun_float</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">text</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">scstep</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;energy&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">)}</span>  <span class="c1"># type: ignore[union-attr, arg-type]</span>
                <span class="n">cur_ene</span> <span class="o">=</span> <span class="n">e_steps_dict</span><span class="p">[</span><span class="s2">&quot;e_fr_energy&quot;</span><span class="p">]</span>
                <span class="n">min_steps</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">calculation</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;NELMIN&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">calculation</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;electronic_steps&quot;</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">min_steps</span><span class="p">:</span>
                    <span class="n">calculation</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;electronic_steps&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e_steps_dict</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">last_ene</span> <span class="o">=</span> <span class="n">calculation</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;electronic_steps&quot;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;e_fr_energy&quot;</span><span class="p">]</span>  <span class="c1"># type: ignore[call-overload]</span>
                    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">cur_ene</span> <span class="o">-</span> <span class="n">last_ene</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">:</span>
                        <span class="n">calculation</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;electronic_steps&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e_steps_dict</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">calculation</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;electronic_steps&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">e_steps_dict</span><span class="p">]})</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>  <span class="c1"># not all calculations have an energy</span>
                <span class="k">pass</span>
        <span class="n">calculation</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">calculation</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;electronic_steps&quot;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">calculation</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_parse_ionic_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem</span><span class="p">:</span> <span class="n">XML_Element</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse an ionic step.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ion_step</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">i</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]:</span> <span class="n">_vasprun_float</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">elem</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;energy&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">)</span>  <span class="c1"># type: ignore[union-attr]</span>
            <span class="p">}</span>
        <span class="c1"># Not all calculations have an energy</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">ion_step</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">elec_steps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">scstep</span> <span class="ow">in</span> <span class="n">elem</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;scstep&quot;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">e_step_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]:</span> <span class="n">_vasprun_float</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">text</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">scstep</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;energy&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">)}</span>  <span class="c1"># type: ignore[union-attr, arg-type]</span>
                <span class="n">elec_steps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e_step_dict</span><span class="p">)</span>
            <span class="c1"># Not all calculations have an energy</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">struct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_structure</span><span class="p">(</span><span class="n">elem</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;structure&quot;</span><span class="p">))</span>  <span class="c1"># type: ignore[arg-type]</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>  <span class="c1"># not all calculations have a structure</span>
            <span class="n">struct</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">va</span> <span class="ow">in</span> <span class="n">elem</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;varray&quot;</span><span class="p">):</span>
            <span class="n">ion_step</span><span class="p">[</span><span class="n">va</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">_parse_vasp_array</span><span class="p">(</span><span class="n">va</span><span class="p">)</span>
        <span class="n">ion_step</span><span class="p">[</span><span class="s2">&quot;electronic_steps&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">elec_steps</span>
        <span class="n">ion_step</span><span class="p">[</span><span class="s2">&quot;structure&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">struct</span>
        <span class="n">elem</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ion_step</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_parse_dos</span><span class="p">(</span><span class="n">elem</span><span class="p">:</span> <span class="n">XML_Element</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Dos</span><span class="p">,</span> <span class="n">Dos</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse density of states (DOS).&quot;&quot;&quot;</span>
        <span class="n">efermi</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">elem</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>  <span class="c1"># type: ignore[union-attr, arg-type]</span>
        <span class="n">energies</span><span class="p">:</span> <span class="n">NDArray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">tdensities</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">idensities</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">soc_run</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">elem</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;total&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;array&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;set&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;set&quot;</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">2</span>  <span class="c1"># type: ignore[union-attr]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">elem</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;total&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;array&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;set&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;set&quot;</span><span class="p">):</span>  <span class="c1"># type: ignore[union-attr]</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">_parse_vasp_array</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
            <span class="n">energies</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">spin</span> <span class="o">=</span> <span class="n">Spin</span><span class="o">.</span><span class="n">up</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;comment&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;spin 1&quot;</span> <span class="k">else</span> <span class="n">Spin</span><span class="o">.</span><span class="n">down</span>
            <span class="k">if</span> <span class="n">spin</span> <span class="o">!=</span> <span class="n">Spin</span><span class="o">.</span><span class="n">up</span> <span class="ow">and</span> <span class="n">soc_run</span><span class="p">:</span>  <span class="c1"># other &#39;spins&#39; are x,y,z SOC projections</span>
                <span class="k">continue</span>
            <span class="n">tdensities</span><span class="p">[</span><span class="n">spin</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">idensities</span><span class="p">[</span><span class="n">spin</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>

        <span class="n">pdoss</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">partial</span> <span class="o">=</span> <span class="n">elem</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;partial&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">partial</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">orbs</span> <span class="o">=</span> <span class="p">[</span><span class="n">ss</span><span class="o">.</span><span class="n">text</span> <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">partial</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;array&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;field&quot;</span><span class="p">)]</span>  <span class="c1"># type: ignore[union-attr]</span>
            <span class="n">orbs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">lm</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="s2">&quot;x&quot;</span> <span class="ow">in</span> <span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">orbs</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">partial</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;array&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;set&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;set&quot;</span><span class="p">):</span>  <span class="c1"># type: ignore[union-attr]</span>
                <span class="n">pdos</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Orbital</span> <span class="o">|</span> <span class="n">OrbitalType</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Spin</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">]]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;set&quot;</span><span class="p">):</span>
                    <span class="n">spin</span> <span class="o">=</span> <span class="n">Spin</span><span class="o">.</span><span class="n">up</span> <span class="k">if</span> <span class="n">ss</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;comment&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;spin 1&quot;</span> <span class="k">else</span> <span class="n">Spin</span><span class="o">.</span><span class="n">down</span>
                    <span class="k">if</span> <span class="n">spin</span> <span class="o">!=</span> <span class="n">Spin</span><span class="o">.</span><span class="n">up</span> <span class="ow">and</span> <span class="n">soc_run</span><span class="p">:</span>  <span class="c1"># other &#39;spins&#39; are x,y,z SOC projections</span>
                        <span class="k">continue</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">_parse_vasp_array</span><span class="p">(</span><span class="n">ss</span><span class="p">))</span>
                    <span class="n">_n_row</span><span class="p">,</span> <span class="n">n_col</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
                    <span class="k">for</span> <span class="n">col_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_col</span><span class="p">):</span>
                        <span class="n">orb</span> <span class="o">=</span> <span class="n">Orbital</span><span class="p">(</span><span class="n">col_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">lm</span> <span class="k">else</span> <span class="n">OrbitalType</span><span class="p">(</span><span class="n">col_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="n">pdos</span><span class="p">[</span><span class="n">orb</span><span class="p">][</span><span class="n">spin</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="n">col_idx</span><span class="p">]</span>  <span class="c1"># type: ignore[index]</span>
                <span class="n">pdoss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pdos</span><span class="p">)</span>
        <span class="n">elem</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">energies</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;energies is None&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">Dos</span><span class="p">(</span><span class="n">efermi</span><span class="p">,</span> <span class="n">energies</span><span class="p">,</span> <span class="n">tdensities</span><span class="p">),</span>
            <span class="n">Dos</span><span class="p">(</span><span class="n">efermi</span><span class="p">,</span> <span class="n">energies</span><span class="p">,</span> <span class="n">idensities</span><span class="p">),</span>
            <span class="n">pdoss</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_parse_eigen</span><span class="p">(</span><span class="n">elem</span><span class="p">:</span> <span class="n">XML_Element</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Spin</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse eigenvalues.&quot;&quot;&quot;</span>
        <span class="n">eigenvalues</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Spin</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">elem</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;array&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;set&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;set&quot;</span><span class="p">):</span>  <span class="c1"># type: ignore[union-attr]</span>
            <span class="n">spin</span> <span class="o">=</span> <span class="n">Spin</span><span class="o">.</span><span class="n">up</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;comment&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;spin 1&quot;</span> <span class="k">else</span> <span class="n">Spin</span><span class="o">.</span><span class="n">down</span>
            <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;set&quot;</span><span class="p">):</span>
                <span class="n">eigenvalues</span><span class="p">[</span><span class="n">spin</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_parse_vasp_array</span><span class="p">(</span><span class="n">ss</span><span class="p">))</span>
        <span class="n">eigenvalues</span> <span class="o">=</span> <span class="p">{</span><span class="n">spin</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">spin</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">eigenvalues</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">elem</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">eigenvalues</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_parse_projected_eigen</span><span class="p">(</span>
        <span class="n">elem</span><span class="p">:</span> <span class="n">XML_Element</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="n">Spin</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">],</span> <span class="n">NDArray</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse projected eigenvalues.&quot;&quot;&quot;</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">elem</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;array&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;set&quot;</span><span class="p">)</span>  <span class="c1"># type: ignore[union-attr]</span>
        <span class="n">_proj_eigen</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;set&quot;</span><span class="p">):</span>  <span class="c1"># type: ignore[union-attr]</span>
            <span class="n">spin</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;spin(\d+)&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;comment&quot;</span><span class="p">])[</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># type: ignore[index]</span>

            <span class="c1"># Force spin to be +1 or -1</span>
            <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;set&quot;</span><span class="p">):</span>
                <span class="n">dk</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">sss</span> <span class="ow">in</span> <span class="n">ss</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;set&quot;</span><span class="p">):</span>
                    <span class="n">db</span> <span class="o">=</span> <span class="n">_parse_vasp_array</span><span class="p">(</span><span class="n">sss</span><span class="p">)</span>
                    <span class="n">dk</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">db</span><span class="p">)</span>
                <span class="n">_proj_eigen</span><span class="p">[</span><span class="n">spin</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dk</span><span class="p">)</span>
        <span class="n">_proj_eigen</span> <span class="o">=</span> <span class="p">{</span><span class="n">spin</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">spin</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">_proj_eigen</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_proj_eigen</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># non-collinear magentism (also spin-orbit coupling) enabled, last three</span>
            <span class="c1"># &quot;spin channels&quot; are the projected magnetization of the orbitals in the</span>
            <span class="c1"># x, y, and z Cartesian coordinates</span>
            <span class="n">proj_mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">_proj_eigen</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># type: ignore[call-overload]</span>
            <span class="n">proj_eigen</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Spin</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">Spin</span><span class="o">.</span><span class="n">up</span><span class="p">:</span> <span class="n">_proj_eigen</span><span class="p">[</span><span class="mi">1</span><span class="p">]}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">proj_eigen</span> <span class="o">=</span> <span class="p">{</span><span class="n">Spin</span><span class="o">.</span><span class="n">up</span> <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">Spin</span><span class="o">.</span><span class="n">down</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">_proj_eigen</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="n">proj_mag</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">elem</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">proj_eigen</span><span class="p">,</span> <span class="n">proj_mag</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_parse_dynmat</span><span class="p">(</span><span class="n">elem</span><span class="p">:</span> <span class="n">XML_Element</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">list</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse dynamical matrix.&quot;&quot;&quot;</span>
        <span class="n">hessian</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">eigenvalues</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">eigenvectors</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">elem</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;eigenvalues&quot;</span><span class="p">:</span>
                <span class="n">eigenvalues</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>  <span class="c1"># type: ignore[union-attr]</span>

        <span class="k">for</span> <span class="n">va</span> <span class="ow">in</span> <span class="n">elem</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;varray&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">va</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;hessian&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">va</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">):</span>
                    <span class="n">hessian</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">split</span><span class="p">()])</span>  <span class="c1"># type: ignore[union-attr]</span>

            <span class="k">elif</span> <span class="n">va</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;eigenvectors&quot;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">va</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">):</span>
                    <span class="n">eigenvectors</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">split</span><span class="p">()])</span>  <span class="c1"># type: ignore[union-attr]</span>

        <span class="k">return</span> <span class="n">hessian</span><span class="p">,</span> <span class="n">eigenvalues</span><span class="p">,</span> <span class="n">eigenvectors</span></div>



<div class="viewcode-block" id="BSVasprun">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.BSVasprun">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BSVasprun</span><span class="p">(</span><span class="n">Vasprun</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A highly optimized version of Vasprun that parses only eigenvalues for</span>
<span class="sd">    bandstructures. All other properties like structures, parameters,</span>
<span class="sd">    etc. are ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filename</span><span class="p">:</span> <span class="n">PathLike</span><span class="p">,</span>
        <span class="n">parse_projected_eigen</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">parse_potcar_file</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">occu_tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">,</span>
        <span class="n">separate_spins</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            filename: Filename to parse</span>
<span class="sd">            parse_projected_eigen: Whether to parse the projected</span>
<span class="sd">                eigenvalues. Defaults to False. Set to True to obtain projected</span>
<span class="sd">                eigenvalues. **Note that this can take an extreme amount of time</span>
<span class="sd">                and memory.** So use this wisely.</span>
<span class="sd">            parse_potcar_file: Whether to parse the potcar file to read</span>
<span class="sd">                the potcar hashes for the potcar_spec attribute. Defaults to True,</span>
<span class="sd">                where no hashes will be determined and the potcar_spec dictionaries</span>
<span class="sd">                will read {&quot;symbol&quot;: ElSymbol, &quot;hash&quot;: None}. By Default, looks in</span>
<span class="sd">                the same directory as the vasprun.xml, with same extensions as</span>
<span class="sd">                Vasprun.xml. If a string is provided, looks at that filepath.</span>
<span class="sd">            occu_tol: Sets the minimum tol for the determination of the</span>
<span class="sd">                vbm and cbm. Usually the default of 1e-8 works well enough,</span>
<span class="sd">                but there may be pathological cases.</span>
<span class="sd">            separate_spins (bool): Whether the band gap, CBM, and VBM should be</span>
<span class="sd">                reported for each individual spin channel. Defaults to False,</span>
<span class="sd">                which computes the eigenvalue band properties independent of</span>
<span class="sd">                the spin orientation. If True, the calculation must be spin-polarized.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">occu_tol</span> <span class="o">=</span> <span class="n">occu_tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">separate_spins</span> <span class="o">=</span> <span class="n">separate_spins</span>

        <span class="k">with</span> <span class="n">zopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;rt&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">efermi</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">parsed_header</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">in_kpoints_opt</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projected_eigenvalues</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kpoints_opt_props</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">event</span><span class="p">,</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">ET</span><span class="o">.</span><span class="n">iterparse</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">events</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">,</span> <span class="s2">&quot;end&quot;</span><span class="p">]):</span>
                <span class="n">tag</span> <span class="o">=</span> <span class="n">elem</span><span class="o">.</span><span class="n">tag</span>
                <span class="k">if</span> <span class="n">event</span> <span class="o">==</span> <span class="s2">&quot;start&quot;</span><span class="p">:</span>
                    <span class="c1"># The start event tells us when we have entered blocks</span>
                    <span class="k">if</span> <span class="n">tag</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;eigenvalues_kpoints_opt&quot;</span><span class="p">,</span> <span class="s2">&quot;projected_kpoints_opt&quot;</span><span class="p">}</span> <span class="ow">or</span> <span class="p">(</span>
                        <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;dos&quot;</span> <span class="ow">and</span> <span class="n">elem</span><span class="o">.</span><span class="n">attrib</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;comment&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;kpoints_opt&quot;</span>
                    <span class="p">):</span>
                        <span class="n">in_kpoints_opt</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">parsed_header</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;generator&quot;</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">generator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_params</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;incar&quot;</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">incar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_params</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;kpoints&quot;</span><span class="p">:</span>
                        <span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">kpoints</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">actual_kpoints</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">actual_kpoints_weights</span><span class="p">,</span>
                        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_kpoints</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;parameters&quot;</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_params</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;atominfo&quot;</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">atomic_symbols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">potcar_symbols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_atominfo</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">potcar_spec</span> <span class="o">=</span> <span class="p">[</span>
                            <span class="p">{</span><span class="s2">&quot;titel&quot;</span><span class="p">:</span> <span class="n">p</span><span class="p">,</span> <span class="s2">&quot;hash&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;summary_stats&quot;</span><span class="p">:</span> <span class="p">{}}</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">potcar_symbols</span>
                        <span class="p">]</span>
                        <span class="n">parsed_header</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">elif</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;i&quot;</span> <span class="ow">and</span> <span class="n">elem</span><span class="o">.</span><span class="n">attrib</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;efermi&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">in_kpoints_opt</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kpoints_opt_props</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">kpoints_opt_props</span> <span class="o">=</span> <span class="n">KpointOptProps</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">kpoints_opt_props</span><span class="o">.</span><span class="n">efermi</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">elem</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
                        <span class="n">in_kpoints_opt</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">efermi</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">elem</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;eigenvalues&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">in_kpoints_opt</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_eigen</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">parse_projected_eigen</span> <span class="ow">and</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;projected&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">in_kpoints_opt</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">projected_eigenvalues</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">projected_magnetisation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_projected_eigen</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">tag</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;eigenvalues_kpoints_opt&quot;</span><span class="p">,</span> <span class="s2">&quot;projected_kpoints_opt&quot;</span><span class="p">):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kpoints_opt_props</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">kpoints_opt_props</span> <span class="o">=</span> <span class="n">KpointOptProps</span><span class="p">()</span>
                    <span class="n">in_kpoints_opt</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="c1"># projected_kpoints_opt includes occupation information whereas</span>
                    <span class="c1"># eigenvalues_kpoints_opt doesn&#39;t.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">kpoints_opt_props</span><span class="o">.</span><span class="n">eigenvalues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_eigen</span><span class="p">(</span><span class="n">elem</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;eigenvalues&quot;</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;eigenvalues_kpoints_opt&quot;</span><span class="p">:</span>
                        <span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">kpoints_opt_props</span><span class="o">.</span><span class="n">kpoints</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">kpoints_opt_props</span><span class="o">.</span><span class="n">actual_kpoints</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">kpoints_opt_props</span><span class="o">.</span><span class="n">actual_kpoints_weights</span><span class="p">,</span>
                        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_kpoints</span><span class="p">(</span><span class="n">elem</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;kpoints&quot;</span><span class="p">))</span>
                    <span class="k">elif</span> <span class="n">parse_projected_eigen</span><span class="p">:</span>  <span class="c1"># and tag == &quot;projected_kpoints_opt&quot;: (implied)</span>
                        <span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">kpoints_opt_props</span><span class="o">.</span><span class="n">projected_eigenvalues</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">kpoints_opt_props</span><span class="o">.</span><span class="n">projected_magnetisation</span><span class="p">,</span>
                        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_projected_eigen</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;structure&quot;</span> <span class="ow">and</span> <span class="n">elem</span><span class="o">.</span><span class="n">attrib</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;finalpos&quot;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">final_structure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_structure</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vasp_version</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="p">[</span><span class="s2">&quot;version&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">parse_potcar_file</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_potcar_spec</span><span class="p">(</span><span class="n">parse_potcar_file</span><span class="p">)</span>

<div class="viewcode-block" id="BSVasprun.as_dict">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.BSVasprun.as_dict">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;JSON-serializable dict representation.&quot;&quot;&quot;</span>
        <span class="n">comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_structure</span><span class="o">.</span><span class="n">composition</span>
        <span class="n">unique_symbols</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atomic_symbols</span><span class="p">))</span>
        <span class="n">dct</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;vasp_version&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">vasp_version</span><span class="p">,</span>
            <span class="s2">&quot;has_vasp_completed&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="s2">&quot;nsites&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">final_structure</span><span class="p">),</span>
            <span class="s2">&quot;unit_cell_formula&quot;</span><span class="p">:</span> <span class="n">comp</span><span class="o">.</span><span class="n">as_dict</span><span class="p">(),</span>
            <span class="s2">&quot;reduced_cell_formula&quot;</span><span class="p">:</span> <span class="n">Composition</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">reduced_formula</span><span class="p">)</span><span class="o">.</span><span class="n">as_dict</span><span class="p">(),</span>
            <span class="s2">&quot;pretty_formula&quot;</span><span class="p">:</span> <span class="n">comp</span><span class="o">.</span><span class="n">reduced_formula</span><span class="p">,</span>
            <span class="s2">&quot;is_hubbard&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_hubbard</span><span class="p">,</span>
            <span class="s2">&quot;hubbards&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">hubbards</span><span class="p">,</span>
            <span class="s2">&quot;elements&quot;</span><span class="p">:</span> <span class="n">unique_symbols</span><span class="p">,</span>
            <span class="s2">&quot;nelements&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_symbols</span><span class="p">),</span>
            <span class="s2">&quot;run_type&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_type</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">vin</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;incar&quot;</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">incar</span><span class="p">),</span>
            <span class="s2">&quot;crystal&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_structure</span><span class="o">.</span><span class="n">as_dict</span><span class="p">(),</span>
            <span class="s2">&quot;kpoints&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">kpoints</span><span class="o">.</span><span class="n">as_dict</span><span class="p">(),</span>
        <span class="p">}</span>
        <span class="n">actual_kpts</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">{</span>
                <span class="s2">&quot;abc&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">actual_kpoints</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                <span class="s2">&quot;weight&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">actual_kpoints_weights</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">actual_kpoints</span><span class="p">))</span>
        <span class="p">]</span>
        <span class="n">vin</span><span class="p">[</span><span class="s2">&quot;kpoints&quot;</span><span class="p">][</span><span class="s2">&quot;actual_points&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">actual_kpts</span>
        <span class="k">if</span> <span class="n">kpt_opt_props</span> <span class="o">:=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;kpoints_opt_props&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">vin</span><span class="p">[</span><span class="s2">&quot;kpoints_opt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kpt_opt_props</span><span class="o">.</span><span class="n">kpoints</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span>
            <span class="n">actual_kpts</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">{</span>
                    <span class="s2">&quot;abc&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">kpt_opt_props</span><span class="o">.</span><span class="n">actual_kpoints</span><span class="p">[</span><span class="n">idx</span><span class="p">]),</span>
                    <span class="s2">&quot;weight&quot;</span><span class="p">:</span> <span class="n">kpt_opt_props</span><span class="o">.</span><span class="n">actual_kpoints_weights</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                <span class="p">}</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">kpt_opt_props</span><span class="o">.</span><span class="n">actual_kpoints</span><span class="p">))</span>
            <span class="p">]</span>
            <span class="n">vin</span><span class="p">[</span><span class="s2">&quot;kpoints_opt&quot;</span><span class="p">][</span><span class="s2">&quot;actual_kpoints&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">actual_kpts</span>
            <span class="n">vin</span><span class="p">[</span><span class="s2">&quot;nkpoints_opt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">actual_kpts</span><span class="p">)</span>
        <span class="n">vin</span><span class="p">[</span><span class="s2">&quot;potcar&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">potcar_symbols</span><span class="p">]</span>
        <span class="n">vin</span><span class="p">[</span><span class="s2">&quot;potcar_spec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">potcar_spec</span>
        <span class="n">vin</span><span class="p">[</span><span class="s2">&quot;potcar_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">potcar_symbols</span><span class="p">]</span>
        <span class="n">vin</span><span class="p">[</span><span class="s2">&quot;parameters&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>
        <span class="n">vin</span><span class="p">[</span><span class="s2">&quot;lattice_rec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">reciprocal_lattice</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span>
        <span class="n">dct</span><span class="p">[</span><span class="s2">&quot;input&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">vin</span>

        <span class="n">vout</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;crystal&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">final_structure</span><span class="o">.</span><span class="n">as_dict</span><span class="p">(),</span>
            <span class="s2">&quot;efermi&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">efermi</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">:</span>
            <span class="n">eigen</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">spin</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
                    <span class="n">eigen</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">spin</span><span class="p">)]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="n">vout</span><span class="p">[</span><span class="s2">&quot;eigenvalues&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">eigen</span>
            <span class="n">gap</span><span class="p">,</span> <span class="n">cbm</span><span class="p">,</span> <span class="n">vbm</span><span class="p">,</span> <span class="n">is_direct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalue_band_properties</span>
            <span class="n">vout</span> <span class="o">|=</span> <span class="p">{</span><span class="s2">&quot;bandgap&quot;</span><span class="p">:</span> <span class="n">gap</span><span class="p">,</span> <span class="s2">&quot;cbm&quot;</span><span class="p">:</span> <span class="n">cbm</span><span class="p">,</span> <span class="s2">&quot;vbm&quot;</span><span class="p">:</span> <span class="n">vbm</span><span class="p">,</span> <span class="s2">&quot;is_gap_direct&quot;</span><span class="p">:</span> <span class="n">is_direct</span><span class="p">}</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">projected_eigenvalues</span><span class="p">:</span>
                <span class="n">peigen</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">eigen</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">spin</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">projected_eigenvalues</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">kpoint_index</span><span class="p">,</span> <span class="n">vv</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
                        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">spin</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">peigen</span><span class="p">[</span><span class="n">kpoint_index</span><span class="p">]:</span>
                            <span class="n">peigen</span><span class="p">[</span><span class="n">kpoint_index</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">spin</span><span class="p">)]</span> <span class="o">=</span> <span class="n">vv</span>
                <span class="n">vout</span><span class="p">[</span><span class="s2">&quot;projected_eigenvalues&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">peigen</span>

        <span class="k">if</span> <span class="n">kpt_opt_props</span> <span class="ow">and</span> <span class="n">kpt_opt_props</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">:</span>
            <span class="n">eigen</span> <span class="o">=</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">spin</span><span class="p">):</span> <span class="n">v</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">for</span> <span class="n">spin</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kpt_opt_props</span><span class="o">.</span><span class="n">eigenvalues</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="n">vout</span><span class="p">[</span><span class="s2">&quot;eigenvalues_kpoints_opt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">eigen</span>
            <span class="c1"># TODO: implement kpoints_opt eigenvalue_band_proprties.</span>
            <span class="c1"># gap, cbm, vbm, is_direct = self.eigenvalue_band_properties</span>
            <span class="c1"># vout |= {&quot;bandgap&quot;: gap, &quot;cbm&quot;: cbm, &quot;vbm&quot;: vbm, &quot;is_gap_direct&quot;: is_direct}</span>

            <span class="k">if</span> <span class="n">kpt_opt_props</span><span class="o">.</span><span class="n">projected_eigenvalues</span><span class="p">:</span>
                <span class="n">vout</span><span class="p">[</span><span class="s2">&quot;projected_eigenvalues_kpoints_opt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">spin</span><span class="p">):</span> <span class="n">v</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">for</span> <span class="n">spin</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kpt_opt_props</span><span class="o">.</span><span class="n">projected_eigenvalues</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">}</span>

        <span class="n">dct</span><span class="p">[</span><span class="s2">&quot;output&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">vout</span>
        <span class="k">return</span> <span class="n">jsanitize</span><span class="p">(</span><span class="n">dct</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="Outcar">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Outcar">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Outcar</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Parser for data in OUTCAR that is not available in vasprun.xml.</span>

<span class="sd">    Note, this class works a bit differently than most of the other</span>
<span class="sd">    VASP parsers, since OUTCAR can be very different depending on which</span>
<span class="sd">    &quot;type of run&quot; performed.</span>

<span class="sd">    Creating an Outcar instance with a filename reads &quot;regular parameters&quot; that</span>
<span class="sd">    are always present. One can then call a specific reader method depending on the</span>
<span class="sd">    type of run being performed, including (see the docstring of corresponding</span>
<span class="sd">    method for more details):</span>
<span class="sd">        - read_avg_core_poten</span>
<span class="sd">        - read_chemical_shielding</span>
<span class="sd">        - read_core_state_eigen</span>
<span class="sd">        - read_corrections</span>
<span class="sd">        - read_cs_core_contribution</span>
<span class="sd">        - read_cs_g0_contribution</span>
<span class="sd">        - read_cs_raw_symmetrized_tensors</span>
<span class="sd">        - read_elastic_tensor</span>
<span class="sd">        - read_electrostatic_potential</span>
<span class="sd">        - read_fermi_contact_shift</span>
<span class="sd">        - read_freq_dielectric</span>
<span class="sd">        - read_igpar</span>
<span class="sd">        - read_internal_strain_tensor</span>
<span class="sd">        - read_lcalcpol</span>
<span class="sd">        - read_lepsilon</span>
<span class="sd">        - read_lepsilon_ionic</span>
<span class="sd">        - read_neb</span>
<span class="sd">        - read_nmr_efg</span>
<span class="sd">        - read_nmr_efg_tensor</span>
<span class="sd">        - read_onsite_density_matrices</span>
<span class="sd">        - read_piezo_tensor</span>
<span class="sd">        - read_pseudo_zval</span>
<span class="sd">        - read_table_pattern</span>

<span class="sd">    Attributes:</span>
<span class="sd">        magnetization (tuple[dict[str, float]]): Magnetization on each ion, e.g.</span>
<span class="sd">            ({&quot;d&quot;: 0.0, &quot;p&quot;: 0.003, &quot;s&quot;: 0.002, &quot;tot&quot;: 0.005}, ... ).</span>
<span class="sd">        chemical_shielding (dict): Chemical shielding on each ion with core and valence contributions.</span>
<span class="sd">        unsym_cs_tensor (list): Unsymmetrized chemical shielding tensor matrixes on each ion.</span>
<span class="sd">            e.g. [[[sigma11, sigma12, sigma13], [sigma21, sigma22, sigma23], [sigma31, sigma32, sigma33]], ...]</span>
<span class="sd">        cs_g0_contribution (NDArray): G=0 contribution to chemical shielding. 2D rank 3 matrix.</span>
<span class="sd">        cs_core_contribution (dict[str, float]): Core contribution to chemical shielding. e.g.</span>
<span class="sd">            {&#39;Mg&#39;: -412.8, &#39;C&#39;: -200.5, &#39;O&#39;: -271.1}</span>
<span class="sd">        efg (tuple[dict[str, float]]): Electric Field Gradient (EFG) tensor on each ion, e.g.</span>
<span class="sd">            ({&quot;cq&quot;: 0.1, &quot;eta&quot;, 0.2, &quot;nuclear_quadrupole_moment&quot;: 0.3}, {&quot;cq&quot;: 0.7, &quot;eta&quot;, 0.8,</span>
<span class="sd">            &quot;nuclear_quadrupole_moment&quot;: 0.9}, ...)</span>
<span class="sd">        charge (tuple[dict[str, float]]): Charge on each ion, e.g.</span>
<span class="sd">            ({&quot;p&quot;: 0.154, &quot;s&quot;: 0.078, &quot;d&quot;: 0.0, &quot;tot&quot;: 0.232}, ...)</span>
<span class="sd">        is_stopped (bool): True if OUTCAR is from a stopped run (using STOPCAR, see VASP Manual).</span>
<span class="sd">        run_stats (dict[str, float | None]): Various useful run stats including &quot;System time (sec)&quot;,</span>
<span class="sd">            &quot;Total CPU time used (sec)&quot;, &quot;Elapsed time (sec)&quot;, &quot;Maximum memory used (kb)&quot;,</span>
<span class="sd">            &quot;Average memory used (kb)&quot;, &quot;User time (sec)&quot;, &quot;cores&quot;.</span>
<span class="sd">        elastic_tensor (NDArray): Total elastic moduli (Kbar) is given in a 6x6 array matrix.</span>
<span class="sd">        drift (NDArray): Total drift for each step in eV/Atom.</span>
<span class="sd">        ngf (tuple): Dimensions for the Augmentation grid.</span>
<span class="sd">        sampling_radii (NDArray): Size of the sampling radii in VASP for the test charges for the electrostatic</span>
<span class="sd">            potential at each atom. Total array size is the number of elements present in the calculation.</span>
<span class="sd">        electrostatic_potential (NDArray): Average electrostatic potential at each atomic position in order of</span>
<span class="sd">            the atoms in POSCAR.</span>
<span class="sd">        final_energy_contribs (dict[str, float]): Individual contributions to the total final energy.</span>
<span class="sd">            Include contributions from keys, e.g.:</span>
<span class="sd">            {&#39;DENC&#39;: -505778.5184347, &#39;EATOM&#39;: 15561.06492564, &#39;EBANDS&#39;: -804.53201231, &#39;EENTRO&#39;: -0.08932659,</span>
<span class="sd">            &#39;EXHF&#39;: 0.0, &#39;Ediel_sol&#39;: 0.0, &#39;PAW double counting&#39;: 664.6726974100002, &#39;PSCENC&#39;: 742.48691646,</span>
<span class="sd">            &#39;TEWEN&#39;: 489742.86847338, &#39;XCENC&#39;: -169.64189814}</span>
<span class="sd">        efermi (float): Fermi energy.</span>
<span class="sd">        filename (PathLike): Filename.</span>
<span class="sd">        final_energy (float): Final energy after extrapolation of sigma back to 0, i.e. energy(sigma-&gt;0).</span>
<span class="sd">        final_energy_wo_entrp (float): Final energy before extrapolation of sigma, i.e. energy without entropy.</span>
<span class="sd">        final_fr_energy (float): Final &quot;free energy&quot;, i.e. free energy TOTEN.</span>
<span class="sd">        has_onsite_density_matrices (bool): Whether onsite density matrices have been set.</span>
<span class="sd">        lcalcpol (bool): If LCALCPOL has been set.</span>
<span class="sd">        lepsilon (bool): If LEPSILON has been set.</span>
<span class="sd">        nelect (float): The number of electrons in the calculation.</span>
<span class="sd">        spin (bool): If spin-polarization is enabled via ISPIN.</span>
<span class="sd">        total_mag (float): Total magnetization (in terms of the number of unpaired electrons).</span>

<span class="sd">    Authors: Rickard Armiento, Shyue Ping Ong</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="n">PathLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            filename (PathLike): OUTCAR file to parse.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_stopped</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Assume a compilation with parallelization enabled.</span>
        <span class="c1"># Will be checked later.</span>
        <span class="c1"># If VASP is compiled in serial, the OUTCAR is written slightly differently.</span>
        <span class="n">serial_compilation</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Data from the end of OUTCAR</span>
        <span class="n">charge</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mag_x</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mag_y</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mag_z</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">header</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">run_stats</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">total_mag</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">nelect</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">efermi</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">e_fr_energy</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">e_wo_entrp</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">e0</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">time_patt</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\((sec|kb)\)&quot;</span><span class="p">)</span>
        <span class="n">efermi_patt</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;E-fermi\s*:\s*(\S+)&quot;</span><span class="p">)</span>
        <span class="n">nelect_patt</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;number of electron\s+(\S+)\s+magnetization&quot;</span><span class="p">)</span>
        <span class="n">mag_patt</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;number of electron\s+\S+\s+magnetization\s+(\S+)&quot;</span><span class="p">)</span>
        <span class="n">e_fr_energy_pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;free  energy   TOTEN\s+=\s+([\d\-\.]+)&quot;</span><span class="p">)</span>
        <span class="n">e_wo_entrp_pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;energy  without entropy\s*=\s+([\d\-\.]+)&quot;</span><span class="p">)</span>
        <span class="n">e0_pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;energy\(sigma-&gt;0\)\s*=\s+([\d\-\.]+)&quot;</span><span class="p">)</span>

        <span class="n">all_lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">reverse_readfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">):</span>
            <span class="n">clean</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="n">all_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clean</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">clean</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;soft stop encountered!  aborting job&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">is_stopped</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">time_patt</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
                    <span class="n">tok</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="c1"># try-catch because VASP 6.2.0 may print</span>
                        <span class="c1"># Average memory used (kb):          N/A</span>
                        <span class="c1"># which cannot be parsed as float</span>
                        <span class="n">run_stats</span><span class="p">[</span><span class="n">tok</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tok</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="n">run_stats</span><span class="p">[</span><span class="n">tok</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()]</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">match</span> <span class="o">:=</span> <span class="n">efermi_patt</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">clean</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="c1"># try-catch because VASP sometimes prints</span>
                        <span class="c1"># &#39;E-fermi: ********     XC(G=0):  -6.1327</span>
                        <span class="c1"># alpha+bet : -1.8238&#39;</span>
                        <span class="n">efermi</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                        <span class="k">continue</span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="n">efermi</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="k">continue</span>
                <span class="k">if</span> <span class="n">match</span> <span class="o">:=</span> <span class="n">nelect_patt</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">clean</span><span class="p">):</span>
                    <span class="n">nelect</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">match</span> <span class="o">:=</span> <span class="n">mag_patt</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">clean</span><span class="p">):</span>
                    <span class="n">total_mag</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">e_fr_energy</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">match</span> <span class="o">:=</span> <span class="n">e_fr_energy_pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">clean</span><span class="p">)):</span>
                    <span class="n">e_fr_energy</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">e_wo_entrp</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">match</span> <span class="o">:=</span> <span class="n">e_wo_entrp_pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">clean</span><span class="p">)):</span>
                    <span class="n">e_wo_entrp</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">e0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">match</span> <span class="o">:=</span> <span class="n">e0_pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">clean</span><span class="p">)):</span>
                    <span class="n">e0</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">nelect</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">total_mag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">efermi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">run_stats</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="c1"># For single atom systems, VASP doesn&#39;t print a total line, so</span>
        <span class="c1"># reverse parsing is very difficult</span>
        <span class="n">read_charge</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">read_mag_x</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">read_mag_y</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># for SOC calculations only</span>
        <span class="n">read_mag_z</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">all_lines</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">clean</span> <span class="ow">in</span> <span class="n">all_lines</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">read_charge</span> <span class="ow">or</span> <span class="n">read_mag_x</span> <span class="ow">or</span> <span class="n">read_mag_y</span> <span class="ow">or</span> <span class="n">read_mag_z</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">clean</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;# of ion&quot;</span><span class="p">):</span>
                    <span class="n">header</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\s{2,}&quot;</span><span class="p">,</span> <span class="n">clean</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
                    <span class="n">header</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">match</span> <span class="o">:=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\s*(\d+)\s+(([\d\.\-]+)\s+)+&quot;</span><span class="p">,</span> <span class="n">clean</span><span class="p">):</span>
                    <span class="n">tokens</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[\d\.\-]+&quot;</span><span class="p">,</span> <span class="n">clean</span><span class="p">)]</span>
                    <span class="n">tokens</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">read_charge</span><span class="p">:</span>
                        <span class="n">charge</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)))</span>
                    <span class="k">elif</span> <span class="n">read_mag_x</span><span class="p">:</span>
                        <span class="n">mag_x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)))</span>
                    <span class="k">elif</span> <span class="n">read_mag_y</span><span class="p">:</span>
                        <span class="n">mag_y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)))</span>
                    <span class="k">elif</span> <span class="n">read_mag_z</span><span class="p">:</span>
                        <span class="n">mag_z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)))</span>
                <span class="k">elif</span> <span class="n">clean</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;tot&quot;</span><span class="p">):</span>
                    <span class="n">read_charge</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">read_mag_x</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">read_mag_y</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">read_mag_z</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">clean</span> <span class="o">==</span> <span class="s2">&quot;total charge&quot;</span><span class="p">:</span>
                <span class="n">charge</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">read_charge</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">read_mag_x</span><span class="p">,</span> <span class="n">read_mag_y</span><span class="p">,</span> <span class="n">read_mag_z</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">clean</span> <span class="o">==</span> <span class="s2">&quot;magnetization (x)&quot;</span><span class="p">:</span>
                <span class="n">mag_x</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">read_mag_x</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">read_charge</span><span class="p">,</span> <span class="n">read_mag_y</span><span class="p">,</span> <span class="n">read_mag_z</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">clean</span> <span class="o">==</span> <span class="s2">&quot;magnetization (y)&quot;</span><span class="p">:</span>
                <span class="n">mag_y</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">read_mag_y</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">read_charge</span><span class="p">,</span> <span class="n">read_mag_x</span><span class="p">,</span> <span class="n">read_mag_z</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">clean</span> <span class="o">==</span> <span class="s2">&quot;magnetization (z)&quot;</span><span class="p">:</span>
                <span class="n">mag_z</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">read_mag_z</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">read_charge</span><span class="p">,</span> <span class="n">read_mag_x</span><span class="p">,</span> <span class="n">read_mag_y</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;electrostatic&quot;</span><span class="p">,</span> <span class="n">clean</span><span class="p">):</span>
                <span class="n">read_charge</span><span class="p">,</span> <span class="n">read_mag_x</span><span class="p">,</span> <span class="n">read_mag_y</span><span class="p">,</span> <span class="n">read_mag_z</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="kc">False</span><span class="p">,</span>
                    <span class="kc">False</span><span class="p">,</span>
                    <span class="kc">False</span><span class="p">,</span>
                    <span class="kc">False</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="c1"># Merge x, y and z components of magmoms if present (SOC calculation)</span>
        <span class="k">if</span> <span class="n">mag_y</span> <span class="ow">and</span> <span class="n">mag_z</span><span class="p">:</span>
            <span class="c1"># TODO: detect spin axis</span>
            <span class="n">mag</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mag_x</span><span class="p">)):</span>
                <span class="n">mag</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="n">key</span><span class="p">:</span> <span class="n">Magmom</span><span class="p">([</span><span class="n">mag_x</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">key</span><span class="p">],</span> <span class="n">mag_y</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">key</span><span class="p">],</span> <span class="n">mag_z</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">key</span><span class="p">]])</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">mag_x</span><span class="p">[</span><span class="mi">0</span><span class="p">]})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mag</span> <span class="o">=</span> <span class="n">mag_x</span>

        <span class="c1"># Data from beginning of OUTCAR</span>
        <span class="n">run_stats</span><span class="p">[</span><span class="s2">&quot;cores&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">with</span> <span class="n">zopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;rt&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">file</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;serial&quot;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                    <span class="c1"># Activate serial parallelization</span>
                    <span class="n">run_stats</span><span class="p">[</span><span class="s2">&quot;cores&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">serial_compilation</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
                <span class="k">if</span> <span class="s2">&quot;running&quot;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;on&quot;</span><span class="p">:</span>
                        <span class="n">run_stats</span><span class="p">[</span><span class="s2">&quot;cores&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">2</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">run_stats</span><span class="p">[</span><span class="s2">&quot;cores&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">break</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">run_stats</span> <span class="o">=</span> <span class="n">run_stats</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">magnetization</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">mag</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">charge</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">charge</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">efermi</span> <span class="o">=</span> <span class="n">efermi</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nelect</span> <span class="o">=</span> <span class="n">nelect</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_mag</span> <span class="o">=</span> <span class="n">total_mag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final_energy</span> <span class="o">=</span> <span class="n">e0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final_energy_wo_entrp</span> <span class="o">=</span> <span class="n">e_wo_entrp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final_fr_energy</span> <span class="o">=</span> <span class="n">e_fr_energy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Read &quot;number of bands&quot; (NBANDS)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_pattern</span><span class="p">(</span>
            <span class="p">{</span><span class="s2">&quot;nbands&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;number\s+of\s+bands\s+NBANDS=\s+(\d+)&quot;</span><span class="p">},</span>
            <span class="n">terminate_on_match</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">postprocess</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;nbands&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;nbands&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Read &quot;total number of plane waves&quot; (NPLWV)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_pattern</span><span class="p">(</span>
            <span class="p">{</span><span class="s2">&quot;nplwv&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;total plane-waves  NPLWV =\s+(\*</span><span class="si">{6}</span><span class="s2">|\d+)&quot;</span><span class="p">},</span>
            <span class="n">terminate_on_match</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;nplwv&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;nplwv&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])]]</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;nplwv&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">None</span><span class="p">]]</span>

        <span class="n">nplwvs_at_kpoints</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">n</span>
            <span class="k">for</span> <span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_table_pattern</span><span class="p">(</span>
                <span class="sa">r</span><span class="s2">&quot;\n</span><span class="si">{3}</span><span class="s2">-</span><span class="si">{104}</span><span class="s2">\n</span><span class="si">{3}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="sa">r</span><span class="s2">&quot;.+plane waves:\s+(\*{6,}|\d+)&quot;</span><span class="p">,</span>
                <span class="p">(</span>
                    <span class="sa">r</span><span class="s2">&quot;maximum number of plane-waves&quot;</span>
                    <span class="k">if</span> <span class="n">serial_compilation</span>
                    <span class="k">else</span> <span class="sa">r</span><span class="s2">&quot;maximum and minimum number of plane-waves&quot;</span>
                <span class="p">),</span>
                <span class="n">last_one_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">first_one_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;nplwvs_at_kpoints&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nplwvs_at_kpoints</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">nplwv</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nplwvs_at_kpoints</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;nplwvs_at_kpoints&quot;</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nplwv</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="c1"># Read the drift</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_pattern</span><span class="p">(</span>
            <span class="p">{</span><span class="s2">&quot;drift&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;total drift:\s+([\.\-\d]+)\s+([\.\-\d]+)\s+([\.\-\d]+)&quot;</span><span class="p">},</span>
            <span class="n">postprocess</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">drift</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;drift&quot;</span><span class="p">,</span> <span class="p">[])</span>

        <span class="c1"># Check if calculation is spin polarized</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_pattern</span><span class="p">({</span><span class="s2">&quot;spin&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;ISPIN\s*=\s*2&quot;</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spin</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;spin&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>

        <span class="c1"># Check if calculation is non-collinear</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_pattern</span><span class="p">({</span><span class="s2">&quot;noncollinear&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;LNONCOLLINEAR\s*=\s*T&quot;</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">noncollinear</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;noncollinear&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>

        <span class="c1"># Check if the calculation type is DFPT</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_pattern</span><span class="p">(</span>
            <span class="p">{</span><span class="s2">&quot;ibrion&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;IBRION =\s+([\-\d]+)&quot;</span><span class="p">},</span>
            <span class="n">terminate_on_match</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">postprocess</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ibrion&quot;</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]])[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">6</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dfpt</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_internal_strain_tensor</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dfpt</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Check if LEPSILON is True and read piezo data if so</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_pattern</span><span class="p">({</span><span class="s2">&quot;epsilon&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;LEPSILON\s*=\s*T&quot;</span><span class="p">})</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;epsilon&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lepsilon</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_lepsilon</span><span class="p">()</span>
            <span class="c1"># Only read ionic contribution if DFPT is turned on</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfpt</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">read_lepsilon_ionic</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lepsilon</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Check if LCALCPOL is True and read polarization data if so</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_pattern</span><span class="p">({</span><span class="s2">&quot;calcpol&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;LCALCPOL\s*=\s*T&quot;</span><span class="p">})</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;calcpol&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lcalcpol</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_lcalcpol</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_pseudo_zval</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lcalcpol</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Read electrostatic potential</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">electrostatic_potential</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ngf</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling_radii</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_pattern</span><span class="p">({</span><span class="s2">&quot;electrostatic&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;average \(electrostatic\) potential at core&quot;</span><span class="p">})</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;electrostatic&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_electrostatic_potential</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">read_pattern</span><span class="p">({</span><span class="s2">&quot;nmr_cs&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;LCHIMAG\s*=\s*(T)&quot;</span><span class="p">})</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;nmr_cs&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nmr_cs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_chemical_shielding</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_cs_g0_contribution</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_cs_core_contribution</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_cs_raw_symmetrized_tensors</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nmr_cs</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">read_pattern</span><span class="p">({</span><span class="s2">&quot;nmr_efg&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;NMR quadrupolar parameters&quot;</span><span class="p">})</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;nmr_efg&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nmr_efg</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_nmr_efg</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_nmr_efg_tensor</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nmr_efg</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">read_pattern</span><span class="p">(</span>
            <span class="p">{</span><span class="s2">&quot;has_onsite_density_matrices&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;onsite density matrix&quot;</span><span class="p">},</span>
            <span class="n">terminate_on_match</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;has_onsite_density_matrices&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">has_onsite_density_matrices</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_onsite_density_matrices</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">has_onsite_density_matrices</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Store the individual contributions to the final total energy</span>
        <span class="n">final_energy_contribs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span>
            <span class="s2">&quot;PSCENC&quot;</span><span class="p">,</span>
            <span class="s2">&quot;TEWEN&quot;</span><span class="p">,</span>
            <span class="s2">&quot;DENC&quot;</span><span class="p">,</span>
            <span class="s2">&quot;EXHF&quot;</span><span class="p">,</span>
            <span class="s2">&quot;XCENC&quot;</span><span class="p">,</span>
            <span class="s2">&quot;PAW double counting&quot;</span><span class="p">,</span>
            <span class="s2">&quot;EENTRO&quot;</span><span class="p">,</span>
            <span class="s2">&quot;EBANDS&quot;</span><span class="p">,</span>
            <span class="s2">&quot;EATOM&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Ediel_sol&quot;</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;PAW double counting&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">read_pattern</span><span class="p">({</span><span class="n">key</span><span class="p">:</span> <span class="sa">rf</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">\s+=\s+([\.\-\d]+)\s+([\.\-\d]+)&quot;</span><span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">read_pattern</span><span class="p">({</span><span class="n">key</span><span class="p">:</span> <span class="sa">rf</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">\s+=\s+([\d\-\.]+)&quot;</span><span class="p">})</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="n">final_energy_contribs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final_energy_contribs</span> <span class="o">=</span> <span class="n">final_energy_contribs</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_parse_sci_notation</span><span class="p">(</span><span class="n">line</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parse lines with values in scientific notation and potentially</span>
<span class="sd">        without spaces in between the values. This assumes that the scientific</span>
<span class="sd">        notation always lists two digits for the exponent, e.g. 3.535E-02.</span>

<span class="sd">        Args:</span>
<span class="sd">            line: line to parse.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[float]: numbers if found, empty list if not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">match</span> <span class="o">:=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[\.\-\d]+E[\+\-]\d</span><span class="si">{2}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">line</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">match</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[]</span>

<div class="viewcode-block" id="Outcar.as_dict">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Outcar.as_dict">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;MSONable dict.&quot;&quot;&quot;</span>
        <span class="n">dct</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;@module&quot;</span><span class="p">:</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span>
            <span class="s2">&quot;@class&quot;</span><span class="p">:</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="s2">&quot;efermi&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">efermi</span><span class="p">,</span>
            <span class="s2">&quot;run_stats&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_stats</span><span class="p">,</span>
            <span class="s2">&quot;magnetization&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">magnetization</span><span class="p">,</span>
            <span class="s2">&quot;charge&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">charge</span><span class="p">,</span>
            <span class="s2">&quot;total_magnetization&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_mag</span><span class="p">,</span>
            <span class="s2">&quot;nelect&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nelect</span><span class="p">,</span>
            <span class="s2">&quot;is_stopped&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stopped</span><span class="p">,</span>
            <span class="s2">&quot;drift&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">drift</span><span class="p">,</span>
            <span class="s2">&quot;ngf&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ngf</span><span class="p">,</span>
            <span class="s2">&quot;sampling_radii&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_radii</span><span class="p">,</span>
            <span class="s2">&quot;electrostatic_potential&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">electrostatic_potential</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lepsilon</span><span class="p">:</span>
            <span class="n">dct</span> <span class="o">|=</span> <span class="p">{</span>
                <span class="s2">&quot;piezo_tensor&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">piezo_tensor</span><span class="p">,</span>
                <span class="s2">&quot;dielectric_tensor&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_tensor</span><span class="p">,</span>
                <span class="s2">&quot;born&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">born</span><span class="p">,</span>
            <span class="p">}</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfpt</span><span class="p">:</span>
            <span class="n">dct</span><span class="p">[</span><span class="s2">&quot;internal_strain_tensor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">internal_strain_tensor</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfpt</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">lepsilon</span><span class="p">:</span>
            <span class="n">dct</span> <span class="o">|=</span> <span class="p">{</span>
                <span class="s2">&quot;piezo_ionic_tensor&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">piezo_ionic_tensor</span><span class="p">,</span>
                <span class="s2">&quot;dielectric_ionic_tensor&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_ionic_tensor</span><span class="p">,</span>
            <span class="p">}</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lcalcpol</span><span class="p">:</span>
            <span class="n">dct</span> <span class="o">|=</span> <span class="p">{</span><span class="s2">&quot;p_elec&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_elec</span><span class="p">,</span> <span class="s2">&quot;p_ion&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_ion</span><span class="p">}</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">noncollinear</span><span class="p">:</span>
                <span class="n">dct</span> <span class="o">|=</span> <span class="p">{</span><span class="s2">&quot;p_sp1&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_sp1</span><span class="p">,</span> <span class="s2">&quot;p_sp2&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_sp2</span><span class="p">}</span>
            <span class="n">dct</span><span class="p">[</span><span class="s2">&quot;zval_dict&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zval_dict</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmr_cs</span><span class="p">:</span>
            <span class="n">dct</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="n">nmr_cs</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;valence and core&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;chemical_shielding&quot;</span><span class="p">][</span><span class="s2">&quot;valence_and_core&quot;</span><span class="p">],</span>
                    <span class="s2">&quot;valence_only&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;chemical_shielding&quot;</span><span class="p">][</span><span class="s2">&quot;valence_only&quot;</span><span class="p">],</span>
                    <span class="s2">&quot;g0&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;cs_g0_contribution&quot;</span><span class="p">],</span>
                    <span class="s2">&quot;core&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;cs_core_contribution&quot;</span><span class="p">],</span>
                    <span class="s2">&quot;raw&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;unsym_cs_tensor&quot;</span><span class="p">],</span>
                <span class="p">}</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmr_efg</span><span class="p">:</span>
            <span class="n">dct</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                <span class="n">nmr_efg</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;raw&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;unsym_efg_tensor&quot;</span><span class="p">],</span>
                    <span class="s2">&quot;parameters&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;efg&quot;</span><span class="p">],</span>
                <span class="p">}</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_onsite_density_matrices</span><span class="p">:</span>
            <span class="c1"># Cast Spin to str for consistency with electronic_structure</span>
            <span class="c1"># TODO: improve handling of Enum (de)serialization in monty</span>
            <span class="n">onsite_density_matrices</span> <span class="o">=</span> <span class="p">[{</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">):</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;onsite_density_matrices&quot;</span><span class="p">]]</span>
            <span class="n">dct</span><span class="p">[</span><span class="s2">&quot;onsite_density_matrices&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">onsite_density_matrices</span>

        <span class="k">return</span> <span class="n">dct</span></div>


<div class="viewcode-block" id="Outcar.read_pattern">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Outcar.read_pattern">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_pattern</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">patterns</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
        <span class="n">reverse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">terminate_on_match</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">postprocess</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="nb">str</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        General pattern reading. Use monty&#39;s regrep method and take the same</span>
<span class="sd">        arguments.</span>

<span class="sd">        Args:</span>
<span class="sd">            patterns (dict[str, str]): Patterns, e.g.</span>
<span class="sd">                {&quot;energy&quot;: r&quot;energy\\(sigma-&gt;0\\)\\s+=\\s+([\\d\\-.]+)&quot;}.</span>
<span class="sd">            reverse (bool): Read files in reverse. Defaults to false. Useful for</span>
<span class="sd">                large files like OUTCARs, especially when used with</span>
<span class="sd">                terminate_on_match.</span>
<span class="sd">            terminate_on_match (bool): Whether to terminate when there is at</span>
<span class="sd">                least one match for each key in patterns.</span>
<span class="sd">            postprocess (Callable): A post processing function to convert all</span>
<span class="sd">                matches. Defaults to str, i.e., no change.</span>

<span class="sd">        Renders accessible from self.data:</span>
<span class="sd">            Any attribute in patterns. For example,</span>
<span class="sd">            {&quot;energy&quot;: r&quot;energy\\(sigma-&gt;0\\)\\s+=\\s+([\\d\\-.]+)&quot;} will set the</span>
<span class="sd">            value of self.data[&quot;energy&quot;] = [[-1234], [-3453], ...], to the</span>
<span class="sd">            results from regex and postprocess. Note that the values</span>
<span class="sd">            are list[list], because you can grep multiple items on one line.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="n">regrep</span><span class="p">(</span>
            <span class="n">filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span>
            <span class="n">patterns</span><span class="o">=</span><span class="n">patterns</span><span class="p">,</span>
            <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">,</span>
            <span class="n">terminate_on_match</span><span class="o">=</span><span class="n">terminate_on_match</span><span class="p">,</span>
            <span class="n">postprocess</span><span class="o">=</span><span class="n">postprocess</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">patterns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">matches</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">[])]</span></div>


<div class="viewcode-block" id="Outcar.read_table_pattern">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Outcar.read_table_pattern">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_table_pattern</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">header_pattern</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">row_pattern</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">footer_pattern</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">postprocess</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">attribute_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">last_one_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">first_one_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Parse table-like data. A table composes of three parts: header,</span>
<span class="sd">        main body, footer. All the data matches &quot;row pattern&quot; in the main body</span>
<span class="sd">        will be returned.</span>

<span class="sd">        Args:</span>
<span class="sd">            header_pattern (str): The regular expression pattern matches the</span>
<span class="sd">                table header. This pattern should match all the text</span>
<span class="sd">                immediately before the main body of the table. For multiple</span>
<span class="sd">                sections table match the text until the section of</span>
<span class="sd">                interest. MULTILINE and DOTALL options are enforced, as a</span>
<span class="sd">                result, the &quot;.&quot; meta-character will also match &quot;\n&quot; in this</span>
<span class="sd">                section.</span>
<span class="sd">            row_pattern (str): The regular expression matches a single line in</span>
<span class="sd">                the table. Capture interested field using regular expression</span>
<span class="sd">                groups.</span>
<span class="sd">            footer_pattern (str): The regular expression matches the end of the</span>
<span class="sd">                table. E.g. a long dash line.</span>
<span class="sd">            postprocess (Callable): A post processing function to convert all</span>
<span class="sd">                matches. Defaults to str, i.e., no change.</span>
<span class="sd">            attribute_name (str): Name of this table. If present the parsed data</span>
<span class="sd">                will be attached to &quot;data. e.g. self.data[&quot;efg&quot;] = [...]</span>
<span class="sd">            last_one_only (bool): All the tables will be parsed, if this option</span>
<span class="sd">                is set to True, only the last table will be returned. The</span>
<span class="sd">                enclosing list will be removed. i.e. Only a single table will</span>
<span class="sd">                be returned. Default to be True. Incompatible with first_one_only.</span>
<span class="sd">            first_one_only (bool): Only the first occurrence of the table will be</span>
<span class="sd">                parsed and the parsing procedure will stop. The enclosing list</span>
<span class="sd">                will be removed. i.e. Only a single table will be returned.</span>
<span class="sd">                Incompatible with last_one_only.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of tables or a single table if last_one_only/first_one_only is True.</span>
<span class="sd">                1) A table is a list of rows. 2) A row is either a list of attribute</span>
<span class="sd">                values in case the capturing group is defined without name in row_pattern,</span>
<span class="sd">                or a dict in case that named capturing groups are defined by row_pattern.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">last_one_only</span> <span class="ow">and</span> <span class="n">first_one_only</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;last_one_only and first_one_only options are incompatible&quot;</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">zopen</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;rt&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="n">table_pattern_text</span> <span class="o">=</span> <span class="n">header_pattern</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;\s*^(?P&lt;table_body&gt;(?:\s+&quot;</span> <span class="o">+</span> <span class="n">row_pattern</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;)+)\s+&quot;</span> <span class="o">+</span> <span class="n">footer_pattern</span>
        <span class="n">table_pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">table_pattern_text</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>
        <span class="n">rp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">row_pattern</span><span class="p">)</span>

        <span class="n">TableData</span><span class="p">:</span> <span class="n">TypeAlias</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span>
        <span class="n">tables</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">TableData</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">mt</span> <span class="ow">in</span> <span class="n">table_pattern</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
            <span class="n">table_body_text</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;table_body&quot;</span><span class="p">)</span>
            <span class="n">table_contents</span><span class="p">:</span> <span class="n">TableData</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">table_body_text</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">):</span>
                <span class="n">ml</span> <span class="o">=</span> <span class="n">rp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                <span class="c1"># Skip empty lines</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ml</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">ml</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">processed_line</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">postprocess</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">processed_line</span> <span class="o">=</span> <span class="p">[</span><span class="n">postprocess</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ml</span><span class="o">.</span><span class="n">groups</span><span class="p">()]</span>
                <span class="n">table_contents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">processed_line</span><span class="p">)</span>
            <span class="n">tables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">table_contents</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">first_one_only</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="n">retained_data</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">TableData</span><span class="p">]</span> <span class="o">|</span> <span class="n">TableData</span> <span class="o">=</span> <span class="n">tables</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">last_one_only</span> <span class="ow">or</span> <span class="n">first_one_only</span> <span class="k">else</span> <span class="n">tables</span>
        <span class="k">if</span> <span class="n">attribute_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">attribute_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">retained_data</span>
        <span class="k">return</span> <span class="n">retained_data</span></div>


<div class="viewcode-block" id="Outcar.read_electrostatic_potential">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Outcar.read_electrostatic_potential">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_electrostatic_potential</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse the eletrostatic potential for the last ionic step.</span>

<span class="sd">        Renders accessible as attributes:</span>
<span class="sd">            ngf (list[int, int, int]): Number of grid points along x, y, z dimensions.</span>
<span class="sd">            sampling_radii (list[float, float, float]): Test charge radii.</span>
<span class="sd">            electrostatic_potential (list[float]): The eletrostatic potential.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pattern</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;ngf&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;\s+dimension x,y,z NGXF=\s+([\.\-\d]+)\sNGYF=\s+([\.\-\d]+)\sNGZF=\s+([\.\-\d]+)&quot;</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_pattern</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">postprocess</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ngf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ngf&quot;</span><span class="p">,</span> <span class="p">[[]])[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">pattern</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;radii&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;the test charge radii are((?:\s+[\.\-\d]+)+)&quot;</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_pattern</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">terminate_on_match</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">postprocess</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling_radii</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;radii&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">())]</span>

        <span class="n">header_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\(the norm of the test charge is\s+[\.\-\d]+\)&quot;</span>
        <span class="n">table_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;((?:\s+\d+\s*[\.\-\d]+)+)&quot;</span>
        <span class="n">footer_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\s+E-fermi :&quot;</span>

        <span class="n">pot_patterns</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_table_pattern</span><span class="p">(</span><span class="n">header_pattern</span><span class="p">,</span> <span class="n">table_pattern</span><span class="p">,</span> <span class="n">footer_pattern</span><span class="p">)</span>
        <span class="n">pot_patterns_str</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">pot_patterns</span><span class="p">))</span>
        <span class="n">pots</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\s+\d+\s*([\.\-\d]+)+&quot;</span><span class="p">,</span> <span class="n">pot_patterns_str</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">electrostatic_potential</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">pots</span><span class="p">)]</span></div>


<div class="viewcode-block" id="Outcar.read_freq_dielectric">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Outcar.read_freq_dielectric">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_freq_dielectric</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parse the frequency dependent dielectric function (obtained with LOPTICS).</span>

<span class="sd">        Renders accessible as attributes:</span>
<span class="sd">            plasma_frequencies (dict[Literal[&quot;intraband&quot;, &quot;interband&quot;], NDArray[float64]]):</span>
<span class="sd">                plasma frequency in eV.</span>
<span class="sd">            dielectric_energies (NDArray[float64]): Dielectric energies.</span>
<span class="sd">            dielectric_tensor_function (NDArray[complex128]): Dielectric tensor function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">plasma_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;plasma frequency squared.*&quot;</span>
        <span class="n">dielectric_pattern</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">r</span><span class="s2">&quot;frequency dependent\s+IMAGINARY &quot;</span>
            <span class="sa">r</span><span class="s2">&quot;DIELECTRIC FUNCTION \(independent particle, &quot;</span>
            <span class="sa">r</span><span class="s2">&quot;no local field effects\)(\sdensity-density)*$&quot;</span>
        <span class="p">)</span>
        <span class="n">row_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\s+&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">r</span><span class="s2">&quot;([\.\-\d]+)&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">plasma_frequencies</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">read_plasma</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">read_dielectric</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">energies</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;REAL&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;IMAGINARY&quot;</span><span class="p">:</span> <span class="p">[]}</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">component</span> <span class="o">=</span> <span class="s2">&quot;IMAGINARY&quot;</span>
        <span class="k">with</span> <span class="n">zopen</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;rt&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">file</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">plasma_pattern</span><span class="p">,</span> <span class="n">line</span><span class="p">):</span>
                    <span class="n">read_plasma</span> <span class="o">=</span> <span class="s2">&quot;intraband&quot;</span> <span class="k">if</span> <span class="s2">&quot;intraband&quot;</span> <span class="ow">in</span> <span class="n">line</span> <span class="k">else</span> <span class="s2">&quot;interband&quot;</span>
                <span class="k">elif</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">dielectric_pattern</span><span class="p">,</span> <span class="n">line</span><span class="p">):</span>
                    <span class="n">read_plasma</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">read_dielectric</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">row_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\s+&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">r</span><span class="s2">&quot;([\.\-\d]+)&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">7</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">read_plasma</span> <span class="ow">and</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">row_pattern</span><span class="p">,</span> <span class="n">line</span><span class="p">):</span>
                    <span class="n">plasma_frequencies</span><span class="p">[</span><span class="n">read_plasma</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()])</span>
                <span class="k">elif</span> <span class="n">read_plasma</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_parse_sci_notation</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
                    <span class="n">plasma_frequencies</span><span class="p">[</span><span class="n">read_plasma</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_parse_sci_notation</span><span class="p">(</span><span class="n">line</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">read_dielectric</span><span class="p">:</span>
                    <span class="n">tokens</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">row_pattern</span><span class="p">,</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()):</span>
                        <span class="n">tokens</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_parse_sci_notation</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()):</span>
                        <span class="n">tokens</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_parse_sci_notation</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
                    <span class="k">elif</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\s*-+\s*&quot;</span><span class="p">,</span> <span class="n">line</span><span class="p">):</span>
                        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

                    <span class="k">if</span> <span class="n">tokens</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">component</span> <span class="o">==</span> <span class="s2">&quot;IMAGINARY&quot;</span><span class="p">:</span>
                            <span class="n">energies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                        <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">zz</span><span class="p">,</span> <span class="n">xy</span><span class="p">,</span> <span class="n">yz</span><span class="p">,</span> <span class="n">xz</span> <span class="o">=</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                        <span class="n">matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="n">xx</span><span class="p">,</span> <span class="n">xy</span><span class="p">,</span> <span class="n">xz</span><span class="p">],</span> <span class="p">[</span><span class="n">xy</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">yz</span><span class="p">],</span> <span class="p">[</span><span class="n">xz</span><span class="p">,</span> <span class="n">yz</span><span class="p">,</span> <span class="n">zz</span><span class="p">]]</span>
                        <span class="n">data</span><span class="p">[</span><span class="n">component</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">component</span> <span class="o">=</span> <span class="s2">&quot;REAL&quot;</span>
                    <span class="k">elif</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="k">break</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plasma_frequencies</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">plasma_frequencies</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_energies</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">energies</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_tensor_function</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;REAL&quot;</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;IMAGINARY&quot;</span><span class="p">]</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Outcar.read_chemical_shielding">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Outcar.read_chemical_shielding">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_chemical_shielding</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse the NMR chemical shieldings data. Only the second part &quot;absolute, valence and core&quot;</span>
<span class="sd">        will be parsed. And only the three right most field (ISO_SHIELDING, SPAN, SKEW) will be retrieved.</span>

<span class="sd">        Renders accessible from self.data:</span>
<span class="sd">            chemical_shielding (dict[Literal[&quot;valence_only&quot;, &quot;valence_and_core&quot;], list[list[float]]]):</span>
<span class="sd">                Chemical shieldings in the order of atoms from the OUTCAR. Maryland notation is adopted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">header_pattern</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">r</span><span class="s2">&quot;\s+CSA tensor \(J\. Mason, Solid State Nucl\. Magn\. Reson\. 2, &quot;</span>  <span class="c1"># codespell:ignore reson</span>
            <span class="sa">r</span><span class="s2">&quot;285 \(1993\)\)\s+&quot;</span>
            <span class="sa">r</span><span class="s2">&quot;\s+-{50,}\s+&quot;</span>
            <span class="sa">r</span><span class="s2">&quot;\s+EXCLUDING G=0 CONTRIBUTION\s+INCLUDING G=0 CONTRIBUTION\s+&quot;</span>
            <span class="sa">r</span><span class="s2">&quot;\s+-{20,}\s+-{20,}\s+&quot;</span>
            <span class="sa">r</span><span class="s2">&quot;\s+ATOM\s+ISO_SHIFT\s+SPAN\s+SKEW\s+ISO_SHIFT\s+SPAN\s+SKEW\s+&quot;</span>
            <span class="sa">r</span><span class="s2">&quot;-{50,}\s*$&quot;</span>
        <span class="p">)</span>
        <span class="n">first_part_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\s+\(absolute, valence only\)\s+$&quot;</span>
        <span class="n">swallon_valence_body_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;.+?\(absolute, valence and core\)\s+$&quot;</span>
        <span class="n">row_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\d+(?:\s+[-]?\d+\.\d+)</span><span class="si">{3}</span><span class="s2">\s+&quot;</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;\s+&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">r</span><span class="s2">&quot;([-]?\d+\.\d+)&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">footer_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;-{50,}\s*$&quot;</span>
        <span class="n">h1</span> <span class="o">=</span> <span class="n">header_pattern</span> <span class="o">+</span> <span class="n">first_part_pattern</span>
        <span class="n">cs_valence_only</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_table_pattern</span><span class="p">(</span>
            <span class="n">h1</span><span class="p">,</span> <span class="n">row_pattern</span><span class="p">,</span> <span class="n">footer_pattern</span><span class="p">,</span> <span class="n">postprocess</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">last_one_only</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="n">h2</span> <span class="o">=</span> <span class="n">header_pattern</span> <span class="o">+</span> <span class="n">swallon_valence_body_pattern</span>
        <span class="n">cs_valence_and_core</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_table_pattern</span><span class="p">(</span>
            <span class="n">h2</span><span class="p">,</span> <span class="n">row_pattern</span><span class="p">,</span> <span class="n">footer_pattern</span><span class="p">,</span> <span class="n">postprocess</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">last_one_only</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="n">chemical_shielding</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;valence_only&quot;</span><span class="p">,</span> <span class="s2">&quot;valence_and_core&quot;</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;valence_only&quot;</span><span class="p">:</span> <span class="n">cs_valence_only</span><span class="p">,</span>
            <span class="s2">&quot;valence_and_core&quot;</span><span class="p">:</span> <span class="n">cs_valence_and_core</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;chemical_shielding&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">chemical_shielding</span></div>


<div class="viewcode-block" id="Outcar.read_cs_g0_contribution">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Outcar.read_cs_g0_contribution">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_cs_g0_contribution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse the G0 contribution of NMR chemical shielding.</span>

<span class="sd">        Renders accessible from self.data:</span>
<span class="sd">            cs_g0_contribution (list[list[float]]): G0 contribution matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">header_pattern</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">r</span><span class="s2">&quot;^\s+G\=0 CONTRIBUTION TO CHEMICAL SHIFT \(field along BDIR\)\s+$\n&quot;</span>
            <span class="sa">r</span><span class="s2">&quot;^\s+-{50,}$\n&quot;</span>
            <span class="sa">r</span><span class="s2">&quot;^\s+BDIR\s+X\s+Y\s+Z\s*$\n&quot;</span>
            <span class="sa">r</span><span class="s2">&quot;^\s+-{50,}\s*$\n&quot;</span>
        <span class="p">)</span>
        <span class="n">row_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;(?:\d+)\s+&quot;</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;\s+&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">r</span><span class="s2">&quot;([-]?\d+\.\d+)&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">footer_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\s+-{50,}\s*$&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_table_pattern</span><span class="p">(</span>
            <span class="n">header_pattern</span><span class="p">,</span>
            <span class="n">row_pattern</span><span class="p">,</span>
            <span class="n">footer_pattern</span><span class="p">,</span>
            <span class="n">postprocess</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
            <span class="n">last_one_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">attribute_name</span><span class="o">=</span><span class="s2">&quot;cs_g0_contribution&quot;</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Outcar.read_cs_core_contribution">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Outcar.read_cs_core_contribution">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_cs_core_contribution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse the core contribution of NMR chemical shielding.</span>

<span class="sd">        Renders accessible from self.data:</span>
<span class="sd">            cs_core_contribution (dict[str, float]): Core contribution from each element.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">header_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;^\s+Core NMR properties\s*$\n\n^\s+typ\s+El\s+Core shift \(ppm\)\s*$\n^\s+-{20,}$\n&quot;</span>
        <span class="n">row_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\d+\s+(?P&lt;element&gt;[A-Z][a-z]?\w?)\s+(?P&lt;shift&gt;[-]?\d+\.\d+)&quot;</span>
        <span class="n">footer_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\s+-{20,}\s*$&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_table_pattern</span><span class="p">(</span>
            <span class="n">header_pattern</span><span class="p">,</span>
            <span class="n">row_pattern</span><span class="p">,</span>
            <span class="n">footer_pattern</span><span class="p">,</span>
            <span class="n">postprocess</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
            <span class="n">last_one_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">attribute_name</span><span class="o">=</span><span class="s2">&quot;cs_core_contribution&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">core_contrib</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;element&quot;</span><span class="p">]:</span> <span class="nb">float</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;shift&quot;</span><span class="p">])</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;cs_core_contribution&quot;</span><span class="p">]}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;cs_core_contribution&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">core_contrib</span></div>


<div class="viewcode-block" id="Outcar.read_cs_raw_symmetrized_tensors">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Outcar.read_cs_raw_symmetrized_tensors">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_cs_raw_symmetrized_tensors</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse the matrix form of NMR tensor before corrected to table.</span>

<span class="sd">        Renders accessible from self.data:</span>
<span class="sd">            unsym_cs_tensor (list[list[list[float]]]): Unsymmetrized tensors in the order of atoms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">header_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\s+-{50,}\s+\s+Absolute Chemical Shift tensors\s+\s+-{50,}$&quot;</span>
        <span class="n">first_part_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\s+UNSYMMETRIZED TENSORS\s+$&quot;</span>
        <span class="n">row_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\s+&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">r</span><span class="s2">&quot;([-]?\d+\.\d+)&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">unsym_footer_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;^\s+SYMMETRIZED TENSORS\s+$&quot;</span>

        <span class="k">with</span> <span class="n">zopen</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;rt&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="n">unsym_table_pattern_text</span> <span class="o">=</span> <span class="n">header_pattern</span> <span class="o">+</span> <span class="n">first_part_pattern</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;(?P&lt;table_body&gt;.+)&quot;</span> <span class="o">+</span> <span class="n">unsym_footer_pattern</span>
        <span class="n">table_pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">unsym_table_pattern_text</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>
        <span class="n">row_pat</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">row_pattern</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">match</span> <span class="o">:=</span> <span class="n">table_pattern</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
            <span class="n">table_text</span> <span class="o">=</span> <span class="n">match</span><span class="p">[</span><span class="s2">&quot;table_body&quot;</span><span class="p">]</span>
            <span class="n">micro_header_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;ion\s+\d+&quot;</span>
            <span class="n">micro_table_pattern_text</span> <span class="o">=</span> <span class="n">micro_header_pattern</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;\s*^(?P&lt;table_body&gt;(?:\s*&quot;</span> <span class="o">+</span> <span class="n">row_pattern</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;)+)\s+&quot;</span>
            <span class="n">micro_table_pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">micro_table_pattern_text</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>
            <span class="n">unsym_tensors</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">mt</span> <span class="ow">in</span> <span class="n">micro_table_pattern</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">table_text</span><span class="p">):</span>
                <span class="n">table_body_text</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;table_body&quot;</span><span class="p">)</span>
                <span class="n">tensor_matrix</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">table_body_text</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">):</span>
                    <span class="n">ml</span> <span class="o">=</span> <span class="n">row_pat</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">ml</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;failure to find pattern, </span><span class="si">{</span><span class="n">ml</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">processed_line</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ml</span><span class="o">.</span><span class="n">groups</span><span class="p">()]</span>
                    <span class="n">tensor_matrix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">processed_line</span><span class="p">)</span>
                <span class="n">unsym_tensors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tensor_matrix</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;unsym_cs_tensor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unsym_tensors</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;NMR UNSYMMETRIZED TENSORS is not found&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Outcar.read_nmr_efg_tensor">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Outcar.read_nmr_efg_tensor">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_nmr_efg_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parses the NMR Electric Field Gradient Raw Tensors.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[NDArray[float64]]: Electric Field Gradient Tensors in the order of atoms.</span>

<span class="sd">        Renders accessible from self.data:</span>
<span class="sd">            unsym_efg_tensor (list[NDArray[float64]]): Electric Field Gradient</span>
<span class="sd">                Tensors in the order of atoms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">header_pattern</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">r</span><span class="s2">&quot;Electric field gradients \(V/A\^2\)\n-*\n ion\s+V_xx\s+V_yy\s+V_zz\s+V_xy\s+V_xz\s+V_yz\n-*\n&quot;</span>
        <span class="p">)</span>

        <span class="n">row_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\d+\s+([-\d\.]+)\s+([-\d\.]+)\s+([-\d\.]+)\s+([-\d\.]+)\s+([-\d\.]+)\s+([-\d\.]+)&quot;</span>
        <span class="n">footer_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;-*\n&quot;</span>

        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_table_pattern</span><span class="p">(</span><span class="n">header_pattern</span><span class="p">,</span> <span class="n">row_pattern</span><span class="p">,</span> <span class="n">footer_pattern</span><span class="p">,</span> <span class="n">postprocess</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">tensors</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="n">make_symmetric_matrix_from_upper_tri</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;unsym_efg_tensor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensors</span>
        <span class="k">return</span> <span class="n">tensors</span></div>


<div class="viewcode-block" id="Outcar.read_nmr_efg">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Outcar.read_nmr_efg">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_nmr_efg</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse the NMR Electric Field Gradient interpreted values.</span>

<span class="sd">        Renders accessible from self.data:</span>
<span class="sd">            efg (list[dict[Literal[&quot;cq&quot;, &quot;eta&quot;, &quot;nuclear_quadrupole_moment&quot;], float]]):</span>
<span class="sd">                Electric Field Gradient tensors in the order of atoms.</span>
<span class="sd">                Each dict key/value pair corresponds to a component of the tensors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">header_pattern</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">r</span><span class="s2">&quot;^\s+NMR quadrupolar parameters\s+$\n&quot;</span>
            <span class="sa">r</span><span class="s2">&quot;^\s+Cq : quadrupolar parameter\s+Cq=e[*]Q[*]V_zz/h$\n&quot;</span>
            <span class="sa">r</span><span class="s2">&quot;^\s+eta: asymmetry parameters\s+\(V_yy - V_xx\)/ V_zz$\n&quot;</span>
            <span class="sa">r</span><span class="s2">&quot;^\s+Q  : nuclear electric quadrupole moment in mb \(millibarn\)$\n&quot;</span>
            <span class="sa">r</span><span class="s2">&quot;^-{50,}$\n&quot;</span>
            <span class="sa">r</span><span class="s2">&quot;^\s+ion\s+Cq\(MHz\)\s+eta\s+Q \(mb\)\s+$\n&quot;</span>
            <span class="sa">r</span><span class="s2">&quot;^-{50,}\s*$\n&quot;</span>
        <span class="p">)</span>
        <span class="n">row_pattern</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">r</span><span class="s2">&quot;\d+\s+(?P&lt;cq&gt;[-]?\d+\.\d+)\s+(?P&lt;eta&gt;[-]?\d+\.\d+)\s+(?P&lt;nuclear_quadrupole_moment&gt;[-]?\d+\.\d+)&quot;</span>
        <span class="p">)</span>
        <span class="n">footer_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;-{50,}\s*$&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_table_pattern</span><span class="p">(</span>
            <span class="n">header_pattern</span><span class="p">,</span>
            <span class="n">row_pattern</span><span class="p">,</span>
            <span class="n">footer_pattern</span><span class="p">,</span>
            <span class="n">postprocess</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
            <span class="n">last_one_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">attribute_name</span><span class="o">=</span><span class="s2">&quot;efg&quot;</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Outcar.read_elastic_tensor">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Outcar.read_elastic_tensor">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_elastic_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parse the elastic tensor data.</span>

<span class="sd">        Renders accessible from self.data:</span>
<span class="sd">            elastic_tensor[list[list[float]]]: 6x6 array corresponding to the elastic tensor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">header_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;TOTAL ELASTIC MODULI \(kBar\)\s+Direction\s+([X-Z][X-Z]\s+)+\-+&quot;</span>
        <span class="n">row_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;[X-Z][X-Z]\s+&quot;</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;\s+&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">r</span><span class="s2">&quot;(\-*[\.\d]+)&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">6</span><span class="p">)</span>
        <span class="n">footer_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\-+&quot;</span>
        <span class="n">et_table</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_table_pattern</span><span class="p">(</span>
            <span class="n">header_pattern</span><span class="p">,</span> <span class="n">row_pattern</span><span class="p">,</span> <span class="n">footer_pattern</span><span class="p">,</span> <span class="n">postprocess</span><span class="o">=</span><span class="nb">float</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;elastic_tensor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">et_table</span></div>


<div class="viewcode-block" id="Outcar.read_piezo_tensor">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Outcar.read_piezo_tensor">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_piezo_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse the piezo tensor data.</span>

<span class="sd">        Renders accessible from self.data:</span>
<span class="sd">            piezo_tensor (list[list[float]]): The piezo tensor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">header_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;PIEZOELECTRIC TENSOR  for field in x, y, z\s+\(C/m\^2\)\s+([X-Z][X-Z]\s+)+\-+&quot;</span>
        <span class="n">row_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;[x-z]\s+&quot;</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;\s+&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">r</span><span class="s2">&quot;(\-*[\.\d]+)&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">6</span><span class="p">)</span>
        <span class="n">footer_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;BORN EFFECTIVE&quot;</span>
        <span class="n">piezo_tensor</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_table_pattern</span><span class="p">(</span>
            <span class="n">header_pattern</span><span class="p">,</span> <span class="n">row_pattern</span><span class="p">,</span> <span class="n">footer_pattern</span><span class="p">,</span> <span class="n">postprocess</span><span class="o">=</span><span class="nb">float</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;piezo_tensor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">piezo_tensor</span></div>


<div class="viewcode-block" id="Outcar.read_onsite_density_matrices">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Outcar.read_onsite_density_matrices">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_onsite_density_matrices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse the onsite density matrices.</span>

<span class="sd">        Renders accessible from self.data:</span>
<span class="sd">            onsite_density_matrices (list[dict[Spin, list[list[float]]]]):</span>
<span class="sd">                Onsite density matrices with index corresponding to atom index in Structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Matrix size will vary depending on if d or f orbitals are present.</span>
        <span class="c1"># Therefore regex assumes f, but filter out None values if d.</span>
        <span class="n">header_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;spin component  1\n&quot;</span>
        <span class="n">row_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;[^\S\r\n]*(?:(-?[\d.]+))&quot;</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;(?:[^\S\r\n]*(-?[\d.]+)[^\S\r\n]*)?&quot;</span> <span class="o">*</span> <span class="mi">6</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;.*?&quot;</span>
        <span class="n">footer_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\nspin component  2&quot;</span>
        <span class="n">spin1_component</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_table_pattern</span><span class="p">(</span>
            <span class="n">header_pattern</span><span class="p">,</span>
            <span class="n">row_pattern</span><span class="p">,</span>
            <span class="n">footer_pattern</span><span class="p">,</span>
            <span class="n">postprocess</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">last_one_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Filter out None</span>
        <span class="n">spin1_component</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">row</span> <span class="k">if</span> <span class="n">e</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">matrix</span><span class="p">]</span> <span class="k">for</span> <span class="n">matrix</span> <span class="ow">in</span> <span class="n">spin1_component</span><span class="p">]</span>

        <span class="c1"># And repeat for Spin.down</span>
        <span class="n">header_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;spin component  2\n&quot;</span>
        <span class="n">row_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;[^\S\r\n]*(?:([\d.-]+))&quot;</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;(?:[^\S\r\n]*(-?[\d.]+)[^\S\r\n]*)?&quot;</span> <span class="o">*</span> <span class="mi">6</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;.*?&quot;</span>
        <span class="n">footer_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\n occupancies and eigenvectors&quot;</span>
        <span class="n">spin2_component</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_table_pattern</span><span class="p">(</span>
            <span class="n">header_pattern</span><span class="p">,</span>
            <span class="n">row_pattern</span><span class="p">,</span>
            <span class="n">footer_pattern</span><span class="p">,</span>
            <span class="n">postprocess</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">last_one_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">spin2_component</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">row</span> <span class="k">if</span> <span class="n">e</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">matrix</span><span class="p">]</span> <span class="k">for</span> <span class="n">matrix</span> <span class="ow">in</span> <span class="n">spin2_component</span><span class="p">]</span>

        <span class="n">onsite_density_matrices</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="n">Spin</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]]</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">{</span><span class="n">Spin</span><span class="o">.</span><span class="n">up</span><span class="p">:</span> <span class="n">spin1_component</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">Spin</span><span class="o">.</span><span class="n">down</span><span class="p">:</span> <span class="n">spin2_component</span><span class="p">[</span><span class="n">idx</span><span class="p">]}</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spin1_component</span><span class="p">))</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;onsite_density_matrices&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">onsite_density_matrices</span></div>


<div class="viewcode-block" id="Outcar.read_corrections">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Outcar.read_corrections">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_corrections</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">reverse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">terminate_on_match</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read the dipol qudropol correction.</span>

<span class="sd">        Args:</span>
<span class="sd">            reverse (bool): Whether to start from end of OUTCAR. Defaults to True.</span>
<span class="sd">            terminate_on_match (bool): Whether to terminate once match is found. Defaults to True.</span>

<span class="sd">        Renders accessible from self.data:</span>
<span class="sd">            dipol_quadrupol_correction (float): Dipol qudropol correction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">patterns</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;dipol_quadrupol_correction&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;dipol\+quadrupol energy correction\s+([\d\-\.]+)&quot;</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_pattern</span><span class="p">(</span>
            <span class="n">patterns</span><span class="p">,</span>
            <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">,</span>
            <span class="n">terminate_on_match</span><span class="o">=</span><span class="n">terminate_on_match</span><span class="p">,</span>
            <span class="n">postprocess</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">dipol_quadrupol_correction</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;dipol_quadrupol_correction&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;dipol_quadrupol_correction&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dipol_quadrupol_correction</span></div>


<div class="viewcode-block" id="Outcar.read_neb">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Outcar.read_neb">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_neb</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">reverse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">terminate_on_match</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read NEB data. This only works with OUTCARs from both normal</span>
<span class="sd">        VASP NEB calculations or from the CI NEB method implemented by</span>
<span class="sd">        Henkelman et al.</span>

<span class="sd">        Args:</span>
<span class="sd">            reverse (bool): Read files in reverse. Defaults to false. Useful for</span>
<span class="sd">                large files, especially when used with terminate_on_match.</span>
<span class="sd">                Defaults to True here since we usually want only the final value.</span>
<span class="sd">            terminate_on_match (bool): Whether to terminate when there is at</span>
<span class="sd">                least one match in each key in pattern. Defaults to True here</span>
<span class="sd">                since we usually want only the final value.</span>

<span class="sd">        Renders accessible from self.data:</span>
<span class="sd">            energy (float): Final energy.</span>
<span class="sd">            tangent_force (float): Final tangent force.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">patterns</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;energy&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;energy\(sigma-&gt;0\)\s+=\s+([\d\-\.]+)&quot;</span><span class="p">,</span>
            <span class="s2">&quot;tangent_force&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;(NEB: projections on to tangent \(spring, REAL\)\s+\S+|tangential force \(eV/A\))\s+&quot;</span>
            <span class="sa">r</span><span class="s2">&quot;([\d\-\.]+)&quot;</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_pattern</span><span class="p">(</span>
            <span class="n">patterns</span><span class="p">,</span>
            <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">,</span>
            <span class="n">terminate_on_match</span><span class="o">=</span><span class="n">terminate_on_match</span><span class="p">,</span>
            <span class="n">postprocess</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;energy&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;energy&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;tangent_force&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;tangent_force&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;tangent_force&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span></div>


<div class="viewcode-block" id="Outcar.read_igpar">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Outcar.read_igpar">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_igpar</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read IGPAR.</span>

<span class="sd">        See VASP sections &quot;LBERRY, IGPAR, NPPSTR, DIPOL&quot; for info on</span>
<span class="sd">        what these are.</span>

<span class="sd">        Renders accessible as attributes:</span>
<span class="sd">            er_ev (dict[Spin, NDArray[float]]): e&lt;r&gt;_ev.</span>
<span class="sd">            er_bp (dict[Spin, NDArray[float]]): e&lt;r&gt;_bp.</span>
<span class="sd">            er_ev_tot (NDArray[float]): spin up + spin down summed.</span>
<span class="sd">            er_bp_tot (NDArray[float]): spin up + spin down summed.</span>
<span class="sd">            p_elec (int): spin up + spin down summed.</span>
<span class="sd">            p_ion (int): spin up + spin down summed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Variables to be filled</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">er_ev</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Spin</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># array(3*float)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">er_bp</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Spin</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># array(3*float)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">er_ev_tot</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># array(3*float)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">er_bp_tot</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># array(3*float)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_elec</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_ion</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">search</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Non-spin cases</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">er_ev</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">er_ev</span><span class="p">[</span><span class="n">Spin</span><span class="o">.</span><span class="n">up</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">groups</span><span class="p">()[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]))</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="n">results</span><span class="o">.</span><span class="n">er_ev</span><span class="p">[</span><span class="n">Spin</span><span class="o">.</span><span class="n">down</span><span class="p">]</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">er_ev</span><span class="p">[</span><span class="n">Spin</span><span class="o">.</span><span class="n">up</span><span class="p">]</span>
                <span class="n">results</span><span class="o">.</span><span class="n">context</span> <span class="o">=</span> <span class="mi">2</span>

            <span class="n">er_ev_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;^ *e&lt;r&gt;_ev=\( *([-0-9.Ee+]*) *([-0-9.Ee+]*) *([-0-9.Ee+]*) *\)&quot;</span>
            <span class="n">search</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">er_ev_pattern</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">er_ev</span><span class="p">])</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">er_bp</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">er_bp</span><span class="p">[</span><span class="n">Spin</span><span class="o">.</span><span class="n">up</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="n">results</span><span class="o">.</span><span class="n">er_bp</span><span class="p">[</span><span class="n">Spin</span><span class="o">.</span><span class="n">down</span><span class="p">]</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">er_bp</span><span class="p">[</span><span class="n">Spin</span><span class="o">.</span><span class="n">up</span><span class="p">]</span>

            <span class="n">er_bp_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;^ *e&lt;r&gt;_bp=\( *([-0-9.Ee+]*) *([-0-9.Ee+]*) *([-0-9.Ee+]*) *\)&quot;</span>
            <span class="n">search</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">er_bp_pattern</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">results</span><span class="p">,</span> <span class="n">_line</span><span class="p">:</span> <span class="n">results</span><span class="o">.</span><span class="n">context</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="n">er_bp</span><span class="p">])</span>

            <span class="c1"># Spin cases</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">er_ev_up</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">er_ev</span><span class="p">[</span><span class="n">Spin</span><span class="o">.</span><span class="n">up</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>
                <span class="n">results</span><span class="o">.</span><span class="n">context</span> <span class="o">=</span> <span class="n">Spin</span><span class="o">.</span><span class="n">up</span>

            <span class="n">spin1_ev_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;^.*Spin component 1 *e&lt;r&gt;_ev=\( *([-0-9.Ee+]*) *([-0-9.Ee+]*) *([-0-9.Ee+]*) *\)&quot;</span>
            <span class="n">search</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">spin1_ev_pattern</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">er_ev_up</span><span class="p">])</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">er_bp_up</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">er_bp</span><span class="p">[</span><span class="n">Spin</span><span class="o">.</span><span class="n">up</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">3</span><span class="p">])])</span>

            <span class="n">spin_bp_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;^ *e&lt;r&gt;_bp=\( *([-0-9.Ee+]*) *([-0-9.Ee+]*) *([-0-9.Ee+]*) *\)&quot;</span>
            <span class="n">search</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">spin_bp_pattern</span><span class="p">,</span>
                    <span class="k">lambda</span> <span class="n">results</span><span class="p">,</span> <span class="n">_line</span><span class="p">:</span> <span class="n">results</span><span class="o">.</span><span class="n">context</span> <span class="o">==</span> <span class="n">Spin</span><span class="o">.</span><span class="n">up</span><span class="p">,</span>
                    <span class="n">er_bp_up</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="p">)</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">er_ev_dn</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">er_ev</span><span class="p">[</span><span class="n">Spin</span><span class="o">.</span><span class="n">down</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">3</span><span class="p">])])</span>
                <span class="n">results</span><span class="o">.</span><span class="n">context</span> <span class="o">=</span> <span class="n">Spin</span><span class="o">.</span><span class="n">down</span>

            <span class="n">spin2_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;^.*Spin component 2 *e&lt;r&gt;_ev=\( *([-0-9.Ee+]*) *([-0-9.Ee+]*) *([-0-9.Ee+]*) *\)&quot;</span>
            <span class="n">search</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">spin2_pattern</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">er_ev_dn</span><span class="p">])</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">er_bp_dn</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">er_bp</span><span class="p">[</span><span class="n">Spin</span><span class="o">.</span><span class="n">down</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>

            <span class="n">e_r_bp_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;^ *e&lt;r&gt;_bp=\( *([-0-9.Ee+]*) *([-0-9.Ee+]*) *([-0-9.Ee+]*) *\)&quot;</span>
            <span class="n">search</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">e_r_bp_pattern</span><span class="p">,</span>
                    <span class="k">lambda</span> <span class="n">results</span><span class="p">,</span> <span class="n">_line</span><span class="p">:</span> <span class="n">results</span><span class="o">.</span><span class="n">context</span> <span class="o">==</span> <span class="n">Spin</span><span class="o">.</span><span class="n">down</span><span class="p">,</span>
                    <span class="n">er_bp_dn</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="p">)</span>

            <span class="c1"># Always present spin/non-spin</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">p_elc</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">p_elc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>

            <span class="n">elec_dipole_moment_pattern</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">r</span><span class="s2">&quot;^.*Total electronic dipole moment: *p\[elc\]=\( *([-0-9.Ee+]*) *([-0-9.Ee+]*) *([-0-9.Ee+]*) *\)&quot;</span>
            <span class="p">)</span>
            <span class="n">search</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">elec_dipole_moment_pattern</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">p_elc</span><span class="p">])</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">p_ion</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">p_ion</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>

            <span class="n">ionic_dipole_moment_pattern</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">r</span><span class="s2">&quot;^.*ionic dipole moment: *p\[ion\]=\( *([-0-9.Ee+]*) *([-0-9.Ee+]*) *([-0-9.Ee+]*) *\)&quot;</span>
            <span class="p">)</span>
            <span class="n">search</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">ionic_dipole_moment_pattern</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">p_ion</span><span class="p">])</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">context</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">er_ev</span> <span class="o">=</span> <span class="p">{</span><span class="n">Spin</span><span class="o">.</span><span class="n">up</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="n">Spin</span><span class="o">.</span><span class="n">down</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">er_bp</span> <span class="o">=</span> <span class="p">{</span><span class="n">Spin</span><span class="o">.</span><span class="n">up</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="n">Spin</span><span class="o">.</span><span class="n">down</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>

            <span class="n">micro_pyawk</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">search</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">er_ev</span><span class="p">[</span><span class="n">Spin</span><span class="o">.</span><span class="n">up</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">er_ev</span><span class="p">[</span><span class="n">Spin</span><span class="o">.</span><span class="n">down</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">er_ev_tot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">er_ev</span><span class="p">[</span><span class="n">Spin</span><span class="o">.</span><span class="n">up</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">er_ev</span><span class="p">[</span><span class="n">Spin</span><span class="o">.</span><span class="n">down</span><span class="p">]</span>  <span class="c1"># type: ignore[operator]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">er_bp</span><span class="p">[</span><span class="n">Spin</span><span class="o">.</span><span class="n">up</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">er_bp</span><span class="p">[</span><span class="n">Spin</span><span class="o">.</span><span class="n">down</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">er_bp_tot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">er_bp</span><span class="p">[</span><span class="n">Spin</span><span class="o">.</span><span class="n">up</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">er_bp</span><span class="p">[</span><span class="n">Spin</span><span class="o">.</span><span class="n">down</span><span class="p">]</span>  <span class="c1"># type: ignore[operator]</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;IGPAR OUTCAR could not be parsed.&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">exc</span></div>


<div class="viewcode-block" id="Outcar.read_internal_strain_tensor">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Outcar.read_internal_strain_tensor">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_internal_strain_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read the internal strain tensor.</span>

<span class="sd">        Renders accessible as attributes:</span>
<span class="sd">            internal_strain_tensor (list[NDArray[float64]]): Voigt notation tensors for each site.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">search</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">internal_strain_start</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">match</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">results</span><span class="o">.</span><span class="n">internal_strain_ion</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">results</span><span class="o">.</span><span class="n">internal_strain_tensor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">)))</span>

        <span class="n">search</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="sa">r</span><span class="s2">&quot;INTERNAL STRAIN TENSOR FOR ION\s+(\d+)\s+for displacements in x,y,z  \(eV/Angst\):&quot;</span><span class="p">,</span>
                <span class="kc">None</span><span class="p">,</span>
                <span class="n">internal_strain_start</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">internal_strain_data</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">match</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">match</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;x&quot;</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">match</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">match</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;z&quot;</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Couldn&#39;t parse row index from symbol for internal strain tensor: </span><span class="si">{</span><span class="n">match</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">results</span><span class="o">.</span><span class="n">internal_strain_tensor</span><span class="p">[</span><span class="n">results</span><span class="o">.</span><span class="n">internal_strain_ion</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">)]</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">results</span><span class="o">.</span><span class="n">internal_strain_ion</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">search</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="sa">r</span><span class="s2">&quot;^\s+([x,y,z])\s+&quot;</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;([-]?\d+\.\d+)\s+&quot;</span> <span class="o">*</span> <span class="mi">6</span><span class="p">,</span>
                <span class="k">lambda</span> <span class="n">results</span><span class="p">,</span> <span class="n">_line</span><span class="p">:</span> <span class="n">results</span><span class="o">.</span><span class="n">internal_strain_ion</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">internal_strain_data</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">internal_strain_ion</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">internal_strain_tensor</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">micro_pyawk</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">search</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="Outcar.read_lepsilon">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Outcar.read_lepsilon">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_lepsilon</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read a LEPSILON run.</span>

<span class="sd">        Renders accessible as attributes:</span>
<span class="sd">            dielectric_tensor (list[list[float]]): Dielectric tensor.</span>
<span class="sd">            piezo_tensor (list[list[float]]): The piezo tensor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">search</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">dielectric_section_start</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">dielectric_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

            <span class="n">search</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="sa">r</span><span class="s2">&quot;MACROSCOPIC STATIC DIELECTRIC TENSOR \(&quot;</span><span class="p">,</span>
                    <span class="kc">None</span><span class="p">,</span>
                    <span class="n">dielectric_section_start</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="p">)</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">dielectric_section_start2</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">dielectric_index</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">search</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="sa">r</span><span class="s2">&quot;-------------------------------------&quot;</span><span class="p">,</span>
                    <span class="k">lambda</span> <span class="n">results</span><span class="p">,</span> <span class="n">_line</span><span class="p">:</span> <span class="n">results</span><span class="o">.</span><span class="n">dielectric_index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">dielectric_section_start2</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="p">)</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">dielectric_data</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">dielectric_tensor</span><span class="p">[</span><span class="n">results</span><span class="o">.</span><span class="n">dielectric_index</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>
                <span class="p">)</span>
                <span class="n">results</span><span class="o">.</span><span class="n">dielectric_index</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">search</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="sa">r</span><span class="s2">&quot;^ *([-0-9.Ee+]+) +([-0-9.Ee+]+) +([-0-9.Ee+]+) *$&quot;</span><span class="p">,</span>
                    <span class="k">lambda</span> <span class="n">results</span><span class="p">,</span> <span class="n">_line</span><span class="p">:</span> <span class="p">(</span>
                        <span class="n">results</span><span class="o">.</span><span class="n">dielectric_index</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">results</span><span class="o">.</span><span class="n">dielectric_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
                    <span class="p">),</span>
                    <span class="n">dielectric_data</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="p">)</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">dielectric_section_stop</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">dielectric_index</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">search</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="sa">r</span><span class="s2">&quot;-------------------------------------&quot;</span><span class="p">,</span>
                    <span class="k">lambda</span> <span class="n">results</span><span class="p">,</span> <span class="n">_line</span><span class="p">:</span> <span class="p">(</span>
                        <span class="n">results</span><span class="o">.</span><span class="n">dielectric_index</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">results</span><span class="o">.</span><span class="n">dielectric_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
                    <span class="p">),</span>
                    <span class="n">dielectric_section_stop</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_index</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_tensor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">piezo_section_start</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">_match</span><span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">piezo_index</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">search</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="sa">r</span><span class="s2">&quot;PIEZOELECTRIC TENSOR  for field in x, y, z        \(C/m\^2\)&quot;</span><span class="p">,</span>
                    <span class="kc">None</span><span class="p">,</span>
                    <span class="n">piezo_section_start</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="p">)</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">piezo_data</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">piezo_tensor</span><span class="p">[</span><span class="n">results</span><span class="o">.</span><span class="n">piezo_index</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">)])</span>
                <span class="n">results</span><span class="o">.</span><span class="n">piezo_index</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">search</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="sa">r</span><span class="s2">&quot;^ *[xyz] +([-0-9.Ee+]+) +([-0-9.Ee+]+)&quot;</span>
                    <span class="sa">r</span><span class="s2">&quot; +([-0-9.Ee+]+) *([-0-9.Ee+]+) +([-0-9.Ee+]+) +([-0-9.Ee+]+)*$&quot;</span><span class="p">,</span>
                    <span class="k">lambda</span> <span class="n">results</span><span class="p">,</span> <span class="n">_line</span><span class="p">:</span> <span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">piezo_index</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">results</span><span class="o">.</span><span class="n">piezo_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">),</span>
                    <span class="n">piezo_data</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="p">)</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">piezo_section_stop</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">_match</span><span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">piezo_index</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">search</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="sa">r</span><span class="s2">&quot;-------------------------------------&quot;</span><span class="p">,</span>
                    <span class="k">lambda</span> <span class="n">results</span><span class="p">,</span> <span class="n">_line</span><span class="p">:</span> <span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">piezo_index</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">results</span><span class="o">.</span><span class="n">piezo_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">),</span>
                    <span class="n">piezo_section_stop</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">piezo_index</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">piezo_tensor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">born_section_start</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">_match</span><span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">born_ion</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

            <span class="n">search</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="sa">r</span><span class="s2">&quot;BORN EFFECTIVE CHARGES &quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">born_section_start</span><span class="p">])</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">born_ion</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">born_ion</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">results</span><span class="o">.</span><span class="n">born</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span>

            <span class="n">search</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="sa">r</span><span class="s2">&quot;ion +([0-9]+)&quot;</span><span class="p">,</span>
                    <span class="k">lambda</span> <span class="n">results</span><span class="p">,</span> <span class="n">_line</span><span class="p">:</span> <span class="n">results</span><span class="o">.</span><span class="n">born_ion</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">born_ion</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="p">)</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">born_data</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">born</span><span class="p">[</span><span class="n">results</span><span class="o">.</span><span class="n">born_ion</span><span class="p">][</span><span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)])</span>

            <span class="n">search</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="sa">r</span><span class="s2">&quot;^ *([1-3]+) +([-0-9.Ee+]+) +([-0-9.Ee+]+) +([-0-9.Ee+]+)$&quot;</span><span class="p">,</span>
                    <span class="k">lambda</span> <span class="n">results</span><span class="p">,</span> <span class="n">_line</span><span class="p">:</span> <span class="p">(</span>
                        <span class="n">results</span><span class="o">.</span><span class="n">born_ion</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">results</span><span class="o">.</span><span class="n">born_ion</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">results</span><span class="o">.</span><span class="n">born_ion</span>
                    <span class="p">),</span>
                    <span class="n">born_data</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="p">)</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">born_section_stop</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">_match</span><span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">born_ion</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">search</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="sa">r</span><span class="s2">&quot;-------------------------------------&quot;</span><span class="p">,</span>
                    <span class="k">lambda</span> <span class="n">results</span><span class="p">,</span> <span class="n">_line</span><span class="p">:</span> <span class="p">(</span>
                        <span class="n">results</span><span class="o">.</span><span class="n">born_ion</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">results</span><span class="o">.</span><span class="n">born_ion</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">results</span><span class="o">.</span><span class="n">born_ion</span>
                    <span class="p">),</span>
                    <span class="n">born_section_stop</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">born_ion</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">born</span><span class="p">:</span> <span class="nb">list</span> <span class="o">|</span> <span class="n">NDArray</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">micro_pyawk</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">search</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">born</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">born</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_tensor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_tensor</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">piezo_tensor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">piezo_tensor</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;LEPSILON OUTCAR could not be parsed.&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">exc</span></div>


<div class="viewcode-block" id="Outcar.read_lepsilon_ionic">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Outcar.read_lepsilon_ionic">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_lepsilon_ionic</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read the ionic component of a LEPSILON run.</span>

<span class="sd">        Renders accessible as attributes:</span>
<span class="sd">            dielectric_ionic_tensor (list[list[float]]): Ionic dielectric tensor.</span>
<span class="sd">            piezo_ionic_tensor (list[list[float]]): Ionic piezoelectric tensor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">search</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">dielectric_section_start</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">_match</span><span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">dielectric_ionic_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

            <span class="n">search</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="sa">r</span><span class="s2">&quot;MACROSCOPIC STATIC DIELECTRIC TENSOR IONIC&quot;</span><span class="p">,</span>
                    <span class="kc">None</span><span class="p">,</span>
                    <span class="n">dielectric_section_start</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="p">)</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">dielectric_section_start2</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">_match</span><span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">dielectric_ionic_index</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">search</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="sa">r</span><span class="s2">&quot;-------------------------------------&quot;</span><span class="p">,</span>
                    <span class="k">lambda</span> <span class="n">results</span><span class="p">,</span> <span class="n">_line</span><span class="p">:</span> <span class="p">(</span>
                        <span class="n">results</span><span class="o">.</span><span class="n">dielectric_ionic_index</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
                        <span class="k">if</span> <span class="n">results</span><span class="o">.</span><span class="n">dielectric_ionic_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                        <span class="k">else</span> <span class="n">results</span><span class="o">.</span><span class="n">dielectric_ionic_index</span>
                    <span class="p">),</span>
                    <span class="n">dielectric_section_start2</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="p">)</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">dielectric_data</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">dielectric_ionic_tensor</span><span class="p">[</span><span class="n">results</span><span class="o">.</span><span class="n">dielectric_ionic_index</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>
                <span class="p">)</span>
                <span class="n">results</span><span class="o">.</span><span class="n">dielectric_ionic_index</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">search</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="sa">r</span><span class="s2">&quot;^ *([-0-9.Ee+]+) +([-0-9.Ee+]+) +([-0-9.Ee+]+) *$&quot;</span><span class="p">,</span>
                    <span class="k">lambda</span> <span class="n">results</span><span class="p">,</span> <span class="n">_line</span><span class="p">:</span> <span class="p">(</span>
                        <span class="n">results</span><span class="o">.</span><span class="n">dielectric_ionic_index</span> <span class="o">&gt;=</span> <span class="mi">0</span>
                        <span class="k">if</span> <span class="n">results</span><span class="o">.</span><span class="n">dielectric_ionic_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                        <span class="k">else</span> <span class="n">results</span><span class="o">.</span><span class="n">dielectric_ionic_index</span>
                    <span class="p">),</span>
                    <span class="n">dielectric_data</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="p">)</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">dielectric_section_stop</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">_match</span><span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">dielectric_ionic_index</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">search</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="sa">r</span><span class="s2">&quot;-------------------------------------&quot;</span><span class="p">,</span>
                    <span class="k">lambda</span> <span class="n">results</span><span class="p">,</span> <span class="n">_line</span><span class="p">:</span> <span class="p">(</span>
                        <span class="n">results</span><span class="o">.</span><span class="n">dielectric_ionic_index</span> <span class="o">&gt;=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="n">results</span><span class="o">.</span><span class="n">dielectric_ionic_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                        <span class="k">else</span> <span class="n">results</span><span class="o">.</span><span class="n">dielectric_ionic_index</span>
                    <span class="p">),</span>
                    <span class="n">dielectric_section_stop</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_ionic_index</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_ionic_tensor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">piezo_section_start</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">_match</span><span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">piezo_ionic_index</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">search</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="s2">&quot;PIEZOELECTRIC TENSOR IONIC CONTR  for field in x, y, z        &quot;</span><span class="p">,</span>
                    <span class="kc">None</span><span class="p">,</span>
                    <span class="n">piezo_section_start</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="p">)</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">piezo_data</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">piezo_ionic_tensor</span><span class="p">[</span><span class="n">results</span><span class="o">.</span><span class="n">piezo_ionic_index</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">)]</span>
                <span class="p">)</span>
                <span class="n">results</span><span class="o">.</span><span class="n">piezo_ionic_index</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">search</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="sa">r</span><span class="s2">&quot;^ *[xyz] +([-0-9.Ee+]+) +([-0-9.Ee+]+)&quot;</span>
                    <span class="sa">r</span><span class="s2">&quot; +([-0-9.Ee+]+) *([-0-9.Ee+]+) +([-0-9.Ee+]+) +([-0-9.Ee+]+)*$&quot;</span><span class="p">,</span>
                    <span class="k">lambda</span> <span class="n">results</span><span class="p">,</span> <span class="n">_line</span><span class="p">:</span> <span class="p">(</span>
                        <span class="n">results</span><span class="o">.</span><span class="n">piezo_ionic_index</span> <span class="o">&gt;=</span> <span class="mi">0</span>
                        <span class="k">if</span> <span class="n">results</span><span class="o">.</span><span class="n">piezo_ionic_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                        <span class="k">else</span> <span class="n">results</span><span class="o">.</span><span class="n">piezo_ionic_index</span>
                    <span class="p">),</span>
                    <span class="n">piezo_data</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="p">)</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">piezo_section_stop</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">_match</span><span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">piezo_ionic_index</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">search</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="s2">&quot;-------------------------------------&quot;</span><span class="p">,</span>
                    <span class="k">lambda</span> <span class="n">results</span><span class="p">,</span> <span class="n">_line</span><span class="p">:</span> <span class="p">(</span>
                        <span class="n">results</span><span class="o">.</span><span class="n">piezo_ionic_index</span> <span class="o">&gt;=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="n">results</span><span class="o">.</span><span class="n">piezo_ionic_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                        <span class="k">else</span> <span class="n">results</span><span class="o">.</span><span class="n">piezo_ionic_index</span>
                    <span class="p">),</span>
                    <span class="n">piezo_section_stop</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">piezo_ionic_index</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">piezo_ionic_tensor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

            <span class="n">micro_pyawk</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">search</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_ionic_tensor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dielectric_ionic_tensor</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">piezo_ionic_tensor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">piezo_ionic_tensor</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;ionic part of LEPSILON OUTCAR could not be parsed.&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">exc</span></div>


<div class="viewcode-block" id="Outcar.read_lcalcpol">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Outcar.read_lcalcpol">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_lcalcpol</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read the LCALCPOL.</span>

<span class="sd">        Renders accessible as attributes:</span>
<span class="sd">            p_elec (NDArray[float64]): Total electronic dipole moment.</span>
<span class="sd">            p_ion (NDArray[float64]): Ionic dipole moment.</span>
<span class="sd">            p_sp1 (NDArray[float] | None): Spin up.</span>
<span class="sd">            p_sp2 (NDArray[float] | None): Spin down.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_elec</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_ion</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_sp1</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_sp2</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">search</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Always present spin/non-spin</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">p_elec</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">p_elec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="nb">float</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                        <span class="nb">float</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
                        <span class="nb">float</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
                    <span class="p">]</span>
                <span class="p">)</span>

            <span class="n">search</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="sa">r</span><span class="s2">&quot;^.*Total electronic dipole moment: &quot;</span>
                    <span class="sa">r</span><span class="s2">&quot;*p\[elc\]=\( *([-0-9.Ee+]*) *([-0-9.Ee+]*) &quot;</span>
                    <span class="sa">r</span><span class="s2">&quot;*([-0-9.Ee+]*) *\)&quot;</span><span class="p">,</span>
                    <span class="kc">None</span><span class="p">,</span>
                    <span class="n">p_elec</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="p">)</span>

            <span class="c1"># If spin-polarized (and not noncollinear)</span>
            <span class="c1"># save spin-polarized electronic values</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">noncollinear</span><span class="p">:</span>

                <span class="k">def</span><span class="w"> </span><span class="nf">p_sp1</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
                    <span class="n">results</span><span class="o">.</span><span class="n">p_sp1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                        <span class="p">[</span>
                            <span class="nb">float</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                            <span class="nb">float</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
                            <span class="nb">float</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
                        <span class="p">]</span>
                    <span class="p">)</span>

                <span class="n">search</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="sa">r</span><span class="s2">&quot;^.*p\[sp1\]=\( *([-0-9.Ee+]*) *([-0-9.Ee+]*) *([-0-9.Ee+]*) *\)&quot;</span><span class="p">,</span>
                        <span class="kc">None</span><span class="p">,</span>
                        <span class="n">p_sp1</span><span class="p">,</span>
                    <span class="p">]</span>
                <span class="p">)</span>

                <span class="k">def</span><span class="w"> </span><span class="nf">p_sp2</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
                    <span class="n">results</span><span class="o">.</span><span class="n">p_sp2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                        <span class="p">[</span>
                            <span class="nb">float</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                            <span class="nb">float</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
                            <span class="nb">float</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
                        <span class="p">]</span>
                    <span class="p">)</span>

                <span class="n">search</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="sa">r</span><span class="s2">&quot;^.*p\[sp2\]=\( *([-0-9.Ee+]*) *([-0-9.Ee+]*) *([-0-9.Ee+]*) *\)&quot;</span><span class="p">,</span>
                        <span class="kc">None</span><span class="p">,</span>
                        <span class="n">p_sp2</span><span class="p">,</span>
                    <span class="p">]</span>
                <span class="p">)</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">p_ion</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">p_ion</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="nb">float</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                        <span class="nb">float</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
                        <span class="nb">float</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
                    <span class="p">]</span>
                <span class="p">)</span>

            <span class="n">search</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="sa">r</span><span class="s2">&quot;^.*Ionic dipole moment: *p\[ion\]=\( *([-0-9.Ee+]*) *([-0-9.Ee+]*) *([-0-9.Ee+]*) *\)&quot;</span><span class="p">,</span>
                    <span class="kc">None</span><span class="p">,</span>
                    <span class="n">p_ion</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="p">)</span>

            <span class="n">micro_pyawk</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">search</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

            <span class="c1"># Fix polarization units in new versions of VASP</span>
            <span class="n">regex</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;^.*Ionic dipole moment: .*&quot;</span>
            <span class="n">search</span> <span class="o">=</span> <span class="p">[[</span><span class="n">regex</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">))]]</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">micro_pyawk</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">search</span><span class="p">,</span> <span class="p">[])</span>

            <span class="k">if</span> <span class="s2">&quot;|e|&quot;</span> <span class="ow">in</span> <span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">p_elec</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># type: ignore[operator]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">p_ion</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># type: ignore[operator]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">noncollinear</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">p_sp1</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># type: ignore[operator]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">p_sp2</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># type: ignore[operator]</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;LCALCPOL OUTCAR could not be parsed.&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">exc</span></div>


<div class="viewcode-block" id="Outcar.read_pseudo_zval">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Outcar.read_pseudo_zval">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_pseudo_zval</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a pseudopotential valence electron number (ZVAL) dictionary.</span>

<span class="sd">        Renders accessible as attributes:</span>
<span class="sd">            zval_dict (dict[str, float]): ZVAL for each element.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">atom_symbols</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
                <span class="n">element_symbol</span> <span class="o">=</span> <span class="n">match</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="s2">&quot;atom_symbols&quot;</span><span class="p">):</span>
                    <span class="n">results</span><span class="o">.</span><span class="n">atom_symbols</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">results</span><span class="o">.</span><span class="n">atom_symbols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element_symbol</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">zvals</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
                <span class="n">zvals</span> <span class="o">=</span> <span class="n">match</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">results</span><span class="o">.</span><span class="n">zvals</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;-?\d+\.\d*&quot;</span><span class="p">,</span> <span class="n">zvals</span><span class="p">))</span>

            <span class="n">search</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">search</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="p">[</span><span class="s2">&quot;(?&lt;=VRHFIN =)(.*)(?=:)&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">atom_symbols</span><span class="p">],</span>
                    <span class="p">[</span><span class="s2">&quot;^</span><span class="se">\\</span><span class="s2">s+ZVAL.*=(.*)&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">zvals</span><span class="p">],</span>
                <span class="p">)</span>
            <span class="p">)</span>

            <span class="n">micro_pyawk</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">search</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">zval_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atom_symbols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zvals</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>  <span class="c1"># type: ignore[attr-defined]</span>

            <span class="c1"># Clean up</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom_symbols</span>  <span class="c1"># type: ignore[attr-defined]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">zvals</span>  <span class="c1"># type: ignore[attr-defined]</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;ZVAL dict could not be parsed.&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">exc</span></div>


<div class="viewcode-block" id="Outcar.read_core_state_eigen">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Outcar.read_core_state_eigen">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_core_state_eigen</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read the core state eigenenergies at each ionic step.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[dict[str, list[float]]]: The atom such as [{&quot;AO&quot;: [core_state_eig, ]}, ].</span>
<span class="sd">            The core state eigenenergie list for each AO is over all ionic step.</span>

<span class="sd">        Example:</span>
<span class="sd">            The core state eigenenergie of the 2s AO of the 6th atom of the</span>
<span class="sd">            structure at the last ionic step is [5][&quot;2s&quot;][-1].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">zopen</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;rt&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">foutcar</span><span class="p">:</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">foutcar</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
            <span class="n">core_state_eigs</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">while</span> <span class="n">line</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">foutcar</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>

                <span class="k">if</span> <span class="s2">&quot;NIONS =&quot;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                    <span class="n">natom</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;NIONS =&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">core_state_eigs</span> <span class="o">=</span> <span class="p">[</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">natom</span><span class="p">)]</span>

                <span class="k">if</span> <span class="s2">&quot;the core state eigen&quot;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                    <span class="n">iat</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="k">while</span> <span class="n">line</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                        <span class="n">line</span> <span class="o">=</span> <span class="n">foutcar</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
                        <span class="c1"># don&#39;t know number of lines to parse without knowing</span>
                        <span class="c1"># specific species, so stop parsing when we reach</span>
                        <span class="c1"># &quot;E-fermi&quot; instead</span>
                        <span class="k">if</span> <span class="s2">&quot;E-fermi&quot;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                            <span class="k">break</span>
                        <span class="n">data</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                        <span class="c1"># data will contain odd number of elements if it is</span>
                        <span class="c1"># the start of a new entry, or even number of elements</span>
                        <span class="c1"># if it continues the previous entry</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">iat</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># started parsing a new ion</span>
                            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>  <span class="c1"># remove element with ion number</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
                            <span class="n">core_state_eigs</span><span class="p">[</span><span class="n">iat</span><span class="p">][</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">core_state_eigs</span></div>


<div class="viewcode-block" id="Outcar.read_avg_core_poten">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Outcar.read_avg_core_poten">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_avg_core_poten</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read the core potential at each ionic step.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[list[float]]: The average core potentials for each atom of each ionic</span>
<span class="sd">                step as: [[avg_core_pot, ], ].</span>

<span class="sd">        Example:</span>
<span class="sd">            The average core potential of the 2nd atom of the structure at the</span>
<span class="sd">            last ionic step is: [-1][1].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">zopen</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;rt&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">foutcar</span><span class="p">:</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">foutcar</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
            <span class="n">avg_core_pots</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">while</span> <span class="n">line</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">foutcar</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
                <span class="k">if</span> <span class="s2">&quot;the norm of the test charge is&quot;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                    <span class="n">avg_pot</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">while</span> <span class="n">line</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                        <span class="n">line</span> <span class="o">=</span> <span class="n">foutcar</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
                        <span class="c1"># don&#39;t know number of lines to parse without knowing</span>
                        <span class="c1"># specific species, so stop parsing when we reach</span>
                        <span class="c1"># &quot;E-fermi&quot; instead</span>
                        <span class="k">if</span> <span class="s2">&quot;E-fermi&quot;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                            <span class="n">avg_core_pots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">avg_pot</span><span class="p">)</span>
                            <span class="k">break</span>

                        <span class="c1"># the average core potentials of up to 5 elements are</span>
                        <span class="c1"># given per line; the potentials are separated by several</span>
                        <span class="c1"># spaces and numbered from 1 to natoms; the potentials are</span>
                        <span class="c1"># parsed in a fixed width format</span>
                        <span class="n">npots</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">17</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npots</span><span class="p">):</span>
                            <span class="n">start</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">17</span>
                            <span class="n">avg_pot</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="n">start</span> <span class="o">+</span> <span class="mi">8</span> <span class="p">:</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">17</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">avg_core_pots</span></div>


<div class="viewcode-block" id="Outcar.read_fermi_contact_shift">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Outcar.read_fermi_contact_shift">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_fermi_contact_shift</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read Fermi contact (isotropic) hyperfine coupling parameter.</span>

<span class="sd">        Output example:</span>
<span class="sd">            Fermi contact (isotropic) hyperfine coupling parameter (MHz)</span>
<span class="sd">            -------------------------------------------------------------</span>
<span class="sd">            ion      A_pw      A_1PS     A_1AE     A_1c      A_tot</span>
<span class="sd">            -------------------------------------------------------------</span>
<span class="sd">            1      -0.002    -0.002    -0.051     0.000    -0.052</span>
<span class="sd">            2      -0.002    -0.002    -0.051     0.000    -0.052</span>
<span class="sd">            3       0.056     0.056     0.321    -0.048     0.321</span>
<span class="sd">            -------------------------------------------------------------</span>
<span class="sd">            which corresponds to:</span>
<span class="sd">                [[-0.002, -0.002, -0.051, 0.0, -0.052],</span>
<span class="sd">                [-0.002, -0.002, -0.051, 0.0, -0.052],</span>
<span class="sd">                [0.056, 0.056, 0.321, -0.048, 0.321]] from &#39;fch&#39; data.</span>

<span class="sd">        Renders accessible from self.data:</span>
<span class="sd">            fermi_contact_shift (dict[Literal[&quot;fch&quot;, &quot;dh&quot;, &quot;th&quot;], list[list[float]]]):</span>
<span class="sd">                Fermi contact (isotropic) hyperfine coupling parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Fermi contact (isotropic) hyperfine coupling parameter (MHz)</span>
        <span class="n">header_pattern1</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">r</span><span class="s2">&quot;\s*Fermi contact \(isotropic\) hyperfine coupling parameter \(MHz\)\s+&quot;</span>
            <span class="sa">r</span><span class="s2">&quot;\s*\-+&quot;</span>
            <span class="sa">r</span><span class="s2">&quot;\s*ion\s+A_pw\s+A_1PS\s+A_1AE\s+A_1c\s+A_tot\s+&quot;</span>
            <span class="sa">r</span><span class="s2">&quot;\s*\-+&quot;</span>
        <span class="p">)</span>
        <span class="n">row_pattern1</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;(?:\d+)\s+&quot;</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;\s+&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">r</span><span class="s2">&quot;([-]?\d+\.\d+)&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">5</span><span class="p">)</span>
        <span class="n">footer_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\-+&quot;</span>
        <span class="n">fch_table</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_table_pattern</span><span class="p">(</span>
            <span class="n">header_pattern1</span><span class="p">,</span>
            <span class="n">row_pattern1</span><span class="p">,</span>
            <span class="n">footer_pattern</span><span class="p">,</span>
            <span class="n">postprocess</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
            <span class="n">last_one_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Dipolar hyperfine coupling parameters (MHz)</span>
        <span class="n">header_pattern2</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">r</span><span class="s2">&quot;\s*Dipolar hyperfine coupling parameters \(MHz\)\s+&quot;</span>
            <span class="sa">r</span><span class="s2">&quot;\s*\-+&quot;</span>
            <span class="sa">r</span><span class="s2">&quot;\s*ion\s+A_xx\s+A_yy\s+A_zz\s+A_xy\s+A_xz\s+A_yz\s+&quot;</span>
            <span class="sa">r</span><span class="s2">&quot;\s*\-+&quot;</span>
        <span class="p">)</span>
        <span class="n">row_pattern2</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;(?:\d+)\s+&quot;</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;\s+&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">r</span><span class="s2">&quot;([-]?\d+\.\d+)&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">6</span><span class="p">)</span>
        <span class="n">dh_table</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_table_pattern</span><span class="p">(</span>
            <span class="n">header_pattern2</span><span class="p">,</span>
            <span class="n">row_pattern2</span><span class="p">,</span>
            <span class="n">footer_pattern</span><span class="p">,</span>
            <span class="n">postprocess</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
            <span class="n">last_one_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Total hyperfine coupling parameters after diagonalization (MHz)</span>
        <span class="n">header_pattern3</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">r</span><span class="s2">&quot;\s*Total hyperfine coupling parameters after diagonalization \(MHz\)\s+&quot;</span>
            <span class="sa">r</span><span class="s2">&quot;\s*\(convention: \|A_zz\| &gt; \|A_xx\| &gt; \|A_yy\|\)\s+&quot;</span>
            <span class="sa">r</span><span class="s2">&quot;\s*\-+&quot;</span>
            <span class="sa">r</span><span class="s2">&quot;\s*ion\s+A_xx\s+A_yy\s+A_zz\s+asymmetry \(A_yy - A_xx\)/ A_zz\s+&quot;</span>
            <span class="sa">r</span><span class="s2">&quot;\s*\-+&quot;</span>
        <span class="p">)</span>
        <span class="n">row_pattern3</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;(?:\d+)\s+&quot;</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;\s+&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">r</span><span class="s2">&quot;([-]?\d+\.\d+)&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">th_table</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_table_pattern</span><span class="p">(</span>
            <span class="n">header_pattern3</span><span class="p">,</span>
            <span class="n">row_pattern3</span><span class="p">,</span>
            <span class="n">footer_pattern</span><span class="p">,</span>
            <span class="n">postprocess</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
            <span class="n">last_one_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">fc_shift_table</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;fch&quot;</span><span class="p">,</span> <span class="s2">&quot;dh&quot;</span><span class="p">,</span> <span class="s2">&quot;th&quot;</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;fch&quot;</span><span class="p">:</span> <span class="n">fch_table</span><span class="p">,</span>
            <span class="s2">&quot;dh&quot;</span><span class="p">:</span> <span class="n">dh_table</span><span class="p">,</span>
            <span class="s2">&quot;th&quot;</span><span class="p">:</span> <span class="n">th_table</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;fermi_contact_shift&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fc_shift_table</span></div>
</div>



<div class="viewcode-block" id="VolumetricData">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.VolumetricData">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">VolumetricData</span><span class="p">(</span><span class="n">BaseVolumetricData</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Container for volumetric data that allows</span>
<span class="sd">    for reading/writing with Poscar-type data.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="VolumetricData.parse_file">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.VolumetricData.parse_file">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">parse_file</span><span class="p">(</span><span class="n">filename</span><span class="p">:</span> <span class="n">PathLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Poscar</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parse a generic volumetric data file in the VASP like format.</span>
<span class="sd">        Used by subclasses for parsing files.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename (PathLike): Path of file to parse.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[Poscar, dict, dict]: Poscar object, data dict, data_aug dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">poscar_read</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">poscar_string</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">dataset</span><span class="p">:</span> <span class="n">NDArray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">all_dataset</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">NDArray</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># for holding any strings in input that are not Poscar</span>
        <span class="c1"># or VolumetricData (typically augmentation charges)</span>
        <span class="n">all_dataset_aug</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">dim</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">dimline</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">read_dataset</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">ngrid_pts</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">data_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">poscar</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">with</span> <span class="n">zopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;rt&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">file</span><span class="p">:</span>
                <span class="n">original_line</span> <span class="o">=</span> <span class="n">line</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">read_dataset</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">data_count</span> <span class="o">&lt;</span> <span class="n">ngrid_pts</span><span class="p">:</span>
                            <span class="c1"># This complicated procedure is necessary because</span>
                            <span class="c1"># VASP outputs x as the fastest index, followed by y</span>
                            <span class="c1"># then z.</span>
                            <span class="n">no_x</span> <span class="o">=</span> <span class="n">data_count</span> <span class="o">//</span> <span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="n">dataset</span><span class="p">[</span><span class="n">data_count</span> <span class="o">%</span> <span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">no_x</span> <span class="o">%</span> <span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">no_x</span> <span class="o">//</span> <span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span>
                            <span class="n">data_count</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">data_count</span> <span class="o">&gt;=</span> <span class="n">ngrid_pts</span><span class="p">:</span>
                        <span class="n">read_dataset</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="n">data_count</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">all_dataset</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>

                <span class="k">elif</span> <span class="ow">not</span> <span class="n">poscar_read</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">line</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">poscar_string</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">poscar_string</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">line</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                        <span class="n">poscar</span> <span class="o">=</span> <span class="n">Poscar</span><span class="o">.</span><span class="n">from_str</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">poscar_string</span><span class="p">))</span>
                        <span class="n">poscar_read</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="k">elif</span> <span class="ow">not</span> <span class="n">dim</span><span class="p">:</span>
                    <span class="n">dim</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>
                    <span class="n">ngrid_pts</span> <span class="o">=</span> <span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">dim</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">dimline</span> <span class="o">=</span> <span class="n">line</span>
                    <span class="n">read_dataset</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">dataset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>

                <span class="k">elif</span> <span class="n">line</span> <span class="o">==</span> <span class="n">dimline</span><span class="p">:</span>
                    <span class="c1"># when line == dimline, expect volumetric data to follow</span>
                    <span class="c1"># so set read_dataset to True</span>
                    <span class="n">read_dataset</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">dataset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># store any extra lines that were not part of the</span>
                    <span class="c1"># volumetric data so we know which set of data the extra</span>
                    <span class="c1"># lines are associated with</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_dataset</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_dataset_aug</span><span class="p">:</span>
                        <span class="n">all_dataset_aug</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">all_dataset_aug</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">original_line</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_dataset</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;total&quot;</span><span class="p">:</span> <span class="n">all_dataset</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="s2">&quot;diff_x&quot;</span><span class="p">:</span> <span class="n">all_dataset</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="s2">&quot;diff_y&quot;</span><span class="p">:</span> <span class="n">all_dataset</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                    <span class="s2">&quot;diff_z&quot;</span><span class="p">:</span> <span class="n">all_dataset</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                <span class="p">}</span>
                <span class="n">data_aug</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;total&quot;</span><span class="p">:</span> <span class="n">all_dataset_aug</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                    <span class="s2">&quot;diff_x&quot;</span><span class="p">:</span> <span class="n">all_dataset_aug</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                    <span class="s2">&quot;diff_y&quot;</span><span class="p">:</span> <span class="n">all_dataset_aug</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
                    <span class="s2">&quot;diff_z&quot;</span><span class="p">:</span> <span class="n">all_dataset_aug</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
                <span class="p">}</span>

                <span class="c1"># Construct a &quot;diff&quot; dict for scalar-like magnetization density,</span>
                <span class="c1"># referenced to an arbitrary direction (using same method as</span>
                <span class="c1"># pymatgen.electronic_structure.core.Magmom, see</span>
                <span class="c1"># Magmom documentation for justification for this)</span>
                <span class="c1"># TODO: re-examine this, and also similar behavior in</span>
                <span class="c1"># Magmom - @mkhorton</span>
                <span class="c1"># TODO: does CHGCAR change with different SAXIS?</span>
                <span class="n">diff_xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;diff_x&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;diff_y&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;diff_z&quot;</span><span class="p">]])</span>
                <span class="n">diff_xyz</span> <span class="o">=</span> <span class="n">diff_xyz</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">dim</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
                <span class="n">ref_direction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.01</span><span class="p">,</span> <span class="mf">1.02</span><span class="p">,</span> <span class="mf">1.03</span><span class="p">])</span>
                <span class="n">ref_sign</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ref_direction</span><span class="p">,</span> <span class="n">diff_xyz</span><span class="p">))</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">diff_xyz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">ref_sign</span><span class="p">)</span>
                <span class="n">data</span><span class="p">[</span><span class="s2">&quot;diff&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">diff</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dim</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>

            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_dataset</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;total&quot;</span><span class="p">:</span> <span class="n">all_dataset</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;diff&quot;</span><span class="p">:</span> <span class="n">all_dataset</span><span class="p">[</span><span class="mi">1</span><span class="p">]}</span>
                <span class="n">data_aug</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;total&quot;</span><span class="p">:</span> <span class="n">all_dataset_aug</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                    <span class="s2">&quot;diff&quot;</span><span class="p">:</span> <span class="n">all_dataset_aug</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                <span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;total&quot;</span><span class="p">:</span> <span class="n">all_dataset</span><span class="p">[</span><span class="mi">0</span><span class="p">]}</span>
                <span class="n">data_aug</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;total&quot;</span><span class="p">:</span> <span class="n">all_dataset_aug</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">0</span><span class="p">)}</span>
            <span class="k">return</span> <span class="n">poscar</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">data_aug</span>  <span class="c1"># type: ignore[return-value]</span></div>


<div class="viewcode-block" id="VolumetricData.write_file">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.VolumetricData.write_file">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write_file</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">file_name</span><span class="p">:</span> <span class="n">PathLike</span><span class="p">,</span>
        <span class="n">vasp4_compatible</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write the VolumetricData object to a VASP compatible file.</span>

<span class="sd">        Args:</span>
<span class="sd">            file_name (PathLike): The output file.</span>
<span class="sd">            vasp4_compatible (bool): True if the format is VASP4 compatible.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">format_fortran_float</span><span class="p">(</span><span class="n">flt</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Fortran code prints floats with a leading zero in scientific</span>
<span class="sd">            notation. When writing CHGCAR files, we adopt this convention</span>
<span class="sd">            to ensure written CHGCAR files are byte-to-byte identical to</span>
<span class="sd">            their input files as far as possible.</span>

<span class="sd">            Args:</span>
<span class="sd">                flt (float): Float to print.</span>

<span class="sd">            Returns:</span>
<span class="sd">                str: The float in Fortran format.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">flt_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">flt</span><span class="si">:</span><span class="s2">.10E</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">if</span> <span class="n">flt</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;0.</span><span class="si">{</span><span class="n">flt_str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}{</span><span class="n">flt_str</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">12</span><span class="p">]</span><span class="si">}</span><span class="s2">E</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">flt_str</span><span class="p">[</span><span class="mi">13</span><span class="p">:])</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">:</span><span class="s2">+03</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;-.</span><span class="si">{</span><span class="n">flt_str</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}{</span><span class="n">flt_str</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">13</span><span class="p">]</span><span class="si">}</span><span class="s2">E</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">flt_str</span><span class="p">[</span><span class="mi">14</span><span class="p">:])</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">:</span><span class="s2">+03</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">write_spin</span><span class="p">(</span><span class="n">data_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   </span><span class="si">{</span><span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">   </span><span class="si">{</span><span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">   </span><span class="si">{</span><span class="n">dim</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">[</span><span class="mi">2</span><span class="p">])),</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]))):</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">format_fortran_float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">data_type</span><span class="p">][</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]))</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">count</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_aug</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">data_type</span><span class="p">,</span> <span class="p">[])</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
                <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

        <span class="k">with</span> <span class="n">zopen</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;wt&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">poscar</span> <span class="o">=</span> <span class="n">Poscar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span>

            <span class="c1"># Use original name if it&#39;s been set (e.g. from Chgcar)</span>
            <span class="n">comment</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">poscar</span><span class="o">.</span><span class="n">comment</span><span class="p">)</span>

            <span class="n">lines</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">comment</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="n">lines</span> <span class="o">+=</span> <span class="s2">&quot;   1.00000000000000</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="k">for</span> <span class="n">vec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">matrix</span><span class="p">:</span>
                <span class="n">lines</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">12.6f</span><span class="si">}{</span><span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">12.6f</span><span class="si">}{</span><span class="n">vec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">:</span><span class="s2">12.6f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">vasp4_compatible</span><span class="p">:</span>
                <span class="n">lines</span> <span class="o">+=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">s</span><span class="si">:</span><span class="s2">5</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">poscar</span><span class="o">.</span><span class="n">site_symbols</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="n">lines</span> <span class="o">+=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s2">6</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">poscar</span><span class="o">.</span><span class="n">natoms</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="n">lines</span> <span class="o">+=</span> <span class="s2">&quot;Direct</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">:</span>
                <span class="n">dim</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">frac_coords</span>
                <span class="n">lines</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dim</span><span class="si">:</span><span class="s2">10.6f</span><span class="si">}{</span><span class="n">b</span><span class="si">:</span><span class="s2">10.6f</span><span class="si">}{</span><span class="n">c</span><span class="si">:</span><span class="s2">10.6f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="n">lines</span> <span class="o">+=</span> <span class="s2">&quot; </span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span>

            <span class="n">write_spin</span><span class="p">(</span><span class="s2">&quot;total&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_spin_polarized</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_soc</span><span class="p">:</span>
                    <span class="n">write_spin</span><span class="p">(</span><span class="s2">&quot;diff_x&quot;</span><span class="p">)</span>
                    <span class="n">write_spin</span><span class="p">(</span><span class="s2">&quot;diff_y&quot;</span><span class="p">)</span>
                    <span class="n">write_spin</span><span class="p">(</span><span class="s2">&quot;diff_z&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">write_spin</span><span class="p">(</span><span class="s2">&quot;diff&quot;</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="Locpot">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Locpot">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Locpot</span><span class="p">(</span><span class="n">VolumetricData</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;LOCPOT file reader.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">poscar</span><span class="p">:</span> <span class="n">Poscar</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            poscar (Poscar): Poscar object containing structure.</span>
<span class="sd">            data (NDArray): Actual data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">poscar</span><span class="o">.</span><span class="n">structure</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">poscar</span><span class="o">.</span><span class="n">comment</span>

<div class="viewcode-block" id="Locpot.from_file">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Locpot.from_file">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_file</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="n">PathLike</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read a LOCPOT file.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename (PathLike): Path to LOCPOT file.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Locpot</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">poscar</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">_data_aug</span> <span class="o">=</span> <span class="n">VolumetricData</span><span class="o">.</span><span class="n">parse_file</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">poscar</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="Chgcar">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Chgcar">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Chgcar</span><span class="p">(</span><span class="n">VolumetricData</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;CHGCAR file reader.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">poscar</span><span class="p">:</span> <span class="n">Poscar</span> <span class="o">|</span> <span class="n">Structure</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">],</span>
        <span class="n">data_aug</span><span class="p">:</span> <span class="n">NDArray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            poscar (Poscar | Structure): Object containing structure.</span>
<span class="sd">            data: Actual data.</span>
<span class="sd">            data_aug: Augmentation charge data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Allow Poscar or Structure to be passed</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">poscar</span><span class="p">,</span> <span class="n">Poscar</span><span class="p">):</span>
            <span class="n">struct</span> <span class="o">=</span> <span class="n">poscar</span><span class="o">.</span><span class="n">structure</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">poscar</span> <span class="o">=</span> <span class="n">poscar</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="n">poscar</span><span class="o">.</span><span class="n">comment</span>  <span class="c1"># type: ignore[assignment]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">poscar</span><span class="p">,</span> <span class="n">Structure</span><span class="p">):</span>
            <span class="n">struct</span> <span class="o">=</span> <span class="n">poscar</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">poscar</span> <span class="o">=</span> <span class="n">Poscar</span><span class="p">(</span><span class="n">poscar</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unsupported POSCAR type.&quot;</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">struct</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">data_aug</span><span class="o">=</span><span class="n">data_aug</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_distance_matrix</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{}</span>

<div class="viewcode-block" id="Chgcar.from_file">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Chgcar.from_file">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_file</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read a CHGCAR file.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename (str): Path to CHGCAR file.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Chgcar</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">poscar</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">data_aug</span> <span class="o">=</span> <span class="n">VolumetricData</span><span class="o">.</span><span class="n">parse_file</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">poscar</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">data_aug</span><span class="o">=</span><span class="n">data_aug</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">net_magnetization</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Net magnetic moment from Chgcar.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;diff&quot;</span><span class="p">])</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_spin_polarized</span> <span class="k">else</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="Elfcar">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Elfcar">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Elfcar</span><span class="p">(</span><span class="n">VolumetricData</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Read an ELFCAR file which contains the Electron Localization Function (ELF).</span>

<span class="sd">    For ELF, &quot;total&quot; key refers to Spin.up, and &quot;diff&quot; refers to Spin.down.</span>

<span class="sd">    This also contains information on the kinetic energy density.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">poscar</span><span class="p">:</span> <span class="n">Poscar</span> <span class="o">|</span> <span class="n">Structure</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            poscar (Poscar or Structure): Object containing structure.</span>
<span class="sd">            data: Actual data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Allow Poscar or Structure to be passed</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">poscar</span><span class="p">,</span> <span class="n">Poscar</span><span class="p">):</span>
            <span class="n">tmp_struct</span> <span class="o">=</span> <span class="n">poscar</span><span class="o">.</span><span class="n">structure</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">poscar</span> <span class="o">=</span> <span class="n">poscar</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">poscar</span><span class="p">,</span> <span class="n">Structure</span><span class="p">):</span>
            <span class="n">tmp_struct</span> <span class="o">=</span> <span class="n">poscar</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">poscar</span> <span class="o">=</span> <span class="n">Poscar</span><span class="p">(</span><span class="n">poscar</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unsupported POSCAR type.&quot;</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">tmp_struct</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="c1"># TODO: (mkhorton) modify VolumetricData so that the correct keys can be used.</span>
        <span class="c1"># for ELF, instead of &quot;total&quot; and &quot;diff&quot; keys we have</span>
        <span class="c1"># &quot;Spin.up&quot; and &quot;Spin.down&quot; keys</span>
        <span class="c1"># I believe this is correct, but there&#39;s not much documentation.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>

<div class="viewcode-block" id="Elfcar.from_file">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Elfcar.from_file">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_file</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read a ELFCAR file.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename: Filename</span>

<span class="sd">        Returns:</span>
<span class="sd">            Elfcar</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">poscar</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">_data_aug</span> <span class="o">=</span> <span class="n">VolumetricData</span><span class="o">.</span><span class="n">parse_file</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">poscar</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span></div>


<div class="viewcode-block" id="Elfcar.get_alpha">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Elfcar.get_alpha">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VolumetricData</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the parameter alpha where ELF = 1/(1 + alpha^2).&quot;&quot;&quot;</span>
        <span class="n">alpha_data</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="mi">1</span> <span class="o">/</span> <span class="n">val</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">return</span> <span class="n">VolumetricData</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">,</span> <span class="n">alpha_data</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="Procar">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Procar">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Procar</span><span class="p">(</span><span class="n">MSONable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    PROCAR file reader.</span>

<span class="sd">    Updated to use code from easyunfold (https://smtg-bham.github.io/easyunfold; band-structure</span>
<span class="sd">    unfolding package) to allow SOC PROCAR parsing, and parsing multiple PROCAR files together.</span>
<span class="sd">    easyunfold&#39;s PROCAR parser can be used if finer control over projections (k-point weighting,</span>
<span class="sd">    normalisation per band, quick orbital sub-selection etc) is needed.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        data (dict): The PROCAR data of the form below. It should VASP uses 1-based indexing,</span>
<span class="sd">            but all indices are converted to 0-based here.</span>
<span class="sd">            {spin: np.array accessed with (k-point index, band index, ion index, orbital index)}</span>
<span class="sd">        weights (NDArray): The weights associated with each k-point as an array of length nkpoints.</span>
<span class="sd">        phase_factors (dict): Phase factors, where present (e.g. LORBIT = 12). A dict of the form:</span>
<span class="sd">            {spin: complex np.array accessed with (k-point index, band index, ion index, orbital index)}</span>
<span class="sd">        nbands (int): Number of bands.</span>
<span class="sd">        nkpoints (int): Number of k-points.</span>
<span class="sd">        nions (int): Number of ions.</span>
<span class="sd">        nspins (int): Number of spins.</span>
<span class="sd">        is_soc (bool): Whether the PROCAR contains spin-orbit coupling (LSORBIT = True) data.</span>
<span class="sd">        kpoints (NDArray): The k-points as an np.array of shape (nkpoints, 3).</span>
<span class="sd">        occupancies (dict): The occupancies of the bands as a dict of the form:</span>
<span class="sd">            {spin: np.array accessed with (k-point index, band index)}</span>
<span class="sd">        eigenvalues (dict): The eigenvalues of the bands as a dict of the form:</span>
<span class="sd">            {spin: np.array accessed with (k-point index, band index)}</span>
<span class="sd">        xyz_data (dict): The PROCAR projections data along the x,y and z magnetisation projection</span>
<span class="sd">            directions, with is_soc = True (see VASP wiki for more info).</span>
<span class="sd">            {&#39;x&#39;/&#39;y&#39;/&#39;z&#39;: np.array accessed with (k-point index, band index, ion index, orbital index)}</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="n">PathLike</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">PathLike</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            filename: The path to PROCAR(.gz) file to read, or list of paths.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get PROCAR filenames list to parse:</span>
        <span class="n">filenames</span> <span class="o">=</span> <span class="n">filename</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">filename</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nions</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># used to check for consistency in files later</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nspins</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># used to check for consistency in files later</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_soc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># used to check for consistency in files later</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">orbitals</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># used to check for consistency in files later</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">filenames</span><span class="p">)</span>

<div class="viewcode-block" id="Procar.read">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Procar.read">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filenames</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">PathLike</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read in PROCAR projections data, possibly from multiple files.</span>

<span class="sd">        Args:</span>
<span class="sd">            filenames: List of PROCAR files to read.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parsed_kpoints</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">occupancies_list</span><span class="p">,</span> <span class="n">kpoints_list</span><span class="p">,</span> <span class="n">weights_list</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">eigenvalues_list</span><span class="p">,</span> <span class="n">data_list</span><span class="p">,</span> <span class="n">xyz_data_list</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">phase_factors_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">filenames</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Reading PROCARs&quot;</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;file&quot;</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">filenames</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="p">(</span>
                <span class="n">kpoints</span><span class="p">,</span>
                <span class="n">weights</span><span class="p">,</span>
                <span class="n">eigenvalues</span><span class="p">,</span>
                <span class="n">occupancies</span><span class="p">,</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="n">phase_factors</span><span class="p">,</span>
                <span class="n">xyz_data</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">parsed_kpoints</span><span class="o">=</span><span class="n">parsed_kpoints</span><span class="p">)</span>

            <span class="c1"># Append to respective lists</span>
            <span class="n">occupancies_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">occupancies</span><span class="p">)</span>
            <span class="n">kpoints_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kpoints</span><span class="p">)</span>
            <span class="n">weights_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
            <span class="n">eigenvalues_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eigenvalues</span><span class="p">)</span>
            <span class="n">data_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">xyz_data_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xyz_data</span><span class="p">)</span>
            <span class="n">phase_factors_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">phase_factors</span><span class="p">)</span>

        <span class="c1"># Combine arrays along the kpoints axis:</span>
        <span class="c1"># nbands (axis = 2) could differ between arrays, so set missing values to zero:</span>
        <span class="n">max_nbands</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">eig_dict</span><span class="p">[</span><span class="n">Spin</span><span class="o">.</span><span class="n">up</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">eig_dict</span> <span class="ow">in</span> <span class="n">eigenvalues_list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">dict_array</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
            <span class="n">occupancies_list</span><span class="p">,</span>
            <span class="n">eigenvalues_list</span><span class="p">,</span>
            <span class="n">data_list</span><span class="p">,</span>
            <span class="n">xyz_data_list</span><span class="p">,</span>
            <span class="n">phase_factors_list</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">dict_array</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">array</span> <span class="ow">in</span> <span class="n">dict_array</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">max_nbands</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># occupancies, eigenvalues</span>
                            <span class="n">dict_array</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span>
                                <span class="n">array</span><span class="p">,</span>
                                <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_nbands</span> <span class="o">-</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])),</span>
                                <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span>
                            <span class="p">)</span>
                        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>  <span class="c1"># data, phase_factors</span>
                            <span class="n">dict_array</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span>
                                <span class="n">array</span><span class="p">,</span>
                                <span class="p">(</span>
                                    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                                    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_nbands</span> <span class="o">-</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
                                    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                                    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                                <span class="p">),</span>
                                <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span>
                            <span class="p">)</span>
                        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>  <span class="c1"># xyz_data</span>
                            <span class="n">dict_array</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span>
                                <span class="n">array</span><span class="p">,</span>
                                <span class="p">(</span>
                                    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                                    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_nbands</span> <span class="o">-</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
                                    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                                    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                                    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                                <span class="p">),</span>
                                <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span>
                            <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unexpected array shape encountered!&quot;</span><span class="p">)</span>

        <span class="c1"># set nbands, nkpoints, and other attributes:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbands</span> <span class="o">=</span> <span class="n">max_nbands</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">kpoints_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nkpoints</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kpoints</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">occupancies</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">spin</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">occupancies</span><span class="p">[</span><span class="n">spin</span><span class="p">]</span> <span class="k">for</span> <span class="n">occupancies</span> <span class="ow">in</span> <span class="n">occupancies_list</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">spin</span> <span class="ow">in</span> <span class="n">occupancies_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">spin</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">eigenvalues</span><span class="p">[</span><span class="n">spin</span><span class="p">]</span> <span class="k">for</span> <span class="n">eigenvalues</span> <span class="ow">in</span> <span class="n">eigenvalues_list</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">spin</span> <span class="ow">in</span> <span class="n">eigenvalues_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">weights_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="n">spin</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">data</span><span class="p">[</span><span class="n">spin</span><span class="p">]</span> <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">data_list</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">spin</span> <span class="ow">in</span> <span class="n">data_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phase_factors</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">spin</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">phase_factors</span><span class="p">[</span><span class="n">spin</span><span class="p">]</span> <span class="k">for</span> <span class="n">phase_factors</span> <span class="ow">in</span> <span class="n">phase_factors_list</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">spin</span> <span class="ow">in</span> <span class="n">phase_factors_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_soc</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xyz_data</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">key</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">xyz_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">xyz_data</span> <span class="ow">in</span> <span class="n">xyz_data_list</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">xyz_data_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xyz_data</span> <span class="o">=</span> <span class="kc">None</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_parse_kpoint_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple3Floats</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parse k-point vector from a PROCAR line.</span>

<span class="sd">        Sometimes VASP outputs the kpoints joined together like</span>
<span class="sd">        &#39;0.00000000-0.50000000-0.50000000&#39; when there are negative signs,</span>
<span class="sd">        so need to be able to recognise and handle this.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fields</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="n">kpoint_fields</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">fields</span><span class="p">[</span><span class="mi">3</span> <span class="p">:</span> <span class="n">fields</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;weight&quot;</span><span class="p">)]</span>
        <span class="n">_kpoint_fields</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot; -&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">split</span><span class="p">()</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">kpoint_fields</span><span class="p">]</span>
        <span class="n">kpoint_fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">_kpoint_fields</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]</span>  <span class="c1"># flattened</span>

        <span class="c1"># tuple to make it hashable, rounded to 5 decimal places to ensure proper kpoint matching</span>
        <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">Tuple3Floats</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="mi">5</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">kpoint_fields</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="n">PathLike</span><span class="p">,</span> <span class="n">parsed_kpoints</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">Kpoint</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Main function for reading in the PROCAR projections data.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename (PathLike): Path to PROCAR file to read.</span>
<span class="sd">            parsed_kpoints (set[tuple[Kpoint]]): Set of tuples of already-parsed kpoints (e.g. from multiple</span>
<span class="sd">                zero-weighted bandstructure calculations), to ensure redundant/duplicate parsing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">parsed_kpoints</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parsed_kpoints</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">with</span> <span class="n">zopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;rt&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">preamble_expr</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;# of k-points:\s*(\d+)\s+# of bands:\s*(\d+)\s+# of ions:\s*(\d+)&quot;</span><span class="p">)</span>
            <span class="n">kpoint_expr</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^k-point\s+(\d+).*weight = ([0-9\.]+)&quot;</span><span class="p">)</span>
            <span class="n">band_expr</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^band\s+(\d+)&quot;</span><span class="p">)</span>
            <span class="n">ion_expr</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^ion.*&quot;</span><span class="p">)</span>
            <span class="n">total_expr</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^tot.*&quot;</span><span class="p">)</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^([0-9]+)\s+&quot;</span><span class="p">)</span>
            <span class="n">current_kpoint</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">current_band</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">spin</span> <span class="o">=</span> <span class="n">Spin</span><span class="o">.</span><span class="n">down</span>  <span class="c1"># switched to Spin.up for first block</span>

            <span class="n">n_kpoints</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">kpoints</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">n_bands</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">n_ions</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">weights</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">headers</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Spin</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">eigenvalues</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Spin</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">occupancies</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Spin</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">phase_factors</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Spin</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">xyz_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">NDArray</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># &#39;x&#39;/&#39;y&#39;/&#39;z&#39; as keys for SOC projections dict</span>
            <span class="c1"># keep track of parsed kpoints, to avoid redundant/duplicate parsing with multiple PROCARs:</span>
            <span class="n">this_procar_parsed_kpoints</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">set</span><span class="p">()</span>
            <span class="p">)</span>  <span class="c1"># set of tuples of parsed (kvectors, 0/1 for Spin.up/down) for this PROCAR</span>

            <span class="c1"># first dynamically determine whether PROCAR is SOC or not; SOC PROCARs have 4 lists of projections (</span>
            <span class="c1"># total and x,y,z) for each band, while non-SOC have only 1 list of projections:</span>
            <span class="n">tot_count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">band_count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">file</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">total_expr</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
                    <span class="n">tot_count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">band_expr</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
                    <span class="n">band_count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">band_count</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">break</span>

            <span class="n">file</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># reset file handle to beginning</span>
            <span class="k">if</span> <span class="n">tot_count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">is_soc</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">tot_count</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">is_soc</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Number of lines starting with &#39;tot&#39; in PROCAR does not match expected values (4x or 1x number of &quot;</span>
                    <span class="s2">&quot;lines with &#39;band&#39;), indicating a corrupted file!&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_soc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_soc</span> <span class="o">!=</span> <span class="n">is_soc</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Mismatch in SOC setting (LSORBIT) in supplied PROCARs!&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_soc</span> <span class="o">=</span> <span class="n">is_soc</span>

            <span class="n">skipping_kpoint</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># true when skipping projections for a previously-parsed kpoint</span>
            <span class="n">ion_line_count</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># printed twice when phase factors present</span>
            <span class="n">proj_data_parsed_for_band</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># 0 for non-SOC, 1-4 for SOC/phase factors</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">file</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">ion_expr</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
                    <span class="n">ion_line_count</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">kpoint_expr</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
                    <span class="n">kvec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_kpoint_line</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                    <span class="n">match</span> <span class="o">=</span> <span class="n">kpoint_expr</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                    <span class="n">current_kpoint</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># type: ignore[index]</span>
                    <span class="k">if</span> <span class="n">current_kpoint</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">spin</span> <span class="o">=</span> <span class="n">Spin</span><span class="o">.</span><span class="n">up</span> <span class="k">if</span> <span class="n">spin</span> <span class="o">==</span> <span class="n">Spin</span><span class="o">.</span><span class="n">down</span> <span class="k">else</span> <span class="n">Spin</span><span class="o">.</span><span class="n">down</span>

                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">kvec</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">parsed_kpoints</span>
                        <span class="ow">and</span> <span class="p">(</span><span class="n">kvec</span><span class="p">,</span> <span class="p">{</span><span class="n">Spin</span><span class="o">.</span><span class="n">down</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Spin</span><span class="o">.</span><span class="n">up</span><span class="p">:</span> <span class="mi">1</span><span class="p">}[</span><span class="n">spin</span><span class="p">])</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">this_procar_parsed_kpoints</span>
                    <span class="p">):</span>
                        <span class="n">this_procar_parsed_kpoints</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">kvec</span><span class="p">,</span> <span class="p">{</span><span class="n">Spin</span><span class="o">.</span><span class="n">down</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Spin</span><span class="o">.</span><span class="n">up</span><span class="p">:</span> <span class="mi">1</span><span class="p">}[</span><span class="n">spin</span><span class="p">]))</span>
                        <span class="n">skipping_kpoint</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">if</span> <span class="n">spin</span> <span class="o">==</span> <span class="n">Spin</span><span class="o">.</span><span class="n">up</span><span class="p">:</span>
                            <span class="n">kpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kvec</span><span class="p">)</span>  <span class="c1"># only add once</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># skip ahead to next kpoint:</span>
                        <span class="n">skipping_kpoint</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">continue</span>

                    <span class="k">if</span> <span class="n">spin</span> <span class="o">==</span> <span class="n">Spin</span><span class="o">.</span><span class="n">up</span><span class="p">:</span>  <span class="c1"># record k-weight only once</span>
                        <span class="n">weights</span><span class="p">[</span><span class="n">current_kpoint</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>  <span class="c1"># type: ignore[index]</span>
                    <span class="n">proj_data_parsed_for_band</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="k">elif</span> <span class="n">skipping_kpoint</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">elif</span> <span class="n">band_expr</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
                    <span class="n">ion_line_count</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># printed a second time when phase factors present</span>
                    <span class="n">match</span> <span class="o">=</span> <span class="n">band_expr</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                    <span class="n">current_band</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># type: ignore[index]</span>
                    <span class="n">tokens</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                    <span class="n">eigenvalues</span><span class="p">[</span><span class="n">spin</span><span class="p">][</span><span class="n">current_kpoint</span><span class="p">,</span> <span class="n">current_band</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>  <span class="c1"># type: ignore[index]</span>
                    <span class="n">occupancies</span><span class="p">[</span><span class="n">spin</span><span class="p">][</span><span class="n">current_kpoint</span><span class="p">,</span> <span class="n">current_band</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># type: ignore[index]</span>
                    <span class="c1"># keep track of parsed projections for each band (1x w/non-SOC, 4x w/SOC):</span>
                    <span class="n">proj_data_parsed_for_band</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="k">elif</span> <span class="n">headers</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ion_expr</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
                    <span class="n">headers</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                    <span class="n">headers</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">headers</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

                    <span class="n">data</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_kpoints</span><span class="p">,</span> <span class="n">n_bands</span><span class="p">,</span> <span class="n">n_ions</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">headers</span><span class="p">))))</span>
                    <span class="n">phase_factors</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span>
                        <span class="k">lambda</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span>
                            <span class="p">(</span><span class="n">n_kpoints</span><span class="p">,</span> <span class="n">n_bands</span><span class="p">,</span> <span class="n">n_ions</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">headers</span><span class="p">)),</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_soc</span><span class="p">:</span>  <span class="c1"># dict keys are now &quot;x&quot;, &quot;y&quot;, &quot;z&quot; rather than Spin.up/down</span>
                        <span class="n">xyz_data</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_kpoints</span><span class="p">,</span> <span class="n">n_bands</span><span class="p">,</span> <span class="n">n_ions</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">headers</span><span class="p">))))</span>

                <span class="k">elif</span> <span class="n">expr</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
                    <span class="n">tokens</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">headers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;headers is None&quot;</span><span class="p">)</span>
                    <span class="n">num_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">headers</span><span class="p">)]])</span>
                    <span class="k">if</span> <span class="n">phase_factors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;phase_factors is None&quot;</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">proj_data_parsed_for_band</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">data</span><span class="p">[</span><span class="n">spin</span><span class="p">][</span><span class="n">current_kpoint</span><span class="p">,</span> <span class="n">current_band</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">num_data</span>

                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_soc</span> <span class="ow">and</span> <span class="n">proj_data_parsed_for_band</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
                        <span class="n">proj_direction</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="s2">&quot;z&quot;</span><span class="p">}[</span><span class="n">proj_data_parsed_for_band</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">xyz_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">xyz_data</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">xyz_data</span><span class="p">[</span><span class="n">proj_direction</span><span class="p">][</span><span class="n">current_kpoint</span><span class="p">,</span> <span class="n">current_band</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">num_data</span>

                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">headers</span><span class="p">):</span>  <span class="c1"># note no xyz projected phase factors with SOC</span>
                        <span class="c1"># New format of PROCAR (VASP 5.4.4)</span>
                        <span class="n">num_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">[:</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">headers</span><span class="p">)]])</span>
                        <span class="k">for</span> <span class="n">orb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">headers</span><span class="p">)):</span>
                            <span class="n">phase_factors</span><span class="p">[</span><span class="n">spin</span><span class="p">][</span><span class="n">current_kpoint</span><span class="p">,</span> <span class="n">current_band</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">orb</span><span class="p">]</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span>
                                <span class="n">num_data</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">orb</span><span class="p">],</span> <span class="n">num_data</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">orb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                            <span class="p">)</span>
                    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">phase_factors</span><span class="p">[</span><span class="n">spin</span><span class="p">][</span><span class="n">current_kpoint</span><span class="p">,</span> <span class="n">current_band</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
                        <span class="c1"># Old format of PROCAR (VASP 5.4.1 and before)</span>
                        <span class="n">phase_factors</span><span class="p">[</span><span class="n">spin</span><span class="p">][</span><span class="n">current_kpoint</span><span class="p">,</span> <span class="n">current_band</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">num_data</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">phase_factors</span><span class="p">[</span><span class="n">spin</span><span class="p">][</span><span class="n">current_kpoint</span><span class="p">,</span> <span class="n">current_band</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">num_data</span>

                <span class="k">elif</span> <span class="n">total_expr</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
                    <span class="n">proj_data_parsed_for_band</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="k">elif</span> <span class="n">preamble_expr</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
                    <span class="n">match</span> <span class="o">=</span> <span class="n">preamble_expr</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to find preamable pattern, </span><span class="si">{</span><span class="n">match</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">n_kpoints</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">n_bands</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">eigenvalues</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># first spin</span>
                        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_kpoints</span><span class="p">)</span>
                        <span class="n">eigenvalues</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_kpoints</span><span class="p">,</span> <span class="n">n_bands</span><span class="p">)))</span>
                        <span class="n">occupancies</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_kpoints</span><span class="p">,</span> <span class="n">n_bands</span><span class="p">)))</span>
                    <span class="n">n_ions</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">nions</span> <span class="o">!=</span> <span class="n">n_ions</span><span class="p">:</span>  <span class="c1"># parsing multiple PROCARs but nions mismatch!</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mismatch in number of ions in supplied PROCARs: (</span><span class="si">{</span><span class="n">n_ions</span><span class="si">}</span><span class="s2"> vs </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nions</span><span class="si">}</span><span class="s2">)!&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">nions</span> <span class="o">=</span> <span class="n">n_ions</span>  <span class="c1"># attributes that should be consistent between multiple files are set here</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbitals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbitals</span> <span class="o">!=</span> <span class="n">headers</span><span class="p">:</span>  <span class="c1"># multiple PROCARs but orbitals mismatch!</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mismatch in orbital headers in supplied PROCARs: </span><span class="si">{</span><span class="n">headers</span><span class="si">}</span><span class="s2"> vs </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">orbitals</span><span class="si">}</span><span class="s2">!&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">orbitals</span> <span class="o">=</span> <span class="n">headers</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nspins</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">nspins</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>  <span class="c1"># parsing multiple PROCARs but nspins mismatch!</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Mismatch in number of spin channels in supplied PROCARs!&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nspins</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

            <span class="c1"># chop off empty kpoints in arrays and redetermine nkpoints as we may have skipped previously-parsed kpoints</span>
            <span class="n">nkpoints</span> <span class="o">=</span> <span class="n">current_kpoint</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">weights</span><span class="p">[:</span><span class="n">nkpoints</span><span class="p">])</span>  <span class="c1"># type: ignore[index]</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="n">spin</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="n">spin</span><span class="p">][:</span><span class="n">nkpoints</span><span class="p">]</span> <span class="k">for</span> <span class="n">spin</span> <span class="ow">in</span> <span class="n">data</span><span class="p">}</span>  <span class="c1"># type: ignore[index]</span>
            <span class="n">eigenvalues</span> <span class="o">=</span> <span class="p">{</span><span class="n">spin</span><span class="p">:</span> <span class="n">eigenvalues</span><span class="p">[</span><span class="n">spin</span><span class="p">][:</span><span class="n">nkpoints</span><span class="p">]</span> <span class="k">for</span> <span class="n">spin</span> <span class="ow">in</span> <span class="n">eigenvalues</span><span class="p">}</span>  <span class="c1"># type: ignore[union-attr,index]</span>
            <span class="n">occupancies</span> <span class="o">=</span> <span class="p">{</span><span class="n">spin</span><span class="p">:</span> <span class="n">occupancies</span><span class="p">[</span><span class="n">spin</span><span class="p">][:</span><span class="n">nkpoints</span><span class="p">]</span> <span class="k">for</span> <span class="n">spin</span> <span class="ow">in</span> <span class="n">occupancies</span><span class="p">}</span>  <span class="c1"># type: ignore[union-attr,index]</span>
            <span class="n">phase_factors</span> <span class="o">=</span> <span class="p">{</span><span class="n">spin</span><span class="p">:</span> <span class="n">phase_factors</span><span class="p">[</span><span class="n">spin</span><span class="p">][:</span><span class="n">nkpoints</span><span class="p">]</span> <span class="k">for</span> <span class="n">spin</span> <span class="ow">in</span> <span class="n">phase_factors</span><span class="p">}</span>  <span class="c1"># type: ignore[union-attr,index]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_soc</span><span class="p">:</span>
                <span class="n">xyz_data</span> <span class="o">=</span> <span class="p">{</span><span class="n">spin</span><span class="p">:</span> <span class="n">xyz_data</span><span class="p">[</span><span class="n">spin</span><span class="p">][:</span><span class="n">nkpoints</span><span class="p">]</span> <span class="k">for</span> <span class="n">spin</span> <span class="ow">in</span> <span class="n">xyz_data</span><span class="p">}</span>  <span class="c1"># type: ignore[union-attr,index]</span>

            <span class="c1"># Update the parsed kpoints</span>
            <span class="n">parsed_kpoints</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">kvec_spin_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">kvec_spin_tuple</span> <span class="ow">in</span> <span class="n">this_procar_parsed_kpoints</span><span class="p">})</span>

            <span class="k">return</span> <span class="p">(</span>
                <span class="n">kpoints</span><span class="p">,</span>
                <span class="n">weights</span><span class="p">,</span>
                <span class="n">eigenvalues</span><span class="p">,</span>
                <span class="n">occupancies</span><span class="p">,</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="n">phase_factors</span><span class="p">,</span>
                <span class="n">xyz_data</span><span class="p">,</span>
            <span class="p">)</span>

<div class="viewcode-block" id="Procar.get_projection_on_elements">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Procar.get_projection_on_elements">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_projection_on_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="p">:</span> <span class="n">Structure</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Spin</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a dict of projections on elements.</span>

<span class="sd">        Args:</span>
<span class="sd">            structure (Structure): Input structure.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A dict as {Spin: [band index][kpoint index][{Element: values}]].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;data cannot be None.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nkpoints</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nkpoints cannot be None.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbands</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nbands cannot be None.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nions cannot be None.&quot;</span><span class="p">)</span>

        <span class="n">elem_proj</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Spin</span><span class="p">,</span> <span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">spin</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="n">elem_proj</span><span class="p">[</span><span class="n">spin</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nkpoints</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbands</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">iat</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nions</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">species</span><span class="p">[</span><span class="n">iat</span><span class="p">]</span><span class="o">.</span><span class="n">symbol</span>
            <span class="k">for</span> <span class="n">spin</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">kpoint</span><span class="p">,</span> <span class="n">band</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nkpoints</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbands</span><span class="p">)):</span>
                    <span class="n">elem_proj</span><span class="p">[</span><span class="n">spin</span><span class="p">][</span><span class="n">band</span><span class="p">][</span><span class="n">kpoint</span><span class="p">][</span><span class="n">name</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">kpoint</span><span class="p">,</span> <span class="n">band</span><span class="p">,</span> <span class="n">iat</span><span class="p">,</span> <span class="p">:])</span>

        <span class="k">return</span> <span class="n">elem_proj</span></div>


<div class="viewcode-block" id="Procar.get_occupation">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Procar.get_occupation">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_occupation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">orbital</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the occupation for a particular orbital of a particular atom.</span>

<span class="sd">        Args:</span>
<span class="sd">            atom_num (int): Index of atom in the PROCAR. It should be noted</span>
<span class="sd">                that VASP uses 1-based indexing for atoms, but this is</span>
<span class="sd">                converted to 0-based indexing in this parser to be</span>
<span class="sd">                consistent with representation of structures in pymatgen.</span>
<span class="sd">            orbital (str): An orbital. If it is a single character, e.g. s,</span>
<span class="sd">                p, d or f, the sum of all s-type, p-type, d-type or f-type</span>
<span class="sd">                orbitals occupations are returned respectively. If it is a</span>
<span class="sd">                specific orbital, e.g. px, dxy, etc., only the occupation</span>
<span class="sd">                of that orbital is returned.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: Sum occupation of orbital of atom.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbitals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;orbitals is None&quot;</span><span class="p">)</span>
        <span class="n">orbital_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbitals</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">orbital</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;data is None&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="n">spin</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">atom_index</span><span class="p">,</span> <span class="n">orbital_index</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span>  <span class="c1"># type: ignore[call-overload]</span>
            <span class="k">for</span> <span class="n">spin</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span></div>
</div>



<div class="viewcode-block" id="Oszicar">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Oszicar">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Oszicar</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;OSZICAR parser for VASP.</span>

<span class="sd">    In general, while OSZICAR is useful for a quick look at the output from a VASP run,</span>
<span class="sd">    we recommend using the Vasprun parser instead, which gives far richer information.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        electronic_steps (list[list[dict]]): All electronic steps. e.g.</span>
<span class="sd">            [[{&quot;rms&quot;: 160.0, &quot;E&quot;: 4507.24605593, &quot;dE&quot;: 4507.2, &quot;N&quot;: 1, &quot;deps&quot;: -17777.0, &quot;ncg&quot;: 16576}, ...], [....]</span>
<span class="sd">            where electronic_steps[index] refers the list of electronic steps in one ionic_step,</span>
<span class="sd">            electronic_steps[index][subindex] refers to a particular electronic step at subindex in ionic step at</span>
<span class="sd">            index. The dict of properties depends on the type of VASP run, but in general, &quot;E&quot;, &quot;dE&quot; and &quot;rms&quot; should</span>
<span class="sd">            be present in almost all runs.</span>
<span class="sd">        ionic_steps (list[dict[str, float]]): All ionic_steps, e.g.</span>
<span class="sd">            [{&quot;dE&quot;: -526.36, &quot;E0&quot;: -526.36024, &quot;mag&quot;: 0.0, &quot;F&quot;: -526.36024}, ...]</span>
<span class="sd">            This is the typical output from VASP at the end of each ionic step. The stored dict might be different</span>
<span class="sd">            depending on the type of VASP run.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="n">PathLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            filename (PathLike): The file to parse.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">smart_convert</span><span class="p">(</span><span class="n">header</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">num</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="k">if</span> <span class="n">header</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;ncg&quot;</span><span class="p">}</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>

            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;--&quot;</span>

        <span class="n">electronic_steps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ionic_steps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ionic_general_pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\w+)=\s*(\S+)&quot;</span><span class="p">)</span>
        <span class="n">electronic_pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\s*\w+\s*:(.*)&quot;</span><span class="p">)</span>

        <span class="n">header</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="n">zopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;rt&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">file</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">match</span> <span class="o">:=</span> <span class="n">electronic_pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()):</span>
                    <span class="n">tokens</span> <span class="o">=</span> <span class="n">match</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="n">header</span><span class="p">[</span><span class="n">idx</span><span class="p">]:</span> <span class="n">smart_convert</span><span class="p">(</span><span class="n">header</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">tokens</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">))}</span>
                    <span class="k">if</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;1&quot;</span><span class="p">:</span>
                        <span class="n">electronic_steps</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">data</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">electronic_steps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^\s*N\s+E\s*&quot;</span><span class="p">,</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()):</span>
                    <span class="n">header</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;d eps&quot;</span><span class="p">,</span> <span class="s2">&quot;deps&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="k">elif</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                    <span class="c1"># remove space first and apply field agnostic extraction</span>
                    <span class="n">matches</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">ionic_general_pattern</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;d E &quot;</span><span class="p">,</span> <span class="s2">&quot;dE&quot;</span><span class="p">,</span> <span class="n">line</span><span class="p">))</span>
                    <span class="n">ionic_steps</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="n">key</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">})</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">electronic_steps</span> <span class="o">=</span> <span class="n">electronic_steps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ionic_steps</span> <span class="o">=</span> <span class="n">ionic_steps</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">all_energies</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span> <span class="o">|</span> <span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compilation of all energies from all electronic steps and ionic steps</span>
<span class="sd">        as a tuple of list of energies, e.g.</span>
<span class="sd">        ((4507.24605593, 143.824705755, -512.073149912, ...), ...).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_energies</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">electronic_steps</span><span class="p">)):</span>
            <span class="n">energies</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span> <span class="o">|</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">step</span><span class="p">[</span><span class="s2">&quot;E&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">electronic_steps</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="n">energies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ionic_steps</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;F&quot;</span><span class="p">])</span>
            <span class="n">all_energies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">energies</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">all_energies</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@unitized</span><span class="p">(</span><span class="s2">&quot;eV&quot;</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">final_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Final energy from a run.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ionic_steps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;E0&quot;</span><span class="p">]</span>

<div class="viewcode-block" id="Oszicar.as_dict">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Oszicar.as_dict">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;MSONable dict.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;electronic_steps&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">electronic_steps</span><span class="p">,</span>
            <span class="s2">&quot;ionic_steps&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ionic_steps</span><span class="p">,</span>
        <span class="p">}</span></div>
</div>



<div class="viewcode-block" id="VaspParseError">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.VaspParseError">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">VaspParseError</span><span class="p">(</span><span class="n">ParseError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Exception class for VASP parsing.&quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="get_band_structure_from_vasp_multiple_branches">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.get_band_structure_from_vasp_multiple_branches">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_band_structure_from_vasp_multiple_branches</span><span class="p">(</span>
    <span class="n">dir_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">efermi</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">projections</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BandStructureSymmLine</span> <span class="o">|</span> <span class="n">BandStructure</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get band structure info from a VASP directory.</span>

<span class="sd">    It takes into account that a run can be divided in several branches named</span>
<span class="sd">    &quot;branch_x&quot;. If the run has not been divided in branches the method will</span>
<span class="sd">    turn to parsing vasprun.xml directly.</span>

<span class="sd">    Args:</span>
<span class="sd">        dir_name: Directory containing all bandstructure runs.</span>
<span class="sd">        efermi: Efermi for bandstructure.</span>
<span class="sd">        projections: True if you want to get the data on site projections if</span>
<span class="sd">            any. Note that this is sometimes very large</span>

<span class="sd">    Returns:</span>
<span class="sd">        A BandStructure Object.</span>
<span class="sd">        None is there&#39;s a parsing error.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: Add better error handling!!!</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dir_name</span><span class="si">}</span><span class="s2">/branch_0&quot;</span><span class="p">):</span>
        <span class="c1"># Get all branch dir names</span>
        <span class="n">branch_dir_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">glob</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dir_name</span><span class="si">}</span><span class="s2">/branch_*&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">d</span><span class="p">)]</span>

        <span class="c1"># Sort by the directory name (e.g, branch_10)</span>
        <span class="n">sorted_branch_dir_names</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">branch_dir_names</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

        <span class="c1"># Populate branches with Bandstructure instances</span>
        <span class="n">branches</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dname</span> <span class="ow">in</span> <span class="n">sorted_branch_dir_names</span><span class="p">:</span>
            <span class="n">xml_file</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dname</span><span class="si">}</span><span class="s2">/vasprun.xml&quot;</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">xml_file</span><span class="p">):</span>
                <span class="n">run</span> <span class="o">=</span> <span class="n">Vasprun</span><span class="p">(</span><span class="n">xml_file</span><span class="p">,</span> <span class="n">parse_projected_eigen</span><span class="o">=</span><span class="n">projections</span><span class="p">)</span>
                <span class="n">branches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">run</span><span class="o">.</span><span class="n">get_band_structure</span><span class="p">(</span><span class="n">efermi</span><span class="o">=</span><span class="n">efermi</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># TODO: It might be better to throw an exception</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Skipping </span><span class="si">{</span><span class="n">dname</span><span class="si">}</span><span class="s2">. Unable to find </span><span class="si">{</span><span class="n">xml_file</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">get_reconstructed_band_structure</span><span class="p">(</span><span class="n">branches</span><span class="p">,</span> <span class="n">efermi</span><span class="p">)</span>

    <span class="n">xml_file</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dir_name</span><span class="si">}</span><span class="s2">/vasprun.xml&quot;</span>
    <span class="c1"># Better handling of Errors</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">xml_file</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Vasprun</span><span class="p">(</span><span class="n">xml_file</span><span class="p">,</span> <span class="n">parse_projected_eigen</span><span class="o">=</span><span class="n">projections</span><span class="p">)</span><span class="o">.</span><span class="n">get_band_structure</span><span class="p">(</span>
            <span class="n">kpoints_filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">efermi</span><span class="o">=</span><span class="n">efermi</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="Xdatcar">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Xdatcar">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Xdatcar</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;XDATCAR parser. Only tested with VASP 5.x files.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        structures (list[Structure]): Structures parsed from XDATCAR.</span>
<span class="sd">        comment (str): Optional comment.</span>

<span class="sd">    Authors: Ram Balachandran</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filename</span><span class="p">:</span> <span class="n">PathLike</span><span class="p">,</span>
        <span class="n">ionicstep_start</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">ionicstep_end</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">comment</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Init a Xdatcar.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename (PathLike): The XDATCAR file.</span>
<span class="sd">            ionicstep_start (int): Starting index of ionic step.</span>
<span class="sd">            ionicstep_end (int): Ending index of ionic step.</span>
<span class="sd">            comment (str): Optional comment attached to this set of structures.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">preamble</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">coords_str</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">structures</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">preamble_done</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">parse_poscar</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">num_sites</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">restart_preamble</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">ionicstep_start</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Start ionic step cannot be less than 1&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ionicstep_end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ionicstep_end</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;End ionic step cannot be less than 1&quot;</span><span class="p">)</span>

        <span class="n">file_len</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">zopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;rt&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">))</span>
        <span class="n">ionicstep_cnt</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">ionicstep_start</span> <span class="o">=</span> <span class="n">ionicstep_start</span> <span class="ow">or</span> <span class="mi">0</span>
        <span class="k">with</span> <span class="n">zopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;rt&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">iline</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">file</span><span class="p">):</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">preamble</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">preamble</span> <span class="o">=</span> <span class="p">[</span><span class="n">line</span><span class="p">]</span>
                    <span class="n">title</span> <span class="o">=</span> <span class="n">line</span>

                <span class="k">elif</span> <span class="n">title</span> <span class="o">==</span> <span class="n">line</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords_str</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># sometimes the title is the same as the only chemical species in the structure</span>
                    <span class="c1"># only enter this block if the coords have been read</span>
                    <span class="n">parse_poscar</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">restart_preamble</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">preamble_done</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="k">elif</span> <span class="ow">not</span> <span class="n">preamble_done</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">line</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="ow">or</span> <span class="s2">&quot;Direct configuration=&quot;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                        <span class="n">preamble_done</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">preamble</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

                <span class="k">elif</span> <span class="n">line</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="ow">or</span> <span class="p">(</span><span class="s2">&quot;Direct configuration=&quot;</span> <span class="ow">in</span> <span class="n">line</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords_str</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="n">parse_poscar</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">restart_preamble</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">coords_str</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">parse_poscar</span> <span class="ow">and</span> <span class="p">(</span><span class="n">num_sites</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords_str</span><span class="p">)</span> <span class="o">==</span> <span class="n">num_sites</span><span class="p">))</span> <span class="ow">or</span> <span class="n">iline</span> <span class="o">==</span> <span class="n">file_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">num_sites</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">num_sites</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords_str</span><span class="p">)</span>

                    <span class="n">poscar</span> <span class="o">=</span> <span class="n">Poscar</span><span class="o">.</span><span class="n">from_str</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="o">*</span><span class="n">preamble</span><span class="p">,</span> <span class="s2">&quot;Direct&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">coords_str</span><span class="p">]))</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">ionicstep_end</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ionicstep_cnt</span> <span class="o">&gt;=</span> <span class="n">ionicstep_start</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                        <span class="n">ionicstep_end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ionicstep_start</span> <span class="o">&lt;=</span> <span class="n">ionicstep_cnt</span> <span class="o">&lt;</span> <span class="n">ionicstep_end</span>
                    <span class="p">):</span>
                        <span class="n">structures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poscar</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="p">(</span><span class="n">ionicstep_end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">ionicstep_cnt</span> <span class="o">&gt;=</span> <span class="n">ionicstep_end</span><span class="p">:</span>
                        <span class="k">break</span>

                    <span class="n">ionicstep_cnt</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">coords_str</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">parse_poscar</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">if</span> <span class="n">restart_preamble</span><span class="p">:</span>
                        <span class="n">preamble</span> <span class="o">=</span> <span class="p">[</span><span class="n">line</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">preamble</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;preamble is None&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">structures</span> <span class="o">=</span> <span class="n">structures</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comment</span> <span class="o">=</span> <span class="n">comment</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">structures</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">formula</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_str</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">site_symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sequence of symbols associated with the Xdatcar.</span>
<span class="sd">        Similar to 6th line in VASP 5+ Xdatcar.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">syms</span> <span class="o">=</span> <span class="p">[</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">symbol</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">structures</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">syms</span><span class="p">)]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">natoms</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sequence of number of sites of each type associated with the Poscar.</span>
<span class="sd">        Similar to 7th line in VASP 5+ Xdatcar.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">syms</span> <span class="o">=</span> <span class="p">[</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">symbol</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">structures</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">return</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">syms</span><span class="p">)]</span>

<div class="viewcode-block" id="Xdatcar.concatenate">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Xdatcar.concatenate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">concatenate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filename</span><span class="p">:</span> <span class="n">PathLike</span><span class="p">,</span>
        <span class="n">ionicstep_start</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">ionicstep_end</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Concatenate structures in file to Xdatcar.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename (PathLike): The XDATCAR file to be concatenated.</span>
<span class="sd">            ionicstep_start (int): Starting number of ionic step.</span>
<span class="sd">            ionicstep_end (int): Ending number of ionic step.</span>

<span class="sd">        TODO (rambalachandran): Check to ensure the new concatenating file</span>
<span class="sd">            has the same lattice structure and atoms as the Xdatcar class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">preamble</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">coords_str</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">structures</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">structures</span>
        <span class="n">preamble_done</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">ionicstep_start</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Start ionic step cannot be less than 1&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ionicstep_end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ionicstep_end</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;End ionic step cannot be less than 1&quot;</span><span class="p">)</span>

        <span class="n">ionicstep_cnt</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">with</span> <span class="n">zopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;rt&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">file</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">preamble</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">preamble</span> <span class="o">=</span> <span class="p">[</span><span class="n">line</span><span class="p">]</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">preamble_done</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">line</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="ow">or</span> <span class="s2">&quot;Direct configuration=&quot;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                        <span class="n">preamble_done</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">tmp_preamble</span> <span class="o">=</span> <span class="p">[</span><span class="n">preamble</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">preamble</span><span class="p">)):</span>
                            <span class="k">if</span> <span class="n">preamble</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">preamble</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                                <span class="n">tmp_preamble</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">preamble</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">break</span>
                        <span class="n">preamble</span> <span class="o">=</span> <span class="n">tmp_preamble</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">preamble</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">line</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="ow">or</span> <span class="s2">&quot;Direct configuration=&quot;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                    <span class="n">poscar</span> <span class="o">=</span> <span class="n">Poscar</span><span class="o">.</span><span class="n">from_str</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="o">*</span><span class="n">preamble</span><span class="p">,</span> <span class="s2">&quot;Direct&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">coords_str</span><span class="p">]))</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">ionicstep_end</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ionicstep_cnt</span> <span class="o">&gt;=</span> <span class="n">ionicstep_start</span>
                    <span class="p">)</span> <span class="ow">or</span> <span class="n">ionicstep_start</span> <span class="o">&lt;=</span> <span class="n">ionicstep_cnt</span> <span class="o">&lt;</span> <span class="n">ionicstep_end</span><span class="p">:</span>
                        <span class="n">structures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poscar</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span>
                    <span class="n">ionicstep_cnt</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">coords_str</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">coords_str</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">preamble</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;preamble is None&quot;</span><span class="p">)</span>
            <span class="n">poscar</span> <span class="o">=</span> <span class="n">Poscar</span><span class="o">.</span><span class="n">from_str</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="o">*</span><span class="n">preamble</span><span class="p">,</span> <span class="s2">&quot;Direct&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">coords_str</span><span class="p">]))</span>

            <span class="k">if</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">ionicstep_end</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ionicstep_cnt</span> <span class="o">&gt;=</span> <span class="n">ionicstep_start</span><span class="p">)</span>
                <span class="ow">or</span> <span class="n">ionicstep_start</span> <span class="o">&lt;=</span> <span class="n">ionicstep_cnt</span> <span class="o">&lt;</span> <span class="n">ionicstep_end</span>  <span class="c1"># type: ignore[operator]</span>
            <span class="p">):</span>
                <span class="n">structures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poscar</span><span class="o">.</span><span class="n">structure</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">structures</span> <span class="o">=</span> <span class="n">structures</span></div>


<div class="viewcode-block" id="Xdatcar.get_str">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Xdatcar.get_str">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_str</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ionicstep_start</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">ionicstep_end</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">significant_figures</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get Xdatcar as a string.</span>

<span class="sd">        Args:</span>
<span class="sd">            ionicstep_start (int): Starting index of ionic step.</span>
<span class="sd">            ionicstep_end (int): Ending index of ionic step.</span>
<span class="sd">            significant_figures (int): Number of significant digits.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: Xdatcar as a string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ionicstep_start</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Start ionic step cannot be less than 1&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ionicstep_end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ionicstep_end</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;End ionic step cannot be less than 1&quot;</span><span class="p">)</span>

        <span class="n">lattice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">structures</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lattice</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">lattice</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lattice</span> <span class="o">=</span> <span class="n">Lattice</span><span class="p">(</span><span class="o">-</span><span class="n">lattice</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">comment</span><span class="p">,</span> <span class="s2">&quot;1.0&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">lattice</span><span class="p">)]</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">site_symbols</span><span class="p">),</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">natoms</span><span class="p">))))</span>

        <span class="n">format_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">{{</span><span class="s2">:.</span><span class="si">{</span><span class="n">significant_figures</span><span class="si">}</span><span class="s2">f</span><span class="se">}}</span><span class="s2">&quot;</span>
        <span class="n">ionicstep_cnt</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">output_cnt</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">structure</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structures</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">ionicstep_cnt</span> <span class="o">=</span> <span class="n">cnt</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">ionicstep_end</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ionicstep_cnt</span> <span class="o">&gt;=</span> <span class="n">ionicstep_start</span><span class="p">)</span>
                <span class="ow">or</span> <span class="n">ionicstep_start</span> <span class="o">&lt;=</span> <span class="n">ionicstep_cnt</span> <span class="o">&lt;</span> <span class="n">ionicstep_end</span>  <span class="c1"># type: ignore[operator]</span>
            <span class="p">):</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Direct configuration=</span><span class="si">{</span><span class="s1">&#39; &#39;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">7</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">output_cnt</span><span class="p">)))</span><span class="si">}{</span><span class="n">output_cnt</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">structure</span><span class="p">:</span>
                    <span class="n">coords</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">frac_coords</span>
                    <span class="n">line</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">format_str</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">)</span>
                    <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                <span class="n">output_cnt</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span></div>


<div class="viewcode-block" id="Xdatcar.write_file">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Xdatcar.write_file">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="n">PathLike</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write Xdatcar into a file.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename (PathLike): The output XDATCAR file.</span>
<span class="sd">            **kwargs: The same as those for the Xdatcar.get_str</span>
<span class="sd">                method and are passed through directly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">zopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;wt&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_str</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">))</span></div>
</div>



<div class="viewcode-block" id="Dynmat">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Dynmat">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Dynmat</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;DYNMAT file reader.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        data (dict): A nested dict containing the DYNMAT data of the form:</span>
<span class="sd">            [atom &lt;int&gt;][disp &lt;int&gt;][&#39;dispvec&#39;] =</span>
<span class="sd">                displacement vector (part of first line in dynmat block, e.g. &quot;0.01 0 0&quot;)</span>
<span class="sd">            [atom &lt;int&gt;][disp &lt;int&gt;][&#39;dynmat&#39;] =</span>
<span class="sd">                &lt;list&gt; list of dynmat lines for this atom and this displacement</span>

<span class="sd">    Authors: Patrick Huck</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="n">PathLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            filename: Name of file containing DYNMAT.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">zopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;rt&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">clean_lines</span><span class="p">(</span><span class="n">file</span><span class="o">.</span><span class="n">readlines</span><span class="p">()))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nspecs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_natoms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ndisps</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_masses</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">lines</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
            <span class="n">atom</span><span class="p">,</span> <span class="n">disp</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="mi">2</span><span class="p">:]):</span>
                <span class="n">v</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">idx</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_natoms</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">atom</span><span class="p">,</span> <span class="n">disp</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">v</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">atom</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">atom</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="k">if</span> <span class="n">disp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">atom</span><span class="p">]:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">atom</span><span class="p">][</span><span class="n">disp</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">atom</span><span class="p">][</span><span class="n">disp</span><span class="p">][</span><span class="s2">&quot;dispvec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s2">&quot;dynmat&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">atom</span><span class="p">][</span><span class="n">disp</span><span class="p">]:</span>  <span class="c1"># type: ignore[index]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">atom</span><span class="p">][</span><span class="n">disp</span><span class="p">][</span><span class="s2">&quot;dynmat&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># type: ignore[index]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">atom</span><span class="p">][</span><span class="n">disp</span><span class="p">][</span><span class="s2">&quot;dynmat&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>  <span class="c1"># type: ignore[index]</span>

<div class="viewcode-block" id="Dynmat.get_phonon_frequencies">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Dynmat.get_phonon_frequencies">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_phonon_frequencies</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate phonon frequencies.</span>

<span class="sd">        WARNING: This method is most likely incorrect or suboptimal,</span>
<span class="sd">            hence for demonstration purposes only.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[float]: phonon frequencies.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">frequencies</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v0</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">v1</span> <span class="ow">in</span> <span class="n">v0</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">vec</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">abs</span><span class="p">,</span> <span class="n">v1</span><span class="p">[</span><span class="s2">&quot;dynmat&quot;</span><span class="p">][</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">frequency</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">vec</span><span class="p">))</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">15.633302</span>  <span class="c1"># THz</span>
                <span class="n">frequencies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frequency</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">frequencies</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nspecs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The number of species.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspecs</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">natoms</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The number of atoms.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_natoms</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ndisps</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The number of displacements.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ndisps</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">masses</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The list of atomic masses.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_masses</span><span class="p">)</span></div>



<div class="viewcode-block" id="get_adjusted_fermi_level">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.get_adjusted_fermi_level">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_adjusted_fermi_level</span><span class="p">(</span>
    <span class="n">efermi</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">cbm</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">band_structure</span><span class="p">:</span> <span class="n">BandStructureSymmLine</span><span class="p">,</span>
    <span class="n">energy_step</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    When running a band structure computation, the Fermi level needs to be</span>
<span class="sd">    taken from the static run that gave the charge density used for the non-self</span>
<span class="sd">    consistent band structure run. Sometimes this Fermi level is too low</span>
<span class="sd">    because of the mismatch between the uniform grid used in the static run</span>
<span class="sd">    and the band structure k-points (e.g., the VBM is on Gamma and the Gamma</span>
<span class="sd">    point is not in the uniform mesh).</span>

<span class="sd">    Here we use a procedure looking for energy levels higher than the static</span>
<span class="sd">    Fermi level and lower than the LUMO. If any of these levels make the</span>
<span class="sd">    band structure appears insulating (not metallic anymore), we keep this</span>
<span class="sd">    adjusted fermi level.</span>

<span class="sd">    This procedure has shown to detect most insulators correctly.</span>

<span class="sd">    Args:</span>
<span class="sd">        efermi (float): The Fermi energy of the static run.</span>
<span class="sd">        cbm (float): The conduction band minimum of the static run.</span>
<span class="sd">        band_structure (BandStructureSymmLine): A band structure object.</span>
<span class="sd">        energy_step (float): The step length for increasing energy during search.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: A new adjusted Fermi level.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Make a working copy of band_structure</span>
    <span class="n">bs_working</span> <span class="o">=</span> <span class="n">BandStructureSymmLine</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">band_structure</span><span class="o">.</span><span class="n">as_dict</span><span class="p">())</span>

    <span class="k">if</span> <span class="n">bs_working</span><span class="o">.</span><span class="n">is_metal</span><span class="p">():</span>
        <span class="n">energy</span> <span class="o">=</span> <span class="n">efermi</span>
        <span class="k">while</span> <span class="n">energy</span> <span class="o">&lt;</span> <span class="n">cbm</span><span class="p">:</span>
            <span class="n">energy</span> <span class="o">+=</span> <span class="n">energy_step</span>
            <span class="n">bs_working</span><span class="o">.</span><span class="n">_efermi</span> <span class="o">=</span> <span class="n">energy</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">bs_working</span><span class="o">.</span><span class="n">is_metal</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">energy</span>
    <span class="k">return</span> <span class="n">efermi</span></div>



<span class="c1"># A note to future confused people (i.e. myself):</span>
<span class="c1"># I use numpy.fromfile instead of scipy.io.FortranFile here because the records</span>
<span class="c1"># are of fixed length, so the record length is only written once. In fortran,</span>
<span class="c1"># this amounts to using open(..., form=&#39;unformatted&#39;, recl=recl_len). In</span>
<span class="c1"># contrast when you write UNK files, the record length is written at the</span>
<span class="c1"># beginning of each record. This allows you to use scipy.io.FortranFile. In</span>
<span class="c1"># fortran, this amounts to using open(..., form=&#39;unformatted&#39;) [i.e. no recl=].</span>
<div class="viewcode-block" id="Wavecar">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Wavecar">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Wavecar</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Container for the (pseudo-) wavefunctions from VASP.</span>

<span class="sd">    Coefficients are read from the given WAVECAR file and the corresponding</span>
<span class="sd">    G-vectors are generated using the algorithm developed in WaveTrans (see</span>
<span class="sd">    acknowledgments below). To understand how the wavefunctions are evaluated,</span>
<span class="sd">    please see the evaluate_wavefunc docstring.</span>

<span class="sd">    It should be noted that the pseudopotential augmentation is not included in</span>
<span class="sd">    the WAVECAR file. As a result, some caution should be exercised when</span>
<span class="sd">    deriving value from this information.</span>

<span class="sd">    The usefulness of this class is to allow the user to do projections or band</span>
<span class="sd">    unfolding style manipulations of the wavefunction. An example of this can</span>
<span class="sd">    be seen in the work of Shen et al. 2017</span>
<span class="sd">    (https://doi.org/10.1103/PhysRevMaterials.1.065001).</span>

<span class="sd">    Attributes:</span>
<span class="sd">        vasp_type (&quot;std&quot; | &quot;gam&quot; | &quot;ncl&quot;): The VASP type WAVECAR was generated with.</span>
<span class="sd">        nk (int): Number of k-points from the WAVECAR.</span>
<span class="sd">        nb (int): Number of bands per k-point.</span>
<span class="sd">        encut (float): Energy cutoff (used to define G_{cut}).</span>
<span class="sd">        efermi (float): Fermi energy.</span>
<span class="sd">        a (NDArray): Primitive lattice vectors of the cell (e.g. a_1 = self.a[0, :]).</span>
<span class="sd">        b (NDArray): Reciprocal lattice vectors of the cell (e.g. b_1 = self.b[0, :]).</span>
<span class="sd">        vol (float): The volume of the unit cell in real space.</span>
<span class="sd">        kpoints (NDArray): A list of k-points read from the WAVECAR file.</span>
<span class="sd">        band_energy (list): A list of band eigenenergies (and corresponding occupancies) for each kpoint,</span>
<span class="sd">            where the first index corresponds to the index of the k-point (e.g. self.band_energy[kp]).</span>
<span class="sd">        Gpoints (list): A list of generated G-points for each k-point (a double list), which</span>
<span class="sd">            are used with the coefficients for each k-point and band to recreate</span>
<span class="sd">            the wavefunction (e.g. self.Gpoints[kp] is the list of G-points for</span>
<span class="sd">            k-point kp). The G-points depend on the k-point and reciprocal lattice</span>
<span class="sd">            and therefore are identical for each band at the same k-point. Each</span>
<span class="sd">            G-point is represented by integer multipliers (e.g. assuming</span>
<span class="sd">            Gpoints[kp][n] == [n_1, n_2, n_3], then</span>
<span class="sd">            G_n = n_1*b_1 + n_2*b_2 + n_3*b_3)</span>
<span class="sd">        coeffs (list): A list of coefficients for each k-point and band for reconstructing the wavefunction.</span>
<span class="sd">            For non-spin-polarized, the first index corresponds to the kpoint and the second corresponds to the band</span>
<span class="sd">            (e.g. self.coeffs[kp][b] corresponds to k-point kp and band b). For spin-polarized calculations,</span>
<span class="sd">            the first index is for the spin. If the calculation was non-collinear, then self.coeffs[kp][b] will have</span>
<span class="sd">            two columns (one for each component of the spinor).</span>

<span class="sd">    Acknowledgments:</span>
<span class="sd">        This code is based upon the Fortran program, WaveTrans, written by</span>
<span class="sd">        R. M. Feenstra and M. Widom from the Dept. of Physics at Carnegie</span>
<span class="sd">        Mellon University. To see the original work, please visit:</span>
<span class="sd">        https://www.andrew.cmu.edu/user/feenstra/wavetrans/</span>

<span class="sd">    Author: Mark Turiansky</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filename</span><span class="p">:</span> <span class="n">PathLike</span> <span class="o">=</span> <span class="s2">&quot;WAVECAR&quot;</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">precision</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;normal&quot;</span><span class="p">,</span> <span class="s2">&quot;accurate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;normal&quot;</span><span class="p">,</span>
        <span class="n">vasp_type</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;std&quot;</span><span class="p">,</span> <span class="s2">&quot;gam&quot;</span><span class="p">,</span> <span class="s2">&quot;ncl&quot;</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract information from the given WAVECAR.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename (PathLike): input file. Defaults to WAVECAR.</span>
<span class="sd">            verbose (bool): determines whether processing information is shown</span>
<span class="sd">            precision (str): determines how fine the fft mesh is (normal or</span>
<span class="sd">                accurate), only the first letter matters.</span>
<span class="sd">            vasp_type (str): determines the VASP type that is used, allowed</span>
<span class="sd">                values are {&#39;std&#39;, &#39;gam&#39;, &#39;ncl&#39;} (only first letter is required).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span>
        <span class="n">valid_types</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;std&quot;</span><span class="p">,</span> <span class="s2">&quot;gam&quot;</span><span class="p">,</span> <span class="s2">&quot;ncl&quot;</span><span class="p">}</span>
        <span class="n">initials</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">valid_types</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">vasp_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">vasp_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">initials</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;invalid </span><span class="si">{</span><span class="n">vasp_type</span><span class="si">=}</span><span class="s2">, must be one of </span><span class="si">{</span><span class="n">valid_types</span><span class="si">}</span><span class="s2"> (we only check the first letter </span><span class="si">{</span><span class="n">initials</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vasp_type</span> <span class="o">=</span> <span class="n">vasp_type</span>

        <span class="c1"># c = 0.26246582250210965422</span>
        <span class="c1"># 2m/hbar^2 in agreement with VASP</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_C</span> <span class="o">=</span> <span class="mf">0.262465831</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="c1"># Read the header information</span>
            <span class="n">recl</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">rtag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">recl</span><span class="si">=}</span><span class="s2">, </span><span class="si">{</span><span class="n">spin</span><span class="si">=}</span><span class="s2">, </span><span class="si">{</span><span class="n">rtag</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">recl8</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">recl</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spin</span> <span class="o">=</span> <span class="n">spin</span>

            <span class="c1"># Make sure we have correct precision</span>
            <span class="n">valid_rtags</span> <span class="o">=</span> <span class="p">{</span><span class="mi">45200</span><span class="p">,</span> <span class="mi">45210</span><span class="p">,</span> <span class="mi">53300</span><span class="p">,</span> <span class="mi">53310</span><span class="p">}</span>
            <span class="k">if</span> <span class="n">rtag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_rtags</span><span class="p">:</span>
                <span class="c1"># note that rtag=45200 and 45210 may not work if file was actually</span>
                <span class="c1"># generated by old version of VASP, since that would write eigenvalues</span>
                <span class="c1"># and occupations in way that does not span FORTRAN records, but</span>
                <span class="c1"># reader below appears to assume that record boundaries can be ignored</span>
                <span class="c1"># (see OUTWAV vs. OUTWAV_4 in VASP fileio.F)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid </span><span class="si">{</span><span class="n">rtag</span><span class="si">=}</span><span class="s2">, must be one of </span><span class="si">{</span><span class="n">valid_rtags</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Pad to end of fortran REC=1</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">recl8</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span>

            <span class="c1"># Extract kpoint, bands, energy, and lattice information</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nk</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">encut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">efermi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;kpoints = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nk</span><span class="si">}</span><span class="s2">, bands = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nb</span><span class="si">}</span><span class="s2">, energy cutoff = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">encut</span><span class="si">}</span><span class="s2">, fermi &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;energy= </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">efermi</span><span class="si">:</span><span class="s2">.04f</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;primitive lattice vectors = </span><span class="se">\n</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">vol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]))</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;volume = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Calculate reciprocal lattice</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]),</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">b</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">vol</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">b</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;reciprocal lattice vectors = </span><span class="se">\n</span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;reciprocal lattice vector magnitudes = </span><span class="se">\n</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Calculate maximum number of b vectors in each direction</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_generate_nbmax</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;max number of G values = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_nbmax</span><span class="si">}</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ng</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nbmax</span> <span class="o">*</span> <span class="mi">3</span> <span class="k">if</span> <span class="n">precision</span><span class="o">.</span><span class="n">lower</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;n&quot;</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nbmax</span> <span class="o">*</span> <span class="mi">4</span>

            <span class="c1"># Pad to end of fortran REC=2</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">recl8</span> <span class="o">-</span> <span class="mi">13</span><span class="p">)</span>

            <span class="c1"># Read records</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Gpoints</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nk</span><span class="p">)]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kpoints</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">spin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coeffs</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="kc">None</span><span class="p">]]]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="kc">None</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">[[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nb</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nk</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">spin</span><span class="p">)</span>
                <span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">band_energy</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">spin</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coeffs</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nb</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nk</span><span class="p">)]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">band_energy</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">i_spin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">spin</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Reading spin </span><span class="si">{</span><span class="n">i_spin</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">i_nk</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nk</span><span class="p">):</span>
                    <span class="c1"># Information for this kpoint</span>
                    <span class="n">nplane</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">kpoint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">i_spin</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">kpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kpoint</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kpoints</span><span class="p">[</span><span class="n">i_nk</span><span class="p">],</span> <span class="n">kpoint</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;kpoints of </span><span class="si">{</span><span class="n">i_nk</span><span class="si">=}</span><span class="s2"> mismatch&quot;</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;kpoint </span><span class="si">{</span><span class="n">i_nk</span><span class="si">:</span><span class="s2"> 4</span><span class="si">}</span><span class="s2"> with </span><span class="si">{</span><span class="n">nplane</span><span class="si">:</span><span class="s2"> 5</span><span class="si">}</span><span class="s2"> plane waves at </span><span class="si">{</span><span class="n">kpoint</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="c1"># Energy and occupation information</span>
                    <span class="n">enocc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">3</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nb</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">spin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">band_energy</span><span class="p">[</span><span class="n">i_spin</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">enocc</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">band_energy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">enocc</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;enocc =</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">enocc</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>

                    <span class="c1"># Pad the end of record that contains nplane, kpoints, evals and occs</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="p">(</span><span class="n">recl8</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb</span><span class="p">)</span> <span class="o">%</span> <span class="n">recl8</span><span class="p">)</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vasp_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Gpoints</span><span class="p">[</span><span class="n">i_nk</span><span class="p">],</span> <span class="n">extra_gpoints</span><span class="p">,</span> <span class="n">extra_coeff_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_G_points</span><span class="p">(</span>  <span class="c1"># type: ignore[call-overload]</span>
                            <span class="n">kpoint</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="kc">True</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gpoints</span><span class="p">[</span><span class="n">i_nk</span><span class="p">])</span> <span class="o">==</span> <span class="n">nplane</span><span class="p">:</span>  <span class="c1"># type: ignore[arg-type]</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">vasp_type</span> <span class="o">=</span> <span class="s2">&quot;gam&quot;</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">Gpoints</span><span class="p">[</span><span class="n">i_nk</span><span class="p">],</span> <span class="n">extra_gpoints</span><span class="p">,</span> <span class="n">extra_coeff_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_G_points</span><span class="p">(</span>  <span class="c1"># type: ignore[call-overload]</span>
                                <span class="n">kpoint</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="kc">False</span>
                            <span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">vasp_type</span> <span class="o">=</span> <span class="s2">&quot;std&quot;</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gpoints</span><span class="p">[</span><span class="n">i_nk</span><span class="p">])</span> <span class="o">==</span> <span class="n">nplane</span> <span class="k">else</span> <span class="s2">&quot;ncl&quot;</span>  <span class="c1"># type: ignore[arg-type]</span>

                        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">determined </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">vasp_type</span><span class="w"> </span><span class="si">= }</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Gpoints</span><span class="p">[</span><span class="n">i_nk</span><span class="p">],</span> <span class="n">extra_gpoints</span><span class="p">,</span> <span class="n">extra_coeff_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_G_points</span><span class="p">(</span>  <span class="c1"># type: ignore[call-overload]</span>
                            <span class="n">kpoint</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vasp_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;g&quot;</span>
                        <span class="p">)</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gpoints</span><span class="p">[</span><span class="n">i_nk</span><span class="p">])</span> <span class="o">!=</span> <span class="n">nplane</span> <span class="ow">and</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gpoints</span><span class="p">[</span><span class="n">i_nk</span><span class="p">])</span> <span class="o">!=</span> <span class="n">nplane</span><span class="p">:</span>  <span class="c1"># type: ignore[arg-type]</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Incorrect </span><span class="si">{</span><span class="n">vasp_type</span><span class="si">=}</span><span class="s2">. Please open an issue if you are certain this WAVECAR&quot;</span>
                            <span class="s2">&quot; was generated with the given vasp_type.&quot;</span>
                        <span class="p">)</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">Gpoints</span><span class="p">[</span><span class="n">i_nk</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gpoints</span><span class="p">[</span><span class="n">i_nk</span><span class="p">]</span> <span class="o">+</span> <span class="n">extra_gpoints</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type, operator]</span>

                    <span class="c1"># Extract coefficients</span>
                    <span class="k">for</span> <span class="n">inb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nb</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">rtag</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">45200</span><span class="p">,</span> <span class="mi">53300</span><span class="p">):</span>
                            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">nplane</span><span class="p">)</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">recl8</span> <span class="o">-</span> <span class="n">nplane</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">rtag</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">45210</span><span class="p">,</span> <span class="mi">53310</span><span class="p">):</span>
                            <span class="c1"># TODO: This should handle double precision coefficients,</span>
                            <span class="c1"># but I don&#39;t have a WAVECAR to test it with</span>
                            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">nplane</span><span class="p">)</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">recl8</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nplane</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Invalid rtag value.&quot;</span><span class="p">)</span>

                        <span class="n">extra_coeffs</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">extra_coeff_inds</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="c1"># Reconstruct extra coefficients missing from gamma-only executable WAVECAR</span>
                            <span class="k">for</span> <span class="n">G_ind</span> <span class="ow">in</span> <span class="n">extra_coeff_inds</span><span class="p">:</span>
                                <span class="c1"># No idea where this factor of sqrt(2) comes from,</span>
                                <span class="c1"># but empirically it appears to be necessary</span>
                                <span class="n">data</span><span class="p">[</span><span class="n">G_ind</span><span class="p">]</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                                <span class="n">extra_coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">G_ind</span><span class="p">]))</span>

                        <span class="k">if</span> <span class="n">spin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">coeffs</span><span class="p">[</span><span class="n">i_spin</span><span class="p">][</span><span class="n">i_nk</span><span class="p">][</span><span class="n">inb</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">+</span> <span class="n">extra_coeffs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>  <span class="c1"># type: ignore[index]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">coeffs</span><span class="p">[</span><span class="n">i_nk</span><span class="p">][</span><span class="n">inb</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">+</span> <span class="n">extra_coeffs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>

                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vasp_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">vasp_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;n&quot;</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">coeffs</span><span class="p">[</span><span class="n">i_nk</span><span class="p">][</span><span class="n">inb</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">nplane</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># type: ignore[union-attr]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_generate_nbmax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Helper function to determine maximum number of b vectors for</span>
<span class="sd">        each direction.</span>

<span class="sd">        This algorithm is adapted from WaveTrans (see Class docstring).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bmag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span>

        <span class="c1"># Calculate maximum integers in each direction for G</span>
        <span class="n">phi12</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span> <span class="o">/</span> <span class="p">(</span><span class="n">bmag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">bmag</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">sphi123</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:],</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]))</span> <span class="o">/</span> <span class="p">(</span><span class="n">bmag</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])))</span>
        <span class="n">nbmaxA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">encut</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_C</span><span class="p">)</span> <span class="o">/</span> <span class="n">bmag</span>
        <span class="n">nbmaxA</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi12</span><span class="p">))</span>
        <span class="n">nbmaxA</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi12</span><span class="p">))</span>
        <span class="n">nbmaxA</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sphi123</span><span class="p">)</span>
        <span class="n">nbmaxA</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">phi13</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span> <span class="o">/</span> <span class="p">(</span><span class="n">bmag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">bmag</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="n">sphi123</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]))</span> <span class="o">/</span> <span class="p">(</span><span class="n">bmag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])))</span>
        <span class="n">nbmaxB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">encut</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_C</span><span class="p">)</span> <span class="o">/</span> <span class="n">bmag</span>
        <span class="n">nbmaxB</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi13</span><span class="p">))</span>
        <span class="n">nbmaxB</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sphi123</span><span class="p">)</span>
        <span class="n">nbmaxB</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi13</span><span class="p">))</span>
        <span class="n">nbmaxB</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">phi23</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span> <span class="o">/</span> <span class="p">(</span><span class="n">bmag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">bmag</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="n">sphi123</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]))</span> <span class="o">/</span> <span class="p">(</span><span class="n">bmag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])))</span>
        <span class="n">nbmaxC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">encut</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_C</span><span class="p">)</span> <span class="o">/</span> <span class="n">bmag</span>
        <span class="n">nbmaxC</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sphi123</span><span class="p">)</span>
        <span class="n">nbmaxC</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi23</span><span class="p">))</span>
        <span class="n">nbmaxC</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi23</span><span class="p">))</span>
        <span class="n">nbmaxC</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_nbmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">nbmaxA</span><span class="p">,</span> <span class="n">nbmaxB</span><span class="p">,</span> <span class="n">nbmaxC</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_generate_G_points</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">kpoint</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span>
        <span class="n">gamma</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">list</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Helper method to generate G-points based on nbmax.</span>

<span class="sd">        This function iterates over possible G-point values and determines</span>
<span class="sd">        if the energy is less than G_{cut}. Valid values are appended to</span>
<span class="sd">        the output array. This function should not be called outside of</span>
<span class="sd">        initialization.</span>

<span class="sd">        Args:</span>
<span class="sd">            kpoint (NDArray): The current k-point value.</span>
<span class="sd">            gamma (bool): determines if G points for gamma-point only executable</span>
<span class="sd">                          should be generated.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple[list, list, list]: Valid G-points</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nbmax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">gamma</span> <span class="k">else</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nbmax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">gpoints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">extra_gpoints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">extra_coeff_inds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">G_ind</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nbmax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">i3</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nbmax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nbmax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">else</span> <span class="n">i</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nbmax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">j2</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nbmax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nbmax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">else</span> <span class="n">j</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">kmax</span><span class="p">):</span>
                    <span class="n">k1</span> <span class="o">=</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nbmax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nbmax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">else</span> <span class="n">k</span>
                    <span class="k">if</span> <span class="n">gamma</span> <span class="ow">and</span> <span class="p">((</span><span class="n">k1</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">j2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">k1</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">j2</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i3</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)):</span>
                        <span class="k">continue</span>
                    <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k1</span><span class="p">,</span> <span class="n">j2</span><span class="p">,</span> <span class="n">i3</span><span class="p">])</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">kpoint</span> <span class="o">+</span> <span class="n">G</span>
                    <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">))</span>
                    <span class="n">E</span> <span class="o">=</span> <span class="n">g</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_C</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">encut</span> <span class="o">&gt;</span> <span class="n">E</span><span class="p">:</span>
                        <span class="n">gpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">gamma</span> <span class="ow">and</span> <span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">j2</span><span class="p">,</span> <span class="n">i3</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
                            <span class="n">extra_gpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">G</span><span class="p">)</span>
                            <span class="n">extra_coeff_inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">G_ind</span><span class="p">)</span>
                        <span class="n">G_ind</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">gpoints</span><span class="p">,</span> <span class="n">extra_gpoints</span><span class="p">,</span> <span class="n">extra_coeff_inds</span>

<div class="viewcode-block" id="Wavecar.evaluate_wavefunc">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Wavecar.evaluate_wavefunc">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">evaluate_wavefunc</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">kpoint</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">band</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">r</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span>
        <span class="n">spin</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">spinor</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Evaluate the wavefunction for a given position, r.</span>

<span class="sd">        The wavefunction is given by the k-point and band. It is evaluated</span>
<span class="sd">        at the given position by summing over the components. Formally,</span>

<span class="sd">        \psi_n^k (r) = \sum_{i=1}^N c_i^{n,k} \exp (i (k + G_i^{n,k}) \cdot r)</span>

<span class="sd">        where \psi_n^k is the wavefunction for the nth band at k-point k, N is</span>
<span class="sd">        the number of plane waves, c_i^{n,k} is the ith coefficient that</span>
<span class="sd">        corresponds to the nth band and k-point k, and G_i^{n,k} is the ith</span>
<span class="sd">        G-point corresponding to k-point k.</span>

<span class="sd">        NOTE: This function is very slow; a discrete fourier transform is the</span>
<span class="sd">        preferred method of evaluation (see Wavecar.fft_mesh).</span>

<span class="sd">        Args:</span>
<span class="sd">            kpoint (int): the index of the kpoint where the wavefunction will be evaluated.</span>
<span class="sd">            band (int): the index of the band where the wavefunction will be evaluated.</span>
<span class="sd">            r (NDArray): the position where the wavefunction will be evaluated.</span>
<span class="sd">            spin (int): spin index for the desired wavefunction (only for</span>
<span class="sd">                ISPIN = 2, default = 0).</span>
<span class="sd">            spinor (int): component of the spinor that is evaluated (only used</span>
<span class="sd">                if vasp_type == &#39;ncl&#39;).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A complex value corresponding to the evaluation of the wavefunction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vasp_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;vasp_type cannot be None.&quot;</span><span class="p">)</span>

        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gpoints</span><span class="p">[</span><span class="n">kpoint</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">kpoints</span><span class="p">[</span><span class="n">kpoint</span><span class="p">]</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">),</span> <span class="n">r</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vasp_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;n&quot;</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeffs</span><span class="p">[</span><span class="n">kpoint</span><span class="p">][</span><span class="n">band</span><span class="p">][</span><span class="n">spinor</span><span class="p">,</span> <span class="p">:]</span>  <span class="c1"># type: ignore[call-overload, index]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeffs</span><span class="p">[</span><span class="n">spin</span><span class="p">][</span><span class="n">kpoint</span><span class="p">][</span><span class="n">band</span><span class="p">]</span>  <span class="c1"># type: ignore[index]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeffs</span><span class="p">[</span><span class="n">kpoint</span><span class="p">][</span><span class="n">band</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">u</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vol</span><span class="p">)</span></div>


<div class="viewcode-block" id="Wavecar.fft_mesh">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Wavecar.fft_mesh">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fft_mesh</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">kpoint</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">band</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">spin</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">spinor</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">shift</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Place the coefficients of a wavefunction onto an fft mesh.</span>

<span class="sd">        Once the mesh has been obtained, a discrete fourier transform can be</span>
<span class="sd">        used to obtain real-space evaluation of the wavefunction. The output</span>
<span class="sd">        of this function can be passed directly to numpy&#39;s fft function. For</span>
<span class="sd">        example:</span>

<span class="sd">            mesh = Wavecar(&#39;WAVECAR&#39;).fft_mesh(kpoint, band)</span>
<span class="sd">            evals = np.fft.ifftn(mesh)</span>

<span class="sd">        Args:</span>
<span class="sd">            kpoint (int): the index of the kpoint where the wavefunction will be evaluated</span>
<span class="sd">            band (int): the index of the band where the wavefunction will be evaluated</span>
<span class="sd">            spin (int): the spin of the wavefunction for the desired</span>
<span class="sd">                wavefunction (only for ISPIN = 2, default = 0)</span>
<span class="sd">            spinor (int): component of the spinor that is evaluated (only used</span>
<span class="sd">                if vasp_type == &#39;ncl&#39;)</span>
<span class="sd">            shift (bool): determines if the zero frequency coefficient is</span>
<span class="sd">                placed at index (0, 0, 0) or centered</span>

<span class="sd">        Returns:</span>
<span class="sd">            a numpy ndarray representing the 3D mesh of coefficients</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vasp_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;vasp_type cannot be None.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vasp_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;n&quot;</span><span class="p">:</span>
            <span class="n">tcoeffs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeffs</span><span class="p">[</span><span class="n">kpoint</span><span class="p">][</span><span class="n">band</span><span class="p">][</span><span class="n">spinor</span><span class="p">,</span> <span class="p">:]</span>  <span class="c1"># type: ignore[call-overload, index]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">tcoeffs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeffs</span><span class="p">[</span><span class="n">spin</span><span class="p">][</span><span class="n">kpoint</span><span class="p">][</span><span class="n">band</span><span class="p">]</span>  <span class="c1"># type: ignore[index]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tcoeffs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeffs</span><span class="p">[</span><span class="n">kpoint</span><span class="p">][</span><span class="n">band</span><span class="p">]</span>

        <span class="n">mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ng</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">gp</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gpoints</span><span class="p">[</span><span class="n">kpoint</span><span class="p">],</span> <span class="n">tcoeffs</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>  <span class="c1"># type: ignore[call-overload]</span>
            <span class="n">t</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">gp</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ng</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
            <span class="n">mesh</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeff</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span> <span class="k">if</span> <span class="n">shift</span> <span class="k">else</span> <span class="n">mesh</span></div>


<div class="viewcode-block" id="Wavecar.get_parchg">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Wavecar.get_parchg">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_parchg</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">poscar</span><span class="p">:</span> <span class="n">Poscar</span><span class="p">,</span>
        <span class="n">kpoint</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">band</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">spin</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">spinor</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">phase</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">scale</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Chgcar</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate a Chgcar object, which is the charge density of the specified</span>
<span class="sd">        wavefunction.</span>

<span class="sd">        This function generates a Chgcar object with the charge density of the</span>
<span class="sd">        wavefunction specified by band and kpoint (and spin, if the WAVECAR</span>
<span class="sd">        corresponds to a spin-polarized calculation). The phase tag is a</span>
<span class="sd">        feature that is not present in VASP. For a real wavefunction, the phase</span>
<span class="sd">        tag being turned on means that the charge density is multiplied by the</span>
<span class="sd">        sign of the wavefunction at that point in space. A warning is generated</span>
<span class="sd">        if the phase tag is on and the chosen kpoint is not Gamma.</span>

<span class="sd">        Note: Augmentation from the PAWs is NOT included in this function. The</span>
<span class="sd">        maximal charge density will differ from the PARCHG from VASP, but the</span>
<span class="sd">        qualitative shape of the charge density will match.</span>

<span class="sd">        Args:</span>
<span class="sd">            poscar (pymatgen.io.vasp.inputs.Poscar): Poscar object that has the</span>
<span class="sd">                structure associated with the WAVECAR file</span>
<span class="sd">            kpoint (int): the index of the kpoint for the wavefunction</span>
<span class="sd">            band (int): the index of the band for the wavefunction</span>
<span class="sd">            spin (int): optional argument to specify the spin. If the Wavecar</span>
<span class="sd">                has ISPIN = 2, spin is None generates a Chgcar with total spin</span>
<span class="sd">                and magnetization, and spin == {0, 1} specifies just the spin</span>
<span class="sd">                up or down component.</span>
<span class="sd">            spinor (int): optional argument to specify the spinor component</span>
<span class="sd">                for noncollinear data wavefunctions (allowed values of None,</span>
<span class="sd">                0, or 1)</span>
<span class="sd">            phase (bool): flag to determine if the charge density is multiplied</span>
<span class="sd">                by the sign of the wavefunction. Only valid for real</span>
<span class="sd">                wavefunctions.</span>
<span class="sd">            scale (int): scaling for the FFT grid. The default value of 2 is at</span>
<span class="sd">                least as fine as the VASP default.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A Chgcar object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">phase</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kpoints</span><span class="p">[</span><span class="n">kpoint</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;phase is True should only be used for the Gamma kpoint! I hope you know what you&#39;re doing!&quot;</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Scaling of ng for the fft grid, need to restore value at the end</span>
        <span class="n">temp_ng</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ng</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ng</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ng</span> <span class="o">*</span> <span class="n">scale</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ng</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">spin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">wfr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fft_mesh</span><span class="p">(</span><span class="n">kpoint</span><span class="p">,</span> <span class="n">band</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="n">spin</span><span class="p">))</span> <span class="o">*</span> <span class="n">N</span>
                <span class="n">den</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">wfr</span><span class="p">)</span> <span class="o">*</span> <span class="n">wfr</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">phase</span><span class="p">:</span>
                    <span class="n">den</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">wfr</span><span class="p">))</span> <span class="o">*</span> <span class="n">den</span>
                <span class="n">data</span><span class="p">[</span><span class="s2">&quot;total&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">den</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">wfr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fft_mesh</span><span class="p">(</span><span class="n">kpoint</span><span class="p">,</span> <span class="n">band</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">*</span> <span class="n">N</span>
                <span class="n">denup</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">wfr</span><span class="p">)</span> <span class="o">*</span> <span class="n">wfr</span><span class="p">)</span>
                <span class="n">wfr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fft_mesh</span><span class="p">(</span><span class="n">kpoint</span><span class="p">,</span> <span class="n">band</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">N</span>
                <span class="n">dendn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">wfr</span><span class="p">)</span> <span class="o">*</span> <span class="n">wfr</span><span class="p">)</span>
                <span class="n">data</span><span class="p">[</span><span class="s2">&quot;total&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">denup</span> <span class="o">+</span> <span class="n">dendn</span>
                <span class="n">data</span><span class="p">[</span><span class="s2">&quot;diff&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">denup</span> <span class="o">-</span> <span class="n">dendn</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">spinor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">wfr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fft_mesh</span><span class="p">(</span><span class="n">kpoint</span><span class="p">,</span> <span class="n">band</span><span class="p">,</span> <span class="n">spinor</span><span class="o">=</span><span class="n">spinor</span><span class="p">))</span> <span class="o">*</span> <span class="n">N</span>
                <span class="n">den</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">wfr</span><span class="p">)</span> <span class="o">*</span> <span class="n">wfr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">wfr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fft_mesh</span><span class="p">(</span><span class="n">kpoint</span><span class="p">,</span> <span class="n">band</span><span class="p">,</span> <span class="n">spinor</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">*</span> <span class="n">N</span>
                <span class="n">wfr_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fft_mesh</span><span class="p">(</span><span class="n">kpoint</span><span class="p">,</span> <span class="n">band</span><span class="p">,</span> <span class="n">spinor</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">N</span>
                <span class="n">den</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">wfr</span><span class="p">)</span> <span class="o">*</span> <span class="n">wfr</span><span class="p">)</span>
                <span class="n">den</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">wfr_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">wfr_t</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vasp_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;vasp_type cannot be None.&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">phase</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vasp_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;n&quot;</span> <span class="ow">or</span> <span class="n">spinor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">den</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">wfr</span><span class="p">))</span> <span class="o">*</span> <span class="n">den</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;total&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">den</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ng</span> <span class="o">=</span> <span class="n">temp_ng</span>
        <span class="k">return</span> <span class="n">Chgcar</span><span class="p">(</span><span class="n">poscar</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span></div>


<div class="viewcode-block" id="Wavecar.write_unks">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Wavecar.write_unks">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write_unks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directory</span><span class="p">:</span> <span class="n">PathLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write the UNK files to the given directory.</span>

<span class="sd">        Write the cell-periodic part of the Bloch wavefunctions from the</span>
<span class="sd">        WAVECAR file to each of the UNK files. There will be one UNK file for</span>
<span class="sd">        each of the kpoints in the WAVECAR file.</span>

<span class="sd">        Note:</span>
<span class="sd">            Wannier90 expects the full kpoint grid instead of the symmetry-</span>
<span class="sd">            reduced one that VASP stores the wavefunctions on. You should run</span>
<span class="sd">            a nscf calculation with ISYM=0 to obtain the correct grid.</span>

<span class="sd">        Args:</span>
<span class="sd">            directory (PathLike): directory to write the UNK files.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out_dir</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">directory</span><span class="p">)</span><span class="o">.</span><span class="n">expanduser</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">out_dir</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            <span class="n">out_dir</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">out_dir</span><span class="o">.</span><span class="n">is_dir</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid directory&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vasp_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;vasp_type cannot be None.&quot;</span><span class="p">)</span>

        <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ng</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nk</span><span class="p">):</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;UNK</span><span class="si">{</span><span class="n">ik</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">:</span><span class="s2">05d</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vasp_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;n&quot;</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nb</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ng</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nb</span><span class="p">):</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">ib</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fft_mesh</span><span class="p">(</span><span class="n">ik</span><span class="p">,</span> <span class="n">ib</span><span class="p">,</span> <span class="n">spinor</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">*</span> <span class="n">N</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">ib</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fft_mesh</span><span class="p">(</span><span class="n">ik</span><span class="p">,</span> <span class="n">ib</span><span class="p">,</span> <span class="n">spinor</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">N</span>
                <span class="n">Unk</span><span class="p">(</span><span class="n">ik</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">write_file</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">out_dir</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">fname</span><span class="si">}</span><span class="s2">NC&quot;</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nb</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ng</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ispin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spin</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nb</span><span class="p">):</span>
                        <span class="n">data</span><span class="p">[</span><span class="n">ib</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fft_mesh</span><span class="p">(</span><span class="n">ik</span><span class="p">,</span> <span class="n">ib</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="n">ispin</span><span class="p">))</span> <span class="o">*</span> <span class="n">N</span>
                    <span class="n">Unk</span><span class="p">(</span><span class="n">ik</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">write_file</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">out_dir</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">fname</span><span class="si">}{</span><span class="n">ispin</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">))</span></div>
</div>



<div class="viewcode-block" id="Eigenval">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Eigenval">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Eigenval</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;EIGENVAL file reader.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        filename (PathLike): The input file.</span>
<span class="sd">        occu_tol (float): Tolerance for determining occupation in band properties.</span>
<span class="sd">        ispin (int): Spin polarization tag.</span>
<span class="sd">        nelect (int): Number of electrons.</span>
<span class="sd">        nkpt (int): Number of kpoints.</span>
<span class="sd">        nbands (int): Number of bands.</span>
<span class="sd">        kpoints (list): List of kpoints.</span>
<span class="sd">        kpoints_weights (list): Weights of each kpoint in the BZ, should sum to 1.</span>
<span class="sd">        eigenvalues (dict): Eigenvalues as a dict of {(spin): NDArray(shape=(nkpt, nbands, 2))}.</span>
<span class="sd">            This representation is based on actual ordering in VASP and is meant as an intermediate representation</span>
<span class="sd">            to be converted into proper objects. The kpoint index is 0-based (unlike the 1-based indexing in VASP).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">filename</span><span class="p">:</span> <span class="n">PathLike</span><span class="p">,</span>
        <span class="n">occu_tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">,</span>
        <span class="n">separate_spins</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read input from filename to construct Eigenval object.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename (PathLike): filename of EIGENVAL to read.</span>
<span class="sd">            occu_tol (float): tolerance for determining band gap.</span>
<span class="sd">            separate_spins (bool): whether the band gap, CBM, and VBM should be</span>
<span class="sd">                reported for each individual spin channel. Defaults to False,</span>
<span class="sd">                which computes the eigenvalue band properties independent of</span>
<span class="sd">                the spin orientation. If True, the calculation must be spin-polarized.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">occu_tol</span> <span class="o">=</span> <span class="n">occu_tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">separate_spins</span> <span class="o">=</span> <span class="n">separate_spins</span>

        <span class="k">with</span> <span class="n">zopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;rt&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ispin</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">file</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

            <span class="c1"># Remove useless header information</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
                <span class="n">file</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">nelect</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nkpt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbands</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">file</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">kpoints</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kpoints_weights</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ispin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">Spin</span><span class="o">.</span><span class="n">up</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nkpt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbands</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span>
                    <span class="n">Spin</span><span class="o">.</span><span class="n">down</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nkpt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbands</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span>
                <span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span> <span class="o">=</span> <span class="p">{</span><span class="n">Spin</span><span class="o">.</span><span class="n">up</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nkpt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbands</span><span class="p">,</span> <span class="mi">2</span><span class="p">))}</span>

            <span class="n">ikpt</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">file</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(\s+[\-+0-9eE.]+)</span><span class="si">{4}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">line</span><span class="p">)):</span>
                    <span class="n">ikpt</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">kpt</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">kpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kpt</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">kpoints_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kpt</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbands</span><span class="p">):</span>
                        <span class="n">sl</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">file</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sl</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">[</span><span class="n">Spin</span><span class="o">.</span><span class="n">up</span><span class="p">][</span><span class="n">ikpt</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sl</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">[</span><span class="n">Spin</span><span class="o">.</span><span class="n">up</span><span class="p">][</span><span class="n">ikpt</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sl</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">sl</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">[</span><span class="n">Spin</span><span class="o">.</span><span class="n">up</span><span class="p">][</span><span class="n">ikpt</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sl</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">[</span><span class="n">Spin</span><span class="o">.</span><span class="n">up</span><span class="p">][</span><span class="n">ikpt</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sl</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">[</span><span class="n">Spin</span><span class="o">.</span><span class="n">down</span><span class="p">][</span><span class="n">ikpt</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sl</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">[</span><span class="n">Spin</span><span class="o">.</span><span class="n">down</span><span class="p">][</span><span class="n">ikpt</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sl</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">eigenvalue_band_properties</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span>
        <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span>
        <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span>
            <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
            <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">bool</span><span class="p">],</span>
        <span class="p">]</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Band properties from the eigenvalues as a tuple of</span>
<span class="sd">        (band gap, cbm, vbm, is_band_gap_direct).</span>
<span class="sd">        In the case of separate_spins=True,</span>
<span class="sd">        the band gap, cbm, vbm, and is_band_gap_direct are each tuples of 2,</span>
<span class="sd">        with index 0 representing the spin-up channel and index 1 representing</span>
<span class="sd">        the spin-down channel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vbm</span> <span class="o">=</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
        <span class="n">vbm_kpoint</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">cbm</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
        <span class="n">cbm_kpoint</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">vbm_spins</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">vbm_spins_kpoints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cbm_spins</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cbm_spins_kpoints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">separate_spins</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The separate_spins flag can only be True if ISPIN = 2&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">eigenvalues</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">separate_spins</span><span class="p">:</span>
                <span class="n">vbm</span> <span class="o">=</span> <span class="o">-</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
                <span class="n">cbm</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">eigenval</span><span class="p">,</span> <span class="n">occu</span> <span class="ow">in</span> <span class="n">val</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">occu</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">occu_tol</span> <span class="ow">and</span> <span class="n">eigenval</span> <span class="o">&gt;</span> <span class="n">vbm</span><span class="p">:</span>
                        <span class="n">vbm</span> <span class="o">=</span> <span class="n">eigenval</span>
                        <span class="n">vbm_kpoint</span> <span class="o">=</span> <span class="n">k</span>
                    <span class="k">elif</span> <span class="n">occu</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">occu_tol</span> <span class="ow">and</span> <span class="n">eigenval</span> <span class="o">&lt;</span> <span class="n">cbm</span><span class="p">:</span>
                        <span class="n">cbm</span> <span class="o">=</span> <span class="n">eigenval</span>
                        <span class="n">cbm_kpoint</span> <span class="o">=</span> <span class="n">k</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">separate_spins</span><span class="p">:</span>
                <span class="n">vbm_spins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vbm</span><span class="p">)</span>
                <span class="n">vbm_spins_kpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vbm_kpoint</span><span class="p">)</span>
                <span class="n">cbm_spins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cbm</span><span class="p">)</span>
                <span class="n">cbm_spins_kpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cbm_kpoint</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">separate_spins</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="p">(</span>
                    <span class="nb">max</span><span class="p">(</span><span class="n">cbm_spins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">vbm_spins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">),</span>
                    <span class="nb">max</span><span class="p">(</span><span class="n">cbm_spins</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">vbm_spins</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">),</span>
                <span class="p">),</span>
                <span class="p">(</span><span class="n">cbm_spins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cbm_spins</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                <span class="p">(</span><span class="n">vbm_spins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vbm_spins</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                <span class="p">(</span>
                    <span class="n">vbm_spins_kpoints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">cbm_spins_kpoints</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">vbm_spins_kpoints</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">cbm_spins_kpoints</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="p">),</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">cbm</span> <span class="o">-</span> <span class="n">vbm</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">cbm</span><span class="p">,</span> <span class="n">vbm</span><span class="p">,</span> <span class="n">vbm_kpoint</span> <span class="o">==</span> <span class="n">cbm_kpoint</span></div>



<div class="viewcode-block" id="Waveder">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Waveder">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Waveder</span><span class="p">(</span><span class="n">MSONable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Representation of the WAVEDER file.</span>

<span class="sd">    The LOPTICS tag produces a WAVEDER file which contains the derivative of the orbitals with respect to k.</span>
<span class="sd">    Since the data is complex, we need to split it into the real and imaginary parts for JSON serialization.</span>

<span class="sd">    Note:</span>
<span class="sd">        The way that VASP writes the WAVEDER and WAVEDERF has slightly different logic when indexing the bands.</span>
<span class="sd">        This results in the formatted WAVDERF only indexing between filled bands. (i.e. all the matrix elements</span>
<span class="sd">        are between the states i=1:8 and j=1:8 in a two atom Si calculation, which is likely a VASP bug).</span>
<span class="sd">        As such, it is recommended to used the hidden ``LVEL=.True.`` flag in VASP which will force indexing over</span>
<span class="sd">        all bands.</span>

<span class="sd">    The order of the indices of the data are:</span>
<span class="sd">        [</span>
<span class="sd">            band index1,</span>
<span class="sd">            band index2,</span>
<span class="sd">            kpoint index,</span>
<span class="sd">            spin index,</span>
<span class="sd">            cartesian direction,</span>
<span class="sd">        ]</span>

<span class="sd">    Attributes:</span>
<span class="sd">        cder_real: Real part of the derivative of the orbitals with respect to k.</span>
<span class="sd">        cder_imag: Imaginary part of the derivative of the orbitals with respect to k.</span>

<span class="sd">    Author: Miguel Dias Costa, Kamal Choudhary, Jimmy-Xuan Shen</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">cder_real</span><span class="p">:</span> <span class="n">NDArray</span>
    <span class="n">cder_imag</span><span class="p">:</span> <span class="n">NDArray</span>

<div class="viewcode-block" id="Waveder.from_formatted">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Waveder.from_formatted">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_formatted</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="n">PathLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read the WAVEDERF file.</span>

<span class="sd">        Note: This file is only produced when LOPTICS is true and VASP has been</span>
<span class="sd">        recompiled after uncommenting the line that calls</span>
<span class="sd">        WRT_CDER_BETWEEN_STATES_FORMATTED in linear_optics.F.</span>

<span class="sd">        It is recommended to use `from_binary` instead since the binary file is</span>
<span class="sd">        much smaller and contains the same information.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename (PathLike): The name of the WAVEDER file.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A Waveder object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">zopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;rt&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">nspin</span><span class="p">,</span> <span class="n">nkpts</span><span class="p">,</span> <span class="n">nbands</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="c1"># 1 and 4 are the eigenvalues of the bands (this data is missing in the WAVEDER file)</span>
        <span class="c1"># 6:12 are the complex matrix elements in each cartesian direction.</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">skiprows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">usecols</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">nspin</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">nkpts</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">nbands</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">nbands</span><span class="p">),</span> <span class="mi">8</span><span class="p">)</span>  <span class="c1"># slowest to fastest</span>
        <span class="n">cder_real</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">cder_imag</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">3</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
        <span class="c1"># Change to [band1, band2, kpt, spin, cartesian]</span>
        <span class="n">cder_real</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">cder_real</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
        <span class="n">cder_imag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">cder_imag</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
        <span class="c1"># TODO: add eigenvalues?</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">cder_real</span><span class="p">,</span> <span class="n">cder_imag</span><span class="p">)</span></div>


<div class="viewcode-block" id="Waveder.from_binary">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Waveder.from_binary">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_binary</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">filename</span><span class="p">:</span> <span class="n">PathLike</span><span class="p">,</span>
        <span class="n">data_type</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;complex64&quot;</span><span class="p">,</span> <span class="s2">&quot;float64&quot;</span><span class="p">,</span> <span class="s2">&quot;float32&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;complex64&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read the WAVEDER file.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename: Name of file containing WAVEDER.</span>
<span class="sd">            data_type: Data type of the WAVEDER file. Default is complex64.</span>
<span class="sd">                If the file was generated with the &quot;gamma&quot; version of VASP,</span>
<span class="sd">                the data type can be either &quot;float64&quot; or &quot;float32&quot;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Waveder object.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">read_data</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Read records from Fortran binary file and convert to np.array of given dtype.&quot;&quot;&quot;</span>
            <span class="n">data</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;&quot;</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">prefix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">data</span> <span class="o">+=</span> <span class="n">file</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">prefix</span><span class="p">))</span>
                <span class="n">suffix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span> <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span><span class="n">suffix</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Read wrong amount of bytes.</span><span class="se">\n</span><span class="s2">Expected: </span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">, read: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2">, suffix: </span><span class="si">{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">.&quot;</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="n">prefix</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">nbands</span><span class="p">,</span> <span class="n">nelect</span><span class="p">,</span> <span class="n">nk</span><span class="p">,</span> <span class="n">ispin</span> <span class="o">=</span> <span class="n">read_data</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">read_data</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>  <span class="c1"># nodes_in_dielectric_function</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">read_data</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>  <span class="c1"># wplasmon</span>
            <span class="n">me_datatype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">data_type</span><span class="p">)</span>
            <span class="n">cder</span> <span class="o">=</span> <span class="n">read_data</span><span class="p">(</span><span class="n">me_datatype</span><span class="p">)</span>

            <span class="n">cder_data</span> <span class="o">=</span> <span class="n">cder</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">ispin</span><span class="p">,</span> <span class="n">nk</span><span class="p">,</span> <span class="n">nelect</span><span class="p">,</span> <span class="n">nbands</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">cder_data</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">cder_data</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">cder</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The complex derivative of the orbitals with respect to k.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cder_real</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cder_real</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>  <span class="c1"># pragma: no cover</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Not all band pairs are present in the WAVEDER file.&quot;</span>
                <span class="s2">&quot;If you want to get all the matrix elements set LVEL=.True. in the INCAR.&quot;</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cder_real</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cder_imag</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nspin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The number of spin channels.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cder_real</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nkpoints</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The number of k-points.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cder_real</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nbands</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The number of bands.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cder_real</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<div class="viewcode-block" id="Waveder.get_orbital_derivative_between_states">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.Waveder.get_orbital_derivative_between_states">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_orbital_derivative_between_states</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">band_i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">band_j</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">kpoint</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">spin</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="n">cart_dir</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a float between bands band_i and band_j for k-point index,</span>
<span class="sd">        spin-channel and Cartesian direction.</span>

<span class="sd">        Args:</span>
<span class="sd">            band_i (int): Index of band i</span>
<span class="sd">            band_j (int): Index of band j</span>
<span class="sd">            kpoint (int): Index of k-point</span>
<span class="sd">            spin (int): Spin-channel (0 or 1)</span>
<span class="sd">            cart_dir (int): Index of Cartesian direction (0, 1, 2)</span>

<span class="sd">        Returns:</span>
<span class="sd">            a float value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cder</span><span class="p">[</span><span class="n">band_i</span><span class="p">,</span> <span class="n">band_j</span><span class="p">,</span> <span class="n">kpoint</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">cart_dir</span><span class="p">]</span></div>
</div>



<div class="viewcode-block" id="WSWQ">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.WSWQ">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">WSWQ</span><span class="p">(</span><span class="n">MSONable</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Read a WSWQ file.</span>
<span class="sd">    The WSWQ file is used to calculation the wave function overlaps between:</span>
<span class="sd">        - W: Wavefunctions in the current directory&#39;s WAVECAR file.</span>
<span class="sd">        - WQ: Wavefunctions stored in the WAVECAR.qqq file.</span>

<span class="sd">    The overlap is computed using the overlap operator S</span>
<span class="sd">    which make the PAW wavefunctions orthogonormal:</span>
<span class="sd">        &lt;W_k,m| S | W_k,n&gt; = \delta_{mn}</span>

<span class="sd">    The WSWQ file contains matrix elements of the overlap operator S evaluated</span>
<span class="sd">    between the planewave wavefunctions W and WQ:</span>
<span class="sd">        COVL_k,mn = &lt; W_s,k,m | S | WQ_s,k,n &gt;</span>

<span class="sd">    The indices of WSWQ.data are:</span>
<span class="sd">        [spin][kpoint][band_i][band_j]</span>

<span class="sd">    Attributes:</span>
<span class="sd">        nspin: Number of spin channels</span>
<span class="sd">        nkpoints: Number of k-points</span>
<span class="sd">        nbands: Number of bands</span>
<span class="sd">        me_real: Real part of the overlap matrix elements</span>
<span class="sd">        me_imag: Imaginary part of the overlap matrix elements</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nspin</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">nkpoints</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">nbands</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">me_real</span><span class="p">:</span> <span class="n">NDArray</span>
    <span class="n">me_imag</span><span class="p">:</span> <span class="n">NDArray</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Complex overlap matrix.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">me_real</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">me_imag</span>

<div class="viewcode-block" id="WSWQ.from_file">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.WSWQ.from_file">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_file</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct a WSWQ object from a file.</span>

<span class="sd">        Args:</span>
<span class="sd">            filename (str): Name of WSWQ file.</span>

<span class="sd">        Returns:</span>
<span class="sd">            WSWQ object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Grab the spin and kpoint values from lines containing &quot;spin&quot;</span>
        <span class="n">spin_res</span> <span class="o">=</span> <span class="n">regrep</span><span class="p">(</span>
            <span class="n">filename</span><span class="p">,</span>
            <span class="p">{</span><span class="s2">&quot;spin&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;spin\s*=\s*(\d+)\s?\,\s?kpoint\s*=\s*(\d+)&quot;</span><span class="p">},</span>
            <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">terminate_on_match</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">postprocess</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
        <span class="p">)[</span><span class="s2">&quot;spin&quot;</span><span class="p">]</span>
        <span class="p">(</span><span class="n">nspin</span><span class="p">,</span> <span class="n">nkpoints</span><span class="p">),</span> <span class="n">_</span> <span class="o">=</span> <span class="n">spin_res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Grab the index values from the parts with &quot;i    =&quot; and &quot;j    =&quot;</span>
        <span class="n">ij_res</span> <span class="o">=</span> <span class="n">regrep</span><span class="p">(</span>
            <span class="n">filename</span><span class="p">,</span>
            <span class="p">{</span><span class="s2">&quot;ij&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;i\s*=\s*(\d+)\s?\,\s?j\s*=\s*(\d+)&quot;</span><span class="p">},</span>
            <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">terminate_on_match</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">postprocess</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
        <span class="p">)[</span><span class="s2">&quot;ij&quot;</span><span class="p">]</span>
        <span class="p">(</span><span class="n">nbands</span><span class="p">,</span> <span class="n">_</span><span class="p">),</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ij_res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Grab the matrix elements from the parts after the &quot;:&quot;</span>
        <span class="n">data_res</span> <span class="o">=</span> <span class="n">regrep</span><span class="p">(</span>
            <span class="n">filename</span><span class="p">,</span>
            <span class="p">{</span><span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;\:\s*([-+]?\d*\.\d+)\s+([-+]?\d*\.\d+)&quot;</span><span class="p">},</span>
            <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">terminate_on_match</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">postprocess</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
        <span class="p">)[</span><span class="s2">&quot;data&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_res</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nspin</span> <span class="o">*</span> <span class="n">nkpoints</span> <span class="o">*</span> <span class="n">nbands</span> <span class="o">*</span> <span class="n">nbands</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;incorrect length of data_res&quot;</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">complex</span><span class="p">(</span><span class="n">real_part</span><span class="p">,</span> <span class="n">img_part</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">real_part</span><span class="p">,</span> <span class="n">img_part</span><span class="p">),</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">data_res</span><span class="p">])</span>

        <span class="c1"># NOTE: loop order (slow-&gt;fast) spin -&gt; kpoint -&gt; j -&gt; i</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">nspin</span><span class="p">,</span> <span class="n">nkpoints</span><span class="p">,</span> <span class="n">nbands</span><span class="p">,</span> <span class="n">nbands</span><span class="p">))</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># swap i and j</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">nspin</span><span class="o">=</span><span class="n">nspin</span><span class="p">,</span>
            <span class="n">nkpoints</span><span class="o">=</span><span class="n">nkpoints</span><span class="p">,</span>
            <span class="n">nbands</span><span class="o">=</span><span class="n">nbands</span><span class="p">,</span>
            <span class="n">me_real</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">data</span><span class="p">),</span>
            <span class="n">me_imag</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">data</span><span class="p">),</span>
        <span class="p">)</span></div>
</div>



<div class="viewcode-block" id="UnconvergedVASPWarning">
<a class="viewcode-back" href="../../../../pymatgen.io.vasp.html#pymatgen.io.vasp.outputs.UnconvergedVASPWarning">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">UnconvergedVASPWarning</span><span class="p">(</span><span class="ne">Warning</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Warning for unconverged VASP run.&quot;&quot;&quot;</span></div>

</pre></div>

            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">pymatgen 2025.1.24 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">pymatgen.io.vasp.outputs</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2011, Pymatgen Development Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    </div>
  </body>
</html>