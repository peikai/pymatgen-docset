<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pymatgen.core.surface &#8212; pymatgen 2025.1.24 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../_static/basic.css?v=5c69cfe2" />
    <script src="../../../_static/documentation_options.js?v=d2bc030c"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">pymatgen 2025.1.24 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">pymatgen.core.surface</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <h1>Source code for pymatgen.core.surface</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;This module implements representation of Slab, SlabGenerator</span>
<span class="sd">for generating Slabs, ReconstructionGenerator to generate</span>
<span class="sd">reconstructed Slabs, and some related utility functions.</span>

<span class="sd">If you use this module, please consider citing the following work:</span>

<span class="sd">    R. Tran, Z. Xu, B. Radhakrishnan, D. Winston, W. Sun, K. A. Persson,</span>
<span class="sd">    S. P. Ong, &quot;Surface Energies of Elemental Crystals&quot;, Scientific Data,</span>
<span class="sd">    2016, 3:160080, doi: 10.1038/sdata.2016.80.</span>

<span class="sd">    Sun, W.; Ceder, G. Efficient creation and convergence of surface slabs,</span>
<span class="sd">    Surface Science, 2013, 617, 53-59, doi:10.1016/j.susc.2013.05.016.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">reduce</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">cast</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">monty.fractions</span><span class="w"> </span><span class="kn">import</span> <span class="n">lcm</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.cluster.hierarchy</span><span class="w"> </span><span class="kn">import</span> <span class="n">fcluster</span><span class="p">,</span> <span class="n">linkage</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.distance</span><span class="w"> </span><span class="kn">import</span> <span class="n">squareform</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">pymatgen.analysis.structure_matcher</span><span class="w"> </span><span class="kn">import</span> <span class="n">StructureMatcher</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pymatgen.core</span><span class="w"> </span><span class="kn">import</span> <span class="n">Lattice</span><span class="p">,</span> <span class="n">PeriodicSite</span><span class="p">,</span> <span class="n">Structure</span><span class="p">,</span> <span class="n">get_el_sp</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pymatgen.symmetry.analyzer</span><span class="w"> </span><span class="kn">import</span> <span class="n">SpacegroupAnalyzer</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pymatgen.util.coord</span><span class="w"> </span><span class="kn">import</span> <span class="n">in_coord_list</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pymatgen.util.due</span><span class="w"> </span><span class="kn">import</span> <span class="n">Doi</span><span class="p">,</span> <span class="n">due</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pymatgen.util.typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Tuple3Ints</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Sequence</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span>

    <span class="kn">from</span><span class="w"> </span><span class="nn">numpy.typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">NDArray</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">typing_extensions</span><span class="w"> </span><span class="kn">import</span> <span class="n">Self</span>

    <span class="kn">from</span><span class="w"> </span><span class="nn">pymatgen.core.composition</span><span class="w"> </span><span class="kn">import</span> <span class="n">Element</span><span class="p">,</span> <span class="n">Species</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">pymatgen.symmetry.groups</span><span class="w"> </span><span class="kn">import</span> <span class="n">CrystalSystem</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">pymatgen.util.typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">MillerIndex</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Richard Tran, Wenhao Sun, Zihan Xu, Shyue Ping Ong&quot;</span>

<span class="n">due</span><span class="o">.</span><span class="n">dcite</span><span class="p">(</span>
    <span class="n">Doi</span><span class="p">(</span><span class="s2">&quot;10.1038/sdata.2016.80&quot;</span><span class="p">),</span>
    <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Surface Energies of Elemental Crystals&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">due</span><span class="o">.</span><span class="n">dcite</span><span class="p">(</span>
    <span class="n">Doi</span><span class="p">(</span><span class="s2">&quot;10.1016/j.susc.2013.05.016&quot;</span><span class="p">),</span>
    <span class="n">description</span><span class="o">=</span><span class="s2">&quot;Efficient creation and convergence of surface slabs&quot;</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="Slab">
<a class="viewcode-back" href="../../../pymatgen.core.html#pymatgen.core.surface.Slab">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Slab</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Hold information for a Slab, with additional</span>
<span class="sd">    attributes pertaining to slabs, but the init method does not</span>
<span class="sd">    actually create a slab. Also has additional methods that returns other information</span>
<span class="sd">    about a Slab such as the surface area, normal, and atom adsorption.</span>

<span class="sd">    Note that all Slabs have the surface normal oriented perpendicular to the</span>
<span class="sd">    a and b lattice vectors. This means the lattice vectors a and b are in the</span>
<span class="sd">    surface plane and the c vector is out of the surface plane (though not</span>
<span class="sd">    necessarily perpendicular to the surface).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lattice</span><span class="p">:</span> <span class="n">Lattice</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">species</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span>
        <span class="n">coords</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">miller_index</span><span class="p">:</span> <span class="n">MillerIndex</span><span class="p">,</span>
        <span class="n">oriented_unit_cell</span><span class="p">:</span> <span class="n">Structure</span><span class="p">,</span>
        <span class="n">shift</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">scale_factor</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">reorient_lattice</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">validate_proximity</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">to_unit_cell</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">reconstruction</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">coords_are_cartesian</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">site_properties</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">energy</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A Structure object with additional information</span>
<span class="sd">        and methods pertaining to Slabs.</span>

<span class="sd">        Args:</span>
<span class="sd">            lattice (Lattice/3x3 array): The lattice, either as a</span>
<span class="sd">                pymatgen.core.Lattice or simply as any 2D array.</span>
<span class="sd">                Each row should correspond to a lattice</span>
<span class="sd">                vector. e.g. [[10,0,0], [20,10,0], [0,0,30]].</span>
<span class="sd">            species ([Species]): Sequence of species on each site. Can take in</span>
<span class="sd">                flexible input, including:</span>

<span class="sd">                i.  A sequence of element / species specified either as string</span>
<span class="sd">                    symbols, e.g. [&quot;Li&quot;, &quot;Fe2+&quot;, &quot;P&quot;, ...] or atomic numbers,</span>
<span class="sd">                    e.g. (3, 56, ...) or actual Element or Species objects.</span>

<span class="sd">                ii. List of dict of elements/species and occupancies, e.g.</span>
<span class="sd">                    [{&quot;Fe&quot;: 0.5, &quot;Mn&quot;: 0.5}, ...]. This allows the setup of</span>
<span class="sd">                    disordered structures.</span>
<span class="sd">            coords (Nx3 array): list of fractional/cartesian coordinates of each species.</span>
<span class="sd">            miller_index (MillerIndex): Miller index of plane parallel to</span>
<span class="sd">                surface. Note that this is referenced to the input structure. If</span>
<span class="sd">                you need this to be based on the conventional cell,</span>
<span class="sd">                you should supply the conventional structure.</span>
<span class="sd">            oriented_unit_cell (Structure): The oriented_unit_cell from which</span>
<span class="sd">                this Slab is created (by scaling in the c-direction).</span>
<span class="sd">            shift (float): The NEGATIVE of shift in the c-direction applied</span>
<span class="sd">                to get the termination.</span>
<span class="sd">            scale_factor (np.ndarray): scale_factor Final computed scale factor</span>
<span class="sd">                that brings the parent cell to the surface cell.</span>
<span class="sd">            reorient_lattice (bool): reorients the lattice parameters such that</span>
<span class="sd">                the c direction is along the z axis.</span>
<span class="sd">            validate_proximity (bool): Whether to check if there are sites</span>
<span class="sd">                that are less than 0.01 Ang apart. Defaults to False.</span>
<span class="sd">            reconstruction (str): Type of reconstruction. Defaults to None if</span>
<span class="sd">                the slab is not reconstructed.</span>
<span class="sd">            to_unit_cell (bool): Translates fractional coordinates into the</span>
<span class="sd">                unit cell. Defaults to False.</span>
<span class="sd">            coords_are_cartesian (bool): Set to True if you are providing</span>
<span class="sd">                coordinates in Cartesian coordinates. Defaults to False.</span>
<span class="sd">            site_properties (dict): Properties associated with the sites as a</span>
<span class="sd">                dict of sequences, e.g. {&quot;magmom&quot;:[5,5,5,5]}. The sequences</span>
<span class="sd">                have to be the same length as the atomic species and</span>
<span class="sd">                fractional_coords. Defaults to None for no properties.</span>
<span class="sd">            energy (float): A value for the energy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">oriented_unit_cell</span> <span class="o">=</span> <span class="n">oriented_unit_cell</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">miller_index</span> <span class="o">=</span> <span class="n">miller_index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shift</span> <span class="o">=</span> <span class="n">shift</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reconstruction</span> <span class="o">=</span> <span class="n">reconstruction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_factor</span> <span class="o">=</span> <span class="n">scale_factor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">energy</span> <span class="o">=</span> <span class="n">energy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reorient_lattice</span> <span class="o">=</span> <span class="n">reorient_lattice</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reorient_lattice</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">coords_are_cartesian</span><span class="p">:</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">lattice</span><span class="o">.</span><span class="n">get_fractional_coords</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
                <span class="n">coords_are_cartesian</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">lattice</span> <span class="o">=</span> <span class="n">Lattice</span><span class="o">.</span><span class="n">from_parameters</span><span class="p">(</span>
                <span class="n">lattice</span><span class="o">.</span><span class="n">a</span><span class="p">,</span>
                <span class="n">lattice</span><span class="o">.</span><span class="n">b</span><span class="p">,</span>
                <span class="n">lattice</span><span class="o">.</span><span class="n">c</span><span class="p">,</span>
                <span class="n">lattice</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span>
                <span class="n">lattice</span><span class="o">.</span><span class="n">beta</span><span class="p">,</span>
                <span class="n">lattice</span><span class="o">.</span><span class="n">gamma</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">lattice</span><span class="p">,</span>
            <span class="n">species</span><span class="p">,</span>
            <span class="n">coords</span><span class="p">,</span>
            <span class="n">validate_proximity</span><span class="o">=</span><span class="n">validate_proximity</span><span class="p">,</span>
            <span class="n">to_unit_cell</span><span class="o">=</span><span class="n">to_unit_cell</span><span class="p">,</span>
            <span class="n">coords_are_cartesian</span><span class="o">=</span><span class="n">coords_are_cartesian</span><span class="p">,</span>
            <span class="n">site_properties</span><span class="o">=</span><span class="n">site_properties</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">outs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="sa">f</span><span class="s2">&quot;Slab Summary (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">composition</span><span class="o">.</span><span class="n">formula</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;Reduced Formula: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">composition</span><span class="o">.</span><span class="n">reduced_formula</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;Miller index: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">miller_index</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;Shift: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">, Scale Factor: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_factor</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;abc   : </span><span class="si">{</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">i</span><span class="si">:</span><span class="s1">0.6f</span><span class="si">}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">abc</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;angles: </span><span class="si">{</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">i</span><span class="si">:</span><span class="s1">0.6f</span><span class="si">}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">angles</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;Sites (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">,</span>
        <span class="p">]</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">site</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">outs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">idx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">site</span><span class="o">.</span><span class="n">species_string</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">j</span><span class="si">:</span><span class="s1">0.6f</span><span class="si">}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">site</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">center_of_mass</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The center of mass of the Slab in fractional coordinates.&quot;&quot;&quot;</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="n">site</span><span class="o">.</span><span class="n">species</span><span class="o">.</span><span class="n">weight</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dipole</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The dipole moment of the Slab in the direction of the surface normal.</span>

<span class="sd">        Note that the Slab must be oxidation state decorated for this to work properly.</span>
<span class="sd">        Otherwise, the Slab will always have a dipole moment of 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">centroid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cart_coords</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">dipole</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">charge</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="s2">&quot;oxi_state&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">amt</span> <span class="k">for</span> <span class="n">sp</span><span class="p">,</span> <span class="n">amt</span> <span class="ow">in</span> <span class="n">site</span><span class="o">.</span><span class="n">species</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
            <span class="n">dipole</span> <span class="o">+=</span> <span class="n">charge</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">coords</span> <span class="o">-</span> <span class="n">centroid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span>
        <span class="k">return</span> <span class="n">dipole</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">normal</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The surface normal vector of the Slab, normalized to unit length.&quot;&quot;&quot;</span>
        <span class="n">normal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">normal</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">normal</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">surface_area</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The surface area of the Slab.&quot;&quot;&quot;</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">matrix</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

<div class="viewcode-block" id="Slab.from_dict">
<a class="viewcode-back" href="../../../pymatgen.core.html#pymatgen.core.surface.Slab.from_dict">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dct</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            dct: dict.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Slab: Created from dict.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lattice</span> <span class="o">=</span> <span class="n">Lattice</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">dct</span><span class="p">[</span><span class="s2">&quot;lattice&quot;</span><span class="p">])</span>
        <span class="n">sites</span> <span class="o">=</span> <span class="p">[</span><span class="n">PeriodicSite</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="n">lattice</span><span class="p">)</span> <span class="k">for</span> <span class="n">sd</span> <span class="ow">in</span> <span class="n">dct</span><span class="p">[</span><span class="s2">&quot;sites&quot;</span><span class="p">]]</span>
        <span class="n">struct</span> <span class="o">=</span> <span class="n">Structure</span><span class="o">.</span><span class="n">from_sites</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">lattice</span><span class="o">=</span><span class="n">lattice</span><span class="p">,</span>
            <span class="n">species</span><span class="o">=</span><span class="n">struct</span><span class="o">.</span><span class="n">species_and_occu</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="n">struct</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">,</span>
            <span class="n">miller_index</span><span class="o">=</span><span class="n">dct</span><span class="p">[</span><span class="s2">&quot;miller_index&quot;</span><span class="p">],</span>
            <span class="n">oriented_unit_cell</span><span class="o">=</span><span class="n">Structure</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">dct</span><span class="p">[</span><span class="s2">&quot;oriented_unit_cell&quot;</span><span class="p">]),</span>
            <span class="n">shift</span><span class="o">=</span><span class="n">dct</span><span class="p">[</span><span class="s2">&quot;shift&quot;</span><span class="p">],</span>
            <span class="n">scale_factor</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dct</span><span class="p">[</span><span class="s2">&quot;scale_factor&quot;</span><span class="p">]),</span>
            <span class="n">site_properties</span><span class="o">=</span><span class="n">struct</span><span class="o">.</span><span class="n">site_properties</span><span class="p">,</span>
            <span class="n">energy</span><span class="o">=</span><span class="n">dct</span><span class="p">[</span><span class="s2">&quot;energy&quot;</span><span class="p">],</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Slab.as_dict">
<a class="viewcode-back" href="../../../pymatgen.core.html#pymatgen.core.surface.Slab.as_dict">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">as_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;MSONable dict.&quot;&quot;&quot;</span>
        <span class="n">dct</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">as_dict</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">dct</span><span class="p">[</span><span class="s2">&quot;@module&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__module__</span>
        <span class="n">dct</span><span class="p">[</span><span class="s2">&quot;@class&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">dct</span><span class="p">[</span><span class="s2">&quot;oriented_unit_cell&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">oriented_unit_cell</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span>
        <span class="n">dct</span><span class="p">[</span><span class="s2">&quot;miller_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">miller_index</span>
        <span class="n">dct</span><span class="p">[</span><span class="s2">&quot;shift&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span>
        <span class="n">dct</span><span class="p">[</span><span class="s2">&quot;scale_factor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_factor</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>  <span class="c1"># np.ndarray is not JSON serializable</span>
        <span class="n">dct</span><span class="p">[</span><span class="s2">&quot;reconstruction&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reconstruction</span>
        <span class="n">dct</span><span class="p">[</span><span class="s2">&quot;energy&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">energy</span>
        <span class="k">return</span> <span class="n">dct</span></div>


<div class="viewcode-block" id="Slab.copy">
<a class="viewcode-back" href="../../../pymatgen.core.html#pymatgen.core.surface.Slab.copy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">site_properties</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a copy of the Slab, with options to update site properties.</span>

<span class="sd">        Args:</span>
<span class="sd">            site_properties (dict): Properties to update. The</span>
<span class="sd">                properties are specified in the same way as the constructor,</span>
<span class="sd">                i.e., as a dict of the form {property: [values]}.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A copy of the Structure, with optionally new site_properties</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">props</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">site_properties</span>
        <span class="k">if</span> <span class="n">site_properties</span><span class="p">:</span>
            <span class="n">props</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">site_properties</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">species_and_occu</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">miller_index</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">oriented_unit_cell</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale_factor</span><span class="p">,</span>
            <span class="n">site_properties</span><span class="o">=</span><span class="n">props</span><span class="p">,</span>
            <span class="n">reorient_lattice</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reorient_lattice</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Slab.is_symmetric">
<a class="viewcode-back" href="../../../pymatgen.core.html#pymatgen.core.surface.Slab.is_symmetric">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_symmetric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symprec</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if Slab is symmetric, i.e., contains inversion, mirror on (hkl) plane,</span>
<span class="sd">            or screw axis (rotation and translation) about [hkl].</span>

<span class="sd">        Args:</span>
<span class="sd">            symprec (float): Symmetry precision used for SpaceGroup analyzer.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if surfaces are symmetric.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spg_analyzer</span> <span class="o">=</span> <span class="n">SpacegroupAnalyzer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="n">symprec</span><span class="p">)</span>
        <span class="n">symm_ops</span> <span class="o">=</span> <span class="n">spg_analyzer</span><span class="o">.</span><span class="n">get_point_group_operations</span><span class="p">()</span>

        <span class="c1"># Check for inversion symmetry. Or if sites from surface (a) can be translated</span>
        <span class="c1"># to surface (b) along the [hkl]-axis, surfaces are symmetric. Or because the</span>
        <span class="c1"># two surfaces of our slabs are always parallel to the (hkl) plane,</span>
        <span class="c1"># any operation where there&#39;s an (hkl) mirror plane has surface symmetry</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span>
            <span class="n">spg_analyzer</span><span class="o">.</span><span class="n">is_laue</span><span class="p">()</span>
            <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">translation_vector</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">symm_ops</span><span class="p">)</span>
            <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">symm_ops</span><span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Slab.is_polar">
<a class="viewcode-back" href="../../../pymatgen.core.html#pymatgen.core.surface.Slab.is_polar">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_polar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tol_dipole_per_unit_area</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if the Slab is polar by computing the normalized dipole per unit area.</span>
<span class="sd">        Normalized dipole per unit area is used as it is more reliable than</span>
<span class="sd">        using the absolute value, which varies with surface area.</span>

<span class="sd">        Note that the Slab must be oxidation state decorated for this to work properly.</span>
<span class="sd">        Otherwise, the Slab will always have a dipole moment of 0.</span>

<span class="sd">        Args:</span>
<span class="sd">            tol_dipole_per_unit_area (float): A tolerance above which the Slab is</span>
<span class="sd">                considered polar.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dip_per_unit_area</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dipole</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface_area</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">dip_per_unit_area</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol_dipole_per_unit_area</span><span class="p">)</span></div>


<div class="viewcode-block" id="Slab.get_surface_sites">
<a class="viewcode-back" href="../../../pymatgen.core.html#pymatgen.core.surface.Slab.get_surface_sites">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_surface_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the surface sites and their indices in a dictionary.</span>
<span class="sd">        Useful for analysis involving broken bonds and for finding adsorption sites.</span>

<span class="sd">        The oriented unit cell of the slab will determine the</span>
<span class="sd">        coordination number of a typical site.</span>
<span class="sd">        We use VoronoiNN to determine the coordination number of sites.</span>
<span class="sd">        Due to the pathological error resulting from some surface sites in the</span>
<span class="sd">        VoronoiNN, we assume any site that has this error is a surface</span>
<span class="sd">        site as well. This will only work for single-element systems for now.</span>

<span class="sd">        Args:</span>
<span class="sd">            tag (bool): Add attribute &quot;is_surf_site&quot; (bool)</span>
<span class="sd">                to all sites of the Slab. Defaults to False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A dictionary grouping sites on top and bottom of the slab together.</span>
<span class="sd">                {&quot;top&quot;: [sites with indices], &quot;bottom&quot;: [sites with indices]}</span>

<span class="sd">        Todo:</span>
<span class="sd">            Is there a way to determine site equivalence between sites in a slab</span>
<span class="sd">            and bulk system? This would allow us get the coordination number of</span>
<span class="sd">            a specific site for multi-elemental systems or systems with more</span>
<span class="sd">            than one inequivalent site. This will allow us to use this for</span>
<span class="sd">            compound systems.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">pymatgen.analysis.local_env</span><span class="w"> </span><span class="kn">import</span> <span class="n">VoronoiNN</span>

        <span class="c1"># Get a dictionary of coordination numbers for each distinct site in the structure</span>
        <span class="n">spg_analyzer</span> <span class="o">=</span> <span class="n">SpacegroupAnalyzer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">oriented_unit_cell</span><span class="p">)</span>
        <span class="n">u_cell</span> <span class="o">=</span> <span class="n">spg_analyzer</span><span class="o">.</span><span class="n">get_symmetrized_structure</span><span class="p">()</span>
        <span class="n">cn_dict</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">voronoi_nn</span> <span class="o">=</span> <span class="n">VoronoiNN</span><span class="p">()</span>
        <span class="n">unique_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">equ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">equ</span> <span class="ow">in</span> <span class="n">u_cell</span><span class="o">.</span><span class="n">equivalent_indices</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">unique_indices</span><span class="p">:</span>
            <span class="n">el</span> <span class="o">=</span> <span class="n">u_cell</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">species_string</span>
            <span class="k">if</span> <span class="n">el</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cn_dict</span><span class="p">:</span>
                <span class="n">cn_dict</span><span class="p">[</span><span class="n">el</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># Since this will get the CN as a result of the weighted polyhedra, the</span>
            <span class="c1"># slightest difference in CN will indicate a different environment for a</span>
            <span class="c1"># species, eg. bond distance of each neighbor or neighbor species. The</span>
            <span class="c1"># decimal place to get some CN to be equal.</span>
            <span class="n">cn</span> <span class="o">=</span> <span class="n">voronoi_nn</span><span class="o">.</span><span class="n">get_cn</span><span class="p">(</span><span class="n">u_cell</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">use_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">cn</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">cn</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cn</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cn_dict</span><span class="p">[</span><span class="n">el</span><span class="p">]:</span>
                <span class="n">cn_dict</span><span class="p">[</span><span class="n">el</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cn</span><span class="p">)</span>

        <span class="n">voronoi_nn</span> <span class="o">=</span> <span class="n">VoronoiNN</span><span class="p">()</span>

        <span class="n">surf_sites_dict</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;top&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;bottom&quot;</span><span class="p">:</span> <span class="p">[]}</span>
        <span class="n">properties</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">site</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c1"># Determine if site is closer to the top or bottom of the slab</span>
            <span class="n">is_top</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># A site is a surface site, if its environment does</span>
                <span class="c1"># not fit the environment of other sites</span>
                <span class="n">cn</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">voronoi_nn</span><span class="o">.</span><span class="n">get_cn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">idx</span><span class="p">,</span><span class="w"> </span><span class="n">use_weights</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">cn</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="n">cn_dict</span><span class="p">[</span><span class="n">site</span><span class="o">.</span><span class="n">species_string</span><span class="p">]):</span>
                    <span class="n">properties</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;top&quot;</span> <span class="k">if</span> <span class="n">is_top</span> <span class="k">else</span> <span class="s2">&quot;bottom&quot;</span>
                    <span class="n">surf_sites_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">site</span><span class="p">,</span> <span class="n">idx</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">properties</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
                <span class="c1"># or if pathological error is returned, indicating a surface site</span>
                <span class="n">properties</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;top&quot;</span> <span class="k">if</span> <span class="n">is_top</span> <span class="k">else</span> <span class="s2">&quot;bottom&quot;</span>
                <span class="n">surf_sites_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">site</span><span class="p">,</span> <span class="n">idx</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">tag</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_site_property</span><span class="p">(</span><span class="s2">&quot;is_surf_site&quot;</span><span class="p">,</span> <span class="n">properties</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">surf_sites_dict</span></div>


<div class="viewcode-block" id="Slab.get_symmetric_site">
<a class="viewcode-back" href="../../../pymatgen.core.html#pymatgen.core.surface.Slab.get_symmetric_site">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_symmetric_site</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">point</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">cartesian</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Use symmetry operations to find an equivalent site on the other side of</span>
<span class="sd">        the slab. Works mainly for slabs with Laue symmetry.</span>

<span class="sd">        This is useful for retaining the non-polar and</span>
<span class="sd">        symmetric properties of a slab when creating adsorbed</span>
<span class="sd">        structures or symmetric reconstructions.</span>

<span class="sd">        Args:</span>
<span class="sd">            point (ArrayLike): Fractional coordinate of the original site.</span>
<span class="sd">            cartesian (bool): Use Cartesian coordinates.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ArrayLike: Fractional coordinate. A site equivalent to the</span>
<span class="sd">                original site, but on the other side of the slab</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spg_analyzer</span> <span class="o">=</span> <span class="n">SpacegroupAnalyzer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">ops</span> <span class="o">=</span> <span class="n">spg_analyzer</span><span class="o">.</span><span class="n">get_symmetry_operations</span><span class="p">(</span><span class="n">cartesian</span><span class="o">=</span><span class="n">cartesian</span><span class="p">)</span>

        <span class="c1"># Each operation on a site will return an equivalent site.</span>
        <span class="c1"># We want to find the site on the other side of the slab.</span>
        <span class="n">site_other</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">:</span>
            <span class="n">slab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">site_other</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">operate</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">site_other</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">point</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">abs_tol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="c1"># Add dummy sites to check if the overall structure is symmetric</span>
            <span class="n">slab</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;O&quot;</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">coords_are_cartesian</span><span class="o">=</span><span class="n">cartesian</span><span class="p">)</span>
            <span class="n">slab</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;O&quot;</span><span class="p">,</span> <span class="n">site_other</span><span class="p">,</span> <span class="n">coords_are_cartesian</span><span class="o">=</span><span class="n">cartesian</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">SpacegroupAnalyzer</span><span class="p">(</span><span class="n">slab</span><span class="p">)</span><span class="o">.</span><span class="n">is_laue</span><span class="p">():</span>
                <span class="k">break</span>

            <span class="c1"># If not symmetric, remove the two added</span>
            <span class="c1"># sites and try another symmetry operator</span>
            <span class="n">slab</span><span class="o">.</span><span class="n">remove_sites</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">slab</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">slab</span><span class="o">.</span><span class="n">remove_sites</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">slab</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">site_other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Failed to get symmetric site.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">site_other</span></div>


<div class="viewcode-block" id="Slab.get_orthogonal_c_slab">
<a class="viewcode-back" href="../../../pymatgen.core.html#pymatgen.core.surface.Slab.get_orthogonal_c_slab">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_orthogonal_c_slab</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate a Slab where the normal (c lattice vector) is</span>
<span class="sd">        forced to be orthogonal to the surface a and b lattice vectors.</span>

<span class="sd">        **Note that this breaks inherent symmetries in the slab.**</span>

<span class="sd">        It should be pointed out that orthogonality is not required to get good</span>
<span class="sd">        surface energies, but it can be useful in cases where the slabs are</span>
<span class="sd">        subsequently used for postprocessing of some kind, e.g. generating</span>
<span class="sd">        grain boundaries or interfaces.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">matrix</span>
        <span class="n">_new_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">_new_c</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">_new_c</span><span class="p">)</span>
        <span class="n">new_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">_new_c</span><span class="p">)</span> <span class="o">*</span> <span class="n">_new_c</span>
        <span class="n">new_latt</span> <span class="o">=</span> <span class="n">Lattice</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">new_c</span><span class="p">])</span>

        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span>
            <span class="n">lattice</span><span class="o">=</span><span class="n">new_latt</span><span class="p">,</span>
            <span class="n">species</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">species_and_occu</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cart_coords</span><span class="p">,</span>
            <span class="n">miller_index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">miller_index</span><span class="p">,</span>
            <span class="n">oriented_unit_cell</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">oriented_unit_cell</span><span class="p">,</span>
            <span class="n">shift</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">,</span>
            <span class="n">scale_factor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_factor</span><span class="p">,</span>
            <span class="n">coords_are_cartesian</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">energy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">energy</span><span class="p">,</span>
            <span class="n">reorient_lattice</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reorient_lattice</span><span class="p">,</span>
            <span class="n">site_properties</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">site_properties</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Slab.get_tasker2_slabs">
<a class="viewcode-back" href="../../../pymatgen.core.html#pymatgen.core.surface.Slab.get_tasker2_slabs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_tasker2_slabs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
        <span class="n">same_species_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Self</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a list of slabs that have been Tasker 2 corrected.</span>

<span class="sd">        Args:</span>
<span class="sd">            tol (float): Fractional tolerance to determine if atoms are within same plane.</span>
<span class="sd">            same_species_only (bool): If True, only those are of the exact same</span>
<span class="sd">                species as the atom at the outermost surface are considered for moving.</span>
<span class="sd">                Otherwise, all atoms regardless of species within tol are considered for moving.</span>
<span class="sd">                Default is True (usually the desired behavior).</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[Slab]: Tasker 2 corrected slabs.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">get_equi_index</span><span class="p">(</span><span class="n">site</span><span class="p">:</span> <span class="n">PeriodicSite</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Get the index of the equivalent site for a given site.&quot;&quot;&quot;</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">equi_sites</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">symm_structure</span><span class="o">.</span><span class="n">equivalent_sites</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">equi_sites</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">idx</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot determine equi index!&quot;</span><span class="p">)</span>

        <span class="n">sites</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">)</span>
        <span class="n">slabs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">sorted_csites</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">sites</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">site</span><span class="p">:</span> <span class="n">site</span><span class="o">.</span><span class="n">c</span><span class="p">)</span>

        <span class="c1"># Determine what fraction the slab is of the total cell size in the</span>
        <span class="c1"># c direction. Round to nearest rational number.</span>
        <span class="n">n_layers_total</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">c</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">oriented_unit_cell</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">c</span><span class="p">)</span>
        <span class="n">n_layers_slab</span> <span class="o">=</span> <span class="nb">round</span><span class="p">((</span><span class="n">sorted_csites</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">c</span> <span class="o">-</span> <span class="n">sorted_csites</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="n">n_layers_total</span><span class="p">)</span>
        <span class="n">slab_ratio</span> <span class="o">=</span> <span class="n">n_layers_slab</span> <span class="o">/</span> <span class="n">n_layers_total</span>

        <span class="n">spg_analyzer</span> <span class="o">=</span> <span class="n">SpacegroupAnalyzer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">symm_structure</span> <span class="o">=</span> <span class="n">spg_analyzer</span><span class="o">.</span><span class="n">get_symmetrized_structure</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">surface_site</span><span class="p">,</span> <span class="n">shift</span> <span class="ow">in</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">sorted_csites</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">slab_ratio</span><span class="p">),</span>
            <span class="p">(</span><span class="n">sorted_csites</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">slab_ratio</span><span class="p">),</span>
        <span class="p">]:</span>
            <span class="n">to_move</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">fixed</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">sites</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">surface_site</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">abs_tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                    <span class="p">(</span><span class="ow">not</span> <span class="n">same_species_only</span><span class="p">)</span> <span class="ow">or</span> <span class="n">site</span><span class="o">.</span><span class="n">species</span> <span class="o">==</span> <span class="n">surface_site</span><span class="o">.</span><span class="n">species</span>
                <span class="p">):</span>
                    <span class="n">to_move</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fixed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site</span><span class="p">)</span>

            <span class="c1"># Sort and group the sites by the species and symmetry equivalence</span>
            <span class="n">to_move</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">to_move</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">get_equi_index</span><span class="p">)</span>

            <span class="n">grouped</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">sites</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">to_move</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">get_equi_index</span><span class="p">)]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_move</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grouped</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Odd number of sites to divide! Try changing &quot;</span>
                    <span class="s2">&quot;the tolerance to ensure even division of &quot;</span>
                    <span class="s2">&quot;sites or create supercells in a or b directions &quot;</span>
                    <span class="s2">&quot;to allow for atoms to be moved!&quot;</span><span class="p">,</span>
                    <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">combinations</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grouped</span><span class="p">:</span>
                <span class="n">combinations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)))</span>

            <span class="k">for</span> <span class="n">selection</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">combinations</span><span class="p">):</span>
                <span class="n">species</span> <span class="o">=</span> <span class="p">[</span><span class="n">site</span><span class="o">.</span><span class="n">species</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">fixed</span><span class="p">]</span>
                <span class="n">frac_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">site</span><span class="o">.</span><span class="n">frac_coords</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">fixed</span><span class="p">]</span>

                <span class="k">for</span> <span class="n">struct_matcher</span> <span class="ow">in</span> <span class="n">to_move</span><span class="p">:</span>
                    <span class="n">species</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">struct_matcher</span><span class="o">.</span><span class="n">species</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">selection</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">struct_matcher</span> <span class="ow">in</span> <span class="n">group</span><span class="p">:</span>
                            <span class="n">frac_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">struct_matcher</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">)</span>
                            <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Move unselected atom to the opposite surface.</span>
                        <span class="n">frac_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">struct_matcher</span><span class="o">.</span><span class="n">frac_coords</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shift</span><span class="p">]))</span>

                <span class="c1"># sort by species to put all similar species together.</span>
                <span class="n">sp_fcoord</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">species</span><span class="p">,</span> <span class="n">frac_coords</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">species</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sp_fcoord</span><span class="p">]</span>
                <span class="n">frac_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sp_fcoord</span><span class="p">]</span>
                <span class="n">slab</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span>
                    <span class="n">species</span><span class="p">,</span>
                    <span class="n">frac_coords</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">miller_index</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">oriented_unit_cell</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">scale_factor</span><span class="p">,</span>
                    <span class="n">energy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">energy</span><span class="p">,</span>
                    <span class="n">reorient_lattice</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reorient_lattice</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">slabs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slab</span><span class="p">)</span>
        <span class="n">struct_matcher</span> <span class="o">=</span> <span class="n">StructureMatcher</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">ss</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">struct_matcher</span><span class="o">.</span><span class="n">group_structures</span><span class="p">(</span><span class="n">slabs</span><span class="p">)]</span></div>


<div class="viewcode-block" id="Slab.get_sorted_structure">
<a class="viewcode-back" href="../../../pymatgen.core.html#pymatgen.core.surface.Slab.get_sorted_structure">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_sorted_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reverse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a sorted copy of the structure. The parameters have the same</span>
<span class="sd">        meaning as in list.sort. By default, sites are sorted by the</span>
<span class="sd">        electronegativity of the species. Note that Slab has to override this</span>
<span class="sd">        because of the different __init__ args.</span>

<span class="sd">        Args:</span>
<span class="sd">            key: Specifies a function of one argument that is used to extract</span>
<span class="sd">                a comparison key from each list element: key=str.lower. The</span>
<span class="sd">                default value is None (compare the elements directly).</span>
<span class="sd">            reverse (bool): If set to True, then the list elements are sorted</span>
<span class="sd">                as if each comparison were reversed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sites</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>
        <span class="n">struct</span> <span class="o">=</span> <span class="n">Structure</span><span class="o">.</span><span class="n">from_sites</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span>
            <span class="n">struct</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span>
            <span class="n">struct</span><span class="o">.</span><span class="n">species_and_occu</span><span class="p">,</span>
            <span class="n">struct</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">miller_index</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">oriented_unit_cell</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale_factor</span><span class="p">,</span>
            <span class="n">site_properties</span><span class="o">=</span><span class="n">struct</span><span class="o">.</span><span class="n">site_properties</span><span class="p">,</span>
            <span class="n">reorient_lattice</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reorient_lattice</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Slab.add_adsorbate_atom">
<a class="viewcode-back" href="../../../pymatgen.core.html#pymatgen.core.surface.Slab.add_adsorbate_atom">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_adsorbate_atom</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">indices</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">species</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Element</span> <span class="o">|</span> <span class="n">Species</span><span class="p">,</span>
        <span class="n">distance</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">specie</span><span class="p">:</span> <span class="n">Species</span> <span class="o">|</span> <span class="n">Element</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add adsorbate onto the Slab, along the c lattice vector.</span>

<span class="sd">        Args:</span>
<span class="sd">            indices (list[int]): Indices of sites on which to put the adsorbate.</span>
<span class="sd">                Adsorbate will be placed relative to the center of these sites.</span>
<span class="sd">            species (str | Element | Species): The species to add.</span>
<span class="sd">            distance (float): between centers of the adsorbed atom and the</span>
<span class="sd">                given site in Angstroms, along the c lattice vector.</span>
<span class="sd">            specie: Deprecated argument in #3691. Use &#39;species&#39; instead.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Slab: self with adsorbed atom.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if deprecated argument is used</span>
        <span class="k">if</span> <span class="n">specie</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;The argument &#39;specie&#39; is deprecated. Use &#39;species&#39; instead.&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span>
            <span class="p">)</span>
            <span class="n">species</span> <span class="o">=</span> <span class="n">specie</span>

        <span class="c1"># Calculate target site as the center of sites</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="bp">self</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">coords</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="n">center</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal</span> <span class="o">*</span> <span class="n">distance</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">species</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">coords_are_cartesian</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="Slab.symmetrically_add_atom">
<a class="viewcode-back" href="../../../pymatgen.core.html#pymatgen.core.surface.Slab.symmetrically_add_atom">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">symmetrically_add_atom</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">species</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Element</span> <span class="o">|</span> <span class="n">Species</span><span class="p">,</span>
        <span class="n">point</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">specie</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Element</span> <span class="o">|</span> <span class="n">Species</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">coords_are_cartesian</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a species at a selected site in a Slab. Will also add an</span>
<span class="sd">        equivalent site on the other side to maintain symmetry.</span>

<span class="sd">        Args:</span>
<span class="sd">            species (str | Element | Species): The species to add.</span>
<span class="sd">            point (ArrayLike): The coordinate of the target site.</span>
<span class="sd">            specie: Deprecated argument name in #3691. Use &#39;species&#39; instead.</span>
<span class="sd">            coords_are_cartesian (bool): If the site is in Cartesian coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if deprecated argument is used</span>
        <span class="k">if</span> <span class="n">specie</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;The argument &#39;specie&#39; is deprecated. Use &#39;species&#39; instead.&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span>
            <span class="p">)</span>
            <span class="n">species</span> <span class="o">=</span> <span class="n">specie</span>

        <span class="c1"># Get the index of the equivalent site on the other side</span>
        <span class="n">equi_site</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_symmetric_site</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">cartesian</span><span class="o">=</span><span class="n">coords_are_cartesian</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">species</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">coords_are_cartesian</span><span class="o">=</span><span class="n">coords_are_cartesian</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">species</span><span class="p">,</span> <span class="n">equi_site</span><span class="p">,</span> <span class="n">coords_are_cartesian</span><span class="o">=</span><span class="n">coords_are_cartesian</span><span class="p">)</span></div>


<div class="viewcode-block" id="Slab.symmetrically_remove_atoms">
<a class="viewcode-back" href="../../../pymatgen.core.html#pymatgen.core.surface.Slab.symmetrically_remove_atoms">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">symmetrically_remove_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove sites from a list of indices. Will also remove the</span>
<span class="sd">        equivalent site on the other side of the slab to maintain symmetry.</span>

<span class="sd">        Args:</span>
<span class="sd">            indices (list[int]): The indices of the sites to remove.</span>

<span class="sd">        TODO(@DanielYang59):</span>
<span class="sd">        1. Reuse public method get_symmetric_site to get equi sites?</span>
<span class="sd">        2. If not 1, get_equi_sites has multiple nested loops</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">get_equi_sites</span><span class="p">(</span><span class="n">slab</span><span class="p">:</span> <span class="n">Slab</span><span class="p">,</span> <span class="n">sites</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Get the indices of the equivalent sites of given sites.</span>

<span class="sd">            Parameters:</span>
<span class="sd">                slab (Slab): The slab structure.</span>
<span class="sd">                sites (list[int]): Original indices of sites.</span>

<span class="sd">            Returns:</span>
<span class="sd">                list[int]: Indices of the equivalent sites.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">equi_sites</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">eq_indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">eq_sites</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">sites</span><span class="p">:</span>
                <span class="c1"># Get the index of the original site</span>
                <span class="n">cart_point</span> <span class="o">=</span> <span class="n">slab</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">get_cartesian_coords</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="p">[</span><span class="n">site</span><span class="o">.</span><span class="n">distance_from_point</span><span class="p">(</span><span class="n">cart_point</span><span class="p">)</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">slab</span><span class="p">]</span>
                <span class="n">site1</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">dist</span><span class="p">))</span>

                <span class="c1"># Get the index of the equivalent site on the other side</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">eq_sites</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">slab</span><span class="o">.</span><span class="n">equivalent_sites</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">slab</span><span class="p">[</span><span class="n">site1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">eq_sites</span><span class="p">:</span>
                        <span class="n">eq_indices</span> <span class="o">=</span> <span class="n">slab</span><span class="o">.</span><span class="n">equivalent_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="k">break</span>
                <span class="n">i1</span> <span class="o">=</span> <span class="n">eq_indices</span><span class="p">[</span><span class="n">eq_sites</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">slab</span><span class="p">[</span><span class="n">site1</span><span class="p">])]</span>

                <span class="k">for</span> <span class="n">i2</span> <span class="ow">in</span> <span class="n">eq_indices</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i2</span> <span class="o">==</span> <span class="n">i1</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">slab</span><span class="p">[</span><span class="n">i2</span><span class="p">]</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">slab</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                        <span class="k">continue</span>
                    <span class="c1"># Test site remove to see if it results in symmetric slab</span>
                    <span class="n">slab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">slab</span><span class="o">.</span><span class="n">remove_sites</span><span class="p">([</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">slab</span><span class="o">.</span><span class="n">is_symmetric</span><span class="p">():</span>
                        <span class="n">equi_sites</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i2</span><span class="p">)</span>
                        <span class="k">break</span>

            <span class="k">return</span> <span class="n">equi_sites</span>

        <span class="c1"># Generate the equivalent sites of the original sites</span>
        <span class="n">slab_copy</span> <span class="o">=</span> <span class="n">SpacegroupAnalyzer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span><span class="o">.</span><span class="n">get_symmetrized_structure</span><span class="p">()</span>
        <span class="n">sites</span> <span class="o">=</span> <span class="p">[</span><span class="n">slab_copy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">frac_coords</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>

        <span class="n">equi_sites</span> <span class="o">=</span> <span class="n">get_equi_sites</span><span class="p">(</span><span class="n">slab_copy</span><span class="p">,</span> <span class="n">sites</span><span class="p">)</span>

        <span class="c1"># Check if found any equivalent sites</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">equi_sites</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_sites</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_sites</span><span class="p">(</span><span class="n">equi_sites</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Equivalent sites could not be found for some indices. Surface unchanged.&quot;</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="center_slab">
<a class="viewcode-back" href="../../../pymatgen.core.html#pymatgen.core.surface.center_slab">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">center_slab</span><span class="p">(</span><span class="n">slab</span><span class="p">:</span> <span class="n">Structure</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Structure</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Relocate the slab to the center such that its center</span>
<span class="sd">    (the slab region) is close to z=0.5.</span>

<span class="sd">    This makes it easier to find surface sites and apply</span>
<span class="sd">    operations like doping.</span>

<span class="sd">    There are two possible cases:</span>
<span class="sd">        1. When the slab region is completely positioned between</span>
<span class="sd">        two vacuum layers in the cell but is not centered, we simply</span>
<span class="sd">        shift the slab to the center along z-axis.</span>
<span class="sd">        2. If the slab completely resides outside the cell either</span>
<span class="sd">        from the bottom or the top, we iterate through all sites that</span>
<span class="sd">        spill over and shift all sites such that it is now</span>
<span class="sd">        on the other side. An edge case being, either the top</span>
<span class="sd">        of the slab is at z = 0 or the bottom is at z = 1.</span>

<span class="sd">    Args:</span>
<span class="sd">        slab (Structure): The slab to center.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Structure: The centered slab.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get all site indices</span>
    <span class="n">all_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">slab</span><span class="p">)))</span>

    <span class="c1"># Get a reasonable cutoff radius to sample neighbors</span>
    <span class="n">bond_dists</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">nn</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="n">slab</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">slab</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">10</span><span class="p">)</span> <span class="k">if</span> <span class="n">nn</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="c1"># TODO (@DanielYang59): magic number for cutoff radius (would 3 be too large?)</span>
    <span class="n">cutoff_radius</span> <span class="o">=</span> <span class="n">bond_dists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>

    <span class="c1"># TODO (@DanielYang59): do we need the following complex method?</span>
    <span class="c1"># Why don&#39;t we just calculate the center of the Slab and move it to z=0.5?</span>
    <span class="c1"># Before moving we need to ensure there is only one Slab layer though</span>

    <span class="c1"># If structure is case 2, shift all the sites</span>
    <span class="c1"># to the other side until it is case 1</span>
    <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">slab</span><span class="p">:</span>  <span class="c1"># DEBUG (@DanielYang59): Slab position changes during loop?</span>
        <span class="c1"># DEBUG (@DanielYang59): sites below z=0 is not considered (only check coord &gt; c)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">nn</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">slab</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">c</span> <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="n">slab</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">site</span><span class="p">,</span> <span class="n">cutoff_radius</span><span class="p">)):</span>
            <span class="c1"># TODO (@DanielYang59): the magic offset &quot;0.05&quot; seems unnecessary,</span>
            <span class="c1"># as the Slab would be centered later anyway</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">site</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.05</span>
            <span class="n">slab</span><span class="o">.</span><span class="n">translate_sites</span><span class="p">(</span><span class="n">all_indices</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shift</span><span class="p">])</span>

    <span class="c1"># Now the slab is case 1, move it to the center</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="n">site</span><span class="o">.</span><span class="n">species</span><span class="o">.</span><span class="n">weight</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">slab</span><span class="p">]</span>
    <span class="n">center_of_mass</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">slab</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">shift</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">center_of_mass</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">slab</span><span class="o">.</span><span class="n">translate_sites</span><span class="p">(</span><span class="n">all_indices</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shift</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">slab</span></div>



<div class="viewcode-block" id="get_slab_regions">
<a class="viewcode-back" href="../../../pymatgen.core.html#pymatgen.core.surface.get_slab_regions">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_slab_regions</span><span class="p">(</span>
    <span class="n">slab</span><span class="p">:</span> <span class="n">Slab</span><span class="p">,</span>
    <span class="n">blength</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">3.5</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find the z-ranges for the slab region.</span>

<span class="sd">    Useful for discerning where the slab ends and vacuum begins</span>
<span class="sd">    if the slab is not fully within the cell.</span>

<span class="sd">    Args:</span>
<span class="sd">        slab (Slab): The Slab to analyse.</span>
<span class="sd">        blength (float): The bond length between atoms in Angstrom.</span>
<span class="sd">            You generally want this value to be larger than the actual</span>
<span class="sd">            bond length in order to find atoms that are part of the slab.</span>

<span class="sd">    TODO (@DanielYang59): this should be a method for `Slab`?</span>
<span class="sd">    TODO (@DanielYang59): maybe project all z coordinates to 1D?</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">frac_coords</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># TODO (@DanielYang59): zip site and coords?</span>
    <span class="n">indices</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">all_indices</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">slab</span><span class="p">:</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">slab</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">site</span><span class="p">,</span> <span class="n">blength</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
            <span class="c1"># TODO (@DanielYang59): use z coordinate (z&lt;0) to check</span>
            <span class="c1"># if a Slab is contiguous is suspicious (Slab could locate</span>
            <span class="c1"># entirely below z=0)</span>

            <span class="c1"># Find sites with z &lt; 0 (sites noncontiguous within cell)</span>
            <span class="k">if</span> <span class="n">nn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">frac_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nn</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">nn</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_indices</span><span class="p">:</span>
                    <span class="n">all_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nn</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>

    <span class="c1"># If slab is noncontiguous</span>
    <span class="k">if</span> <span class="n">frac_coords</span><span class="p">:</span>
        <span class="c1"># Locate the lowest site within the upper Slab</span>
        <span class="n">last_frac_coords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">last_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">frac_coords</span><span class="p">:</span>
            <span class="n">last_frac_coords</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">frac_coords</span><span class="p">)</span>
            <span class="n">last_indices</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

            <span class="n">site</span> <span class="o">=</span> <span class="n">slab</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">frac_coords</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">frac_coords</span><span class="p">))]]</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="n">slab</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">site</span><span class="p">,</span> <span class="n">blength</span><span class="p">,</span> <span class="n">include_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">include_image</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">frac_coords</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
                <span class="k">if</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">nn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">nn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">site</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                    <span class="c1"># Sites are noncontiguous within cell</span>
                    <span class="n">frac_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                    <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nn</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">nn</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_indices</span><span class="p">:</span>
                        <span class="n">all_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nn</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>

        <span class="c1"># Locate the highest site within the lower Slab</span>
        <span class="n">upper_fcoords</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">slab</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_indices</span> <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="n">slab</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">site</span><span class="p">,</span> <span class="n">blength</span><span class="p">)):</span>
                <span class="n">upper_fcoords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">coords</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">frac_coords</span><span class="p">)</span> <span class="k">if</span> <span class="n">frac_coords</span> <span class="k">else</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">last_frac_coords</span><span class="p">)</span>
        <span class="n">min_top</span> <span class="o">=</span> <span class="n">slab</span><span class="p">[</span><span class="n">last_indices</span><span class="p">[</span><span class="n">coords</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">coords</span><span class="p">))]]</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">upper_fcoords</span><span class="p">)),</span> <span class="p">(</span><span class="n">min_top</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>

    <span class="c1"># If the entire slab region is within the cell, just</span>
    <span class="c1"># set the range as the highest and lowest site in the Slab</span>
    <span class="n">sorted_sites</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">slab</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">site</span><span class="p">:</span> <span class="n">site</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">return</span> <span class="p">[(</span><span class="n">sorted_sites</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">sorted_sites</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">])]</span></div>



<div class="viewcode-block" id="SlabGenerator">
<a class="viewcode-back" href="../../../pymatgen.core.html#pymatgen.core.surface.SlabGenerator">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SlabGenerator</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate different slabs using shift values determined by where</span>
<span class="sd">    a unique termination can be found, along with other criteria such as where a</span>
<span class="sd">    termination doesn&#39;t break a polyhedral bond. The shift value then indicates</span>
<span class="sd">    where the slab layer will begin and terminate in the slab-vacuum system.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        oriented_unit_cell (Structure): An oriented unit cell of the parent structure.</span>
<span class="sd">        parent (Structure): Parent structure from which Slab was derived.</span>
<span class="sd">        lll_reduce (bool): Whether the slabs will be orthogonalized.</span>
<span class="sd">        center_slab (bool): Whether the slabs will be centered in the slab-vacuum system.</span>
<span class="sd">        slab_scale_factor (float): Scale factor that brings</span>
<span class="sd">            the parent cell to the surface cell.</span>
<span class="sd">        miller_index (tuple): Miller index of plane parallel to surface.</span>
<span class="sd">        min_slab_size (float): Minimum size of layers containing atoms, in angstroms.</span>
<span class="sd">        min_vac_size (float): Minimum vacuum layer size, in angstroms.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">initial_structure</span><span class="p">:</span> <span class="n">Structure</span><span class="p">,</span>
        <span class="n">miller_index</span><span class="p">:</span> <span class="n">MillerIndex</span><span class="p">,</span>
        <span class="n">min_slab_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">min_vacuum_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">lll_reduce</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">center_slab</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">in_unit_planes</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">primitive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">max_normal_search</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">reorient_lattice</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the slab scale factor and uses it to generate an</span>
<span class="sd">        oriented unit cell (OUC) of the initial structure.</span>
<span class="sd">        Also stores the initial information needed later on to generate a slab.</span>

<span class="sd">        Args:</span>
<span class="sd">            initial_structure (Structure): Initial input structure. Note that to</span>
<span class="sd">                ensure that the Miller indices correspond to usual</span>
<span class="sd">                crystallographic definitions, you should supply a conventional</span>
<span class="sd">                unit cell structure.</span>
<span class="sd">            miller_index ([h, k, l]): Miller index of the plane parallel to</span>
<span class="sd">                the surface. Note that this is referenced to the input structure.</span>
<span class="sd">                If you need this to be based on the conventional cell,</span>
<span class="sd">                you should supply the conventional structure.</span>
<span class="sd">            min_slab_size (float): In Angstroms or number of hkl planes</span>
<span class="sd">            min_vacuum_size (float): In Angstroms or number of hkl planes</span>
<span class="sd">            lll_reduce (bool): Whether to perform an LLL reduction on the</span>
<span class="sd">                final structure.</span>
<span class="sd">            center_slab (bool): Whether to center the slab in the cell with</span>
<span class="sd">                equal vacuum spacing from the top and bottom.</span>
<span class="sd">            in_unit_planes (bool): Whether to set min_slab_size and min_vac_size</span>
<span class="sd">                in number of hkl planes or Angstrom (default).</span>
<span class="sd">                Setting in units of planes is useful to ensure some slabs</span>
<span class="sd">                to have a certain number of layers, e.g. for Cs(100), 10 Ang</span>
<span class="sd">                will result in a slab with only 2 layers, whereas</span>
<span class="sd">                Fe(100) will have more layers. The slab thickness</span>
<span class="sd">                will be in min_slab_size/math.ceil(self._proj_height/dhkl)</span>
<span class="sd">                multiples of oriented unit cells.</span>
<span class="sd">            primitive (bool): Whether to reduce generated slabs to</span>
<span class="sd">                primitive cell. Note this does NOT generate a slab</span>
<span class="sd">                from a primitive cell, it means that after slab</span>
<span class="sd">                generation, we attempt to reduce the generated slab to</span>
<span class="sd">                primitive cell.</span>
<span class="sd">            max_normal_search (int): If set to a positive integer, the code</span>
<span class="sd">                will search for a normal lattice vector that is as</span>
<span class="sd">                perpendicular to the surface as possible, by considering</span>
<span class="sd">                multiple linear combinations of lattice vectors up to</span>
<span class="sd">                this value. This has no bearing on surface energies,</span>
<span class="sd">                but may be useful as a preliminary step to generate slabs</span>
<span class="sd">                for absorption or other sizes. It may not be the smallest possible</span>
<span class="sd">                cell for simulation. Normality is not guaranteed, but the oriented</span>
<span class="sd">                cell will have the c vector as normal as possible to the surface.</span>
<span class="sd">                The max absolute Miller index is usually sufficient.</span>
<span class="sd">            reorient_lattice (bool): reorient the lattice such that</span>
<span class="sd">                the c direction is parallel to the third lattice vector</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">reduce_vector</span><span class="p">(</span><span class="n">vector</span><span class="p">:</span> <span class="n">MillerIndex</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MillerIndex</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Helper function to reduce vectors.&quot;&quot;&quot;</span>
            <span class="n">divisor</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">reduce</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">gcd</span><span class="p">,</span> <span class="n">vector</span><span class="p">))</span>  <span class="c1"># type: ignore[arg-type]</span>
            <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">Tuple3Ints</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">idx</span> <span class="o">/</span> <span class="n">divisor</span><span class="p">)</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">vector</span><span class="p">))</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">add_site_types</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Add Wyckoff symbols and equivalent sites to the initial structure.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="s2">&quot;bulk_wyckoff&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">initial_structure</span><span class="o">.</span><span class="n">site_properties</span>
                <span class="ow">or</span> <span class="s2">&quot;bulk_equivalent&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">initial_structure</span><span class="o">.</span><span class="n">site_properties</span>
            <span class="p">):</span>
                <span class="n">spg_analyzer</span> <span class="o">=</span> <span class="n">SpacegroupAnalyzer</span><span class="p">(</span><span class="n">initial_structure</span><span class="p">)</span>
                <span class="n">initial_structure</span><span class="o">.</span><span class="n">add_site_property</span><span class="p">(</span><span class="s2">&quot;bulk_wyckoff&quot;</span><span class="p">,</span> <span class="n">spg_analyzer</span><span class="o">.</span><span class="n">get_symmetry_dataset</span><span class="p">()</span><span class="o">.</span><span class="n">wyckoffs</span><span class="p">)</span>
                <span class="n">initial_structure</span><span class="o">.</span><span class="n">add_site_property</span><span class="p">(</span>
                    <span class="s2">&quot;bulk_equivalent&quot;</span><span class="p">,</span>
                    <span class="n">spg_analyzer</span><span class="o">.</span><span class="n">get_symmetry_dataset</span><span class="p">()</span><span class="o">.</span><span class="n">equivalent_atoms</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                <span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">calculate_surface_normal</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Calculate the unit surface normal vector using the reciprocal</span>
<span class="sd">            lattice vector.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">recip_lattice</span> <span class="o">=</span> <span class="n">lattice</span><span class="o">.</span><span class="n">reciprocal_lattice_crystallographic</span>

            <span class="n">normal</span> <span class="o">=</span> <span class="n">recip_lattice</span><span class="o">.</span><span class="n">get_cartesian_coords</span><span class="p">(</span><span class="n">miller_index</span><span class="p">)</span>
            <span class="n">normal</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">normal</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">calculate_scaling_factor</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Calculate scaling factor.</span>

<span class="sd">            # TODO (@DanielYang59): revise docstring to add more details.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">slab_scale_factor</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">non_orth_ind</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">eye</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">miller_idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">miller_index</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">miller_idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># If lattice vector is perpendicular to surface normal, i.e.,</span>
                    <span class="c1"># in plane of surface. We will simply choose this lattice</span>
                    <span class="c1"># vector as the basis vector</span>
                    <span class="n">slab_scale_factor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eye</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Calculate projection of lattice vector onto surface normal.</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">lattice</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="n">idx</span><span class="p">]))</span> <span class="o">/</span> <span class="n">lattice</span><span class="o">.</span><span class="n">abc</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                    <span class="n">non_orth_ind</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">idx</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>

            <span class="c1"># We want the vector that has maximum magnitude in the</span>
            <span class="c1"># direction of the surface normal as the c-direction.</span>
            <span class="c1"># Results in a more &quot;orthogonal&quot; unit cell.</span>
            <span class="n">c_index</span><span class="p">,</span> <span class="n">_dist</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">non_orth_ind</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">non_orth_ind</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">lcm_miller</span> <span class="o">=</span> <span class="n">lcm</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">miller_index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_d</span> <span class="ow">in</span> <span class="n">non_orth_ind</span><span class="p">))</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">_di</span><span class="p">),</span> <span class="p">(</span><span class="n">jj</span><span class="p">,</span> <span class="n">_dj</span><span class="p">)</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">non_orth_ind</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                    <span class="n">scale_factor</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                    <span class="n">scale_factor</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="nb">round</span><span class="p">(</span><span class="n">lcm_miller</span> <span class="o">/</span> <span class="n">miller_index</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
                    <span class="n">scale_factor</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">lcm_miller</span> <span class="o">/</span> <span class="n">miller_index</span><span class="p">[</span><span class="n">jj</span><span class="p">])</span>
                    <span class="n">slab_scale_factor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scale_factor</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">slab_scale_factor</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="k">break</span>

            <span class="k">if</span> <span class="n">max_normal_search</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">slab_scale_factor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eye</span><span class="p">[</span><span class="n">c_index</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">index_range</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                    <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">max_normal_search</span><span class="p">,</span> <span class="n">max_normal_search</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                    <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="n">candidates</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">uvw</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">index_range</span><span class="p">,</span> <span class="n">index_range</span><span class="p">,</span> <span class="n">index_range</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">uvw</span><span class="p">))</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">([</span><span class="o">*</span><span class="n">slab_scale_factor</span><span class="p">,</span> <span class="n">uvw</span><span class="p">]))</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">vec</span> <span class="o">=</span> <span class="n">lattice</span><span class="o">.</span><span class="n">get_cartesian_coords</span><span class="p">(</span><span class="n">uvw</span><span class="p">)</span>
                    <span class="n">osdm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
                    <span class="n">cosine</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span> <span class="o">/</span> <span class="n">osdm</span><span class="p">)</span>
                    <span class="n">candidates</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">uvw</span><span class="p">,</span> <span class="n">cosine</span><span class="p">,</span> <span class="n">osdm</span><span class="p">))</span>
                    <span class="c1"># Stop searching if cosine equals 1 or -1</span>
                    <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">cosine</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">abs_tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
                        <span class="k">break</span>
                <span class="c1"># We want the indices with the maximum absolute cosine,</span>
                <span class="c1"># but smallest possible length.</span>
                <span class="n">uvw</span><span class="p">,</span> <span class="n">cosine</span><span class="p">,</span> <span class="n">osdm</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
                <span class="n">slab_scale_factor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">uvw</span><span class="p">)</span>

            <span class="n">slab_scale_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">slab_scale_factor</span><span class="p">)</span>

            <span class="c1"># Let&#39;s make sure we have a left-handed crystallographic system</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">slab_scale_factor</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">slab_scale_factor</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

            <span class="c1"># Make sure the slab_scale_factor is reduced to avoid</span>
            <span class="c1"># unnecessarily large slabs</span>
            <span class="n">reduced_scale_factor</span> <span class="o">=</span> <span class="p">[</span><span class="n">reduce_vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">slab_scale_factor</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">reduced_scale_factor</span><span class="p">)</span>

        <span class="c1"># Add Wyckoff symbols and equivalent sites to the initial structure,</span>
        <span class="c1"># to help identify types of sites in the generated slab</span>
        <span class="n">add_site_types</span><span class="p">()</span>

        <span class="c1"># Calculate the surface normal</span>
        <span class="n">lattice</span> <span class="o">=</span> <span class="n">initial_structure</span><span class="o">.</span><span class="n">lattice</span>
        <span class="n">miller_index</span> <span class="o">=</span> <span class="n">reduce_vector</span><span class="p">(</span><span class="n">miller_index</span><span class="p">)</span>
        <span class="n">normal</span> <span class="o">=</span> <span class="n">calculate_surface_normal</span><span class="p">()</span>

        <span class="c1"># Calculate scale factor</span>
        <span class="n">slab_scale_factor</span> <span class="o">=</span> <span class="n">calculate_scaling_factor</span><span class="p">()</span>

        <span class="n">single</span> <span class="o">=</span> <span class="n">initial_structure</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">single</span><span class="o">.</span><span class="n">make_supercell</span><span class="p">(</span><span class="n">slab_scale_factor</span><span class="p">)</span>

        <span class="c1"># Calculate the most reduced structure as OUC to minimize calculations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">oriented_unit_cell</span> <span class="o">=</span> <span class="n">Structure</span><span class="o">.</span><span class="n">from_sites</span><span class="p">(</span><span class="n">single</span><span class="p">,</span> <span class="n">to_unit_cell</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">max_normal_search</span> <span class="o">=</span> <span class="n">max_normal_search</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">initial_structure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lll_reduce</span> <span class="o">=</span> <span class="n">lll_reduce</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">center_slab</span> <span class="o">=</span> <span class="n">center_slab</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slab_scale_factor</span> <span class="o">=</span> <span class="n">slab_scale_factor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">miller_index</span> <span class="o">=</span> <span class="n">miller_index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_vac_size</span> <span class="o">=</span> <span class="n">min_vacuum_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_slab_size</span> <span class="o">=</span> <span class="n">min_slab_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">in_unit_planes</span> <span class="o">=</span> <span class="n">in_unit_planes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">primitive</span> <span class="o">=</span> <span class="n">primitive</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_normal</span> <span class="o">=</span> <span class="n">normal</span>  <span class="c1"># TODO (@DanielYang59): used only in unit test</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reorient_lattice</span> <span class="o">=</span> <span class="n">reorient_lattice</span>

        <span class="n">_a</span><span class="p">,</span> <span class="n">_b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">oriented_unit_cell</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_proj_height</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>

<div class="viewcode-block" id="SlabGenerator.get_slab">
<a class="viewcode-back" href="../../../pymatgen.core.html#pymatgen.core.surface.SlabGenerator.get_slab">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_slab</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">shift</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">energy</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Slab</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;[Private method] Generate a slab based on a given termination</span>
<span class="sd">            coordinate along the lattice c direction.</span>

<span class="sd">        You should RARELY use this method directly.</span>

<span class="sd">        Args:</span>
<span class="sd">            shift (float): The termination coordinate along the lattice c</span>
<span class="sd">                direction in fractional coordinates.</span>
<span class="sd">            tol (float): Tolerance to determine primitive cell.</span>
<span class="sd">            energy (float): The energy to assign to the slab.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Slab: from a shifted oriented unit cell.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate total number of layers</span>
        <span class="n">height</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_proj_height</span>
        <span class="n">height_per_layer</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">height</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">d_hkl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">miller_index</span><span class="p">),</span> <span class="mi">8</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_unit_planes</span><span class="p">:</span>
            <span class="n">n_layers_slab</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_slab_size</span> <span class="o">/</span> <span class="n">height_per_layer</span><span class="p">)</span>
            <span class="n">n_layers_vac</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_vac_size</span> <span class="o">/</span> <span class="n">height_per_layer</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_layers_slab</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_slab_size</span> <span class="o">/</span> <span class="n">height</span><span class="p">)</span>
            <span class="n">n_layers_vac</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_vac_size</span> <span class="o">/</span> <span class="n">height</span><span class="p">)</span>

        <span class="n">n_layers</span> <span class="o">=</span> <span class="n">n_layers_slab</span> <span class="o">+</span> <span class="n">n_layers_vac</span>

        <span class="c1"># Prepare for Slab generation: lattice, species, coords and site_properties</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">oriented_unit_cell</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">matrix</span>
        <span class="n">new_lattice</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">n_layers</span> <span class="o">*</span> <span class="n">c</span><span class="p">]</span>

        <span class="n">species</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">oriented_unit_cell</span><span class="o">.</span><span class="n">species_and_occu</span>

        <span class="c1"># Shift all atoms to the termination</span>
        <span class="n">frac_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">oriented_unit_cell</span><span class="o">.</span><span class="n">frac_coords</span>
        <span class="n">frac_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">frac_coords</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">shift</span><span class="p">])[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">frac_coords</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">frac_coords</span><span class="p">)</span>  <span class="c1"># wrap to the [0, 1) range</span>

        <span class="c1"># Scale down z-coordinate by the number of layers</span>
        <span class="n">frac_coords</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">/=</span> <span class="n">n_layers</span>

        <span class="c1"># Duplicate atom layers by stacking along the z-axis</span>
        <span class="n">all_coords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_layers_slab</span><span class="p">):</span>
            <span class="n">_frac_coords</span> <span class="o">=</span> <span class="n">frac_coords</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">_frac_coords</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">idx</span> <span class="o">/</span> <span class="n">n_layers</span>
            <span class="n">all_coords</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_frac_coords</span><span class="p">)</span>

        <span class="c1"># Scale properties by number of atom layers (excluding vacuum)</span>
        <span class="n">props</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">oriented_unit_cell</span><span class="o">.</span><span class="n">site_properties</span>
        <span class="n">props</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="o">*</span> <span class="n">n_layers_slab</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">props</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="c1"># Generate Slab</span>
        <span class="n">struct</span><span class="p">:</span> <span class="n">Structure</span> <span class="o">=</span> <span class="n">Structure</span><span class="p">(</span><span class="n">new_lattice</span><span class="p">,</span> <span class="n">species</span> <span class="o">*</span> <span class="n">n_layers_slab</span><span class="p">,</span> <span class="n">all_coords</span><span class="p">,</span> <span class="n">site_properties</span><span class="o">=</span><span class="n">props</span><span class="p">)</span>

        <span class="c1"># (Optionally) Post-process the Slab</span>
        <span class="c1"># Orthogonalize the structure (through LLL lattice basis reduction)</span>
        <span class="n">scale_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slab_scale_factor</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lll_reduce</span><span class="p">:</span>
            <span class="c1"># Sanitize Slab (LLL reduction + site sorting + map frac_coords)</span>
            <span class="n">lll_slab</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">sanitize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Apply reduction on the scaling factor</span>
            <span class="n">mapping</span> <span class="o">=</span> <span class="n">lll_slab</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">find_mapping</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">lattice</span><span class="p">)</span>
            <span class="n">struct</span> <span class="o">=</span> <span class="n">lll_slab</span>
            <span class="k">if</span> <span class="n">mapping</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;LLL reduction has failed&quot;</span><span class="p">)</span>
            <span class="n">scale_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mapping</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">scale_factor</span><span class="p">)</span>

        <span class="c1"># Center the slab layer around the vacuum</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">center_slab</span><span class="p">:</span>
            <span class="n">struct</span> <span class="o">=</span> <span class="n">center_slab</span><span class="p">(</span><span class="n">struct</span><span class="p">)</span>

        <span class="c1"># Reduce to primitive cell</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">primitive</span><span class="p">:</span>
            <span class="n">prim_slab</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">get_primitive_structure</span><span class="p">(</span><span class="n">tolerance</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>
            <span class="n">struct</span> <span class="o">=</span> <span class="n">prim_slab</span>

            <span class="k">if</span> <span class="n">energy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">energy</span> <span class="o">*=</span> <span class="n">prim_slab</span><span class="o">.</span><span class="n">volume</span> <span class="o">/</span> <span class="n">struct</span><span class="o">.</span><span class="n">volume</span>

        <span class="c1"># Reorient the lattice to get the correctly reduced cell</span>
        <span class="n">ouc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">oriented_unit_cell</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">primitive</span><span class="p">:</span>
            <span class="c1"># Find a reduced OUC</span>
            <span class="n">slab_l</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">lattice</span>
            <span class="n">ouc</span> <span class="o">=</span> <span class="n">ouc</span><span class="o">.</span><span class="n">get_primitive_structure</span><span class="p">(</span>
                <span class="n">constrain_latt</span><span class="o">=</span><span class="p">{</span>
                    <span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="n">slab_l</span><span class="o">.</span><span class="n">a</span><span class="p">,</span>
                    <span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="n">slab_l</span><span class="o">.</span><span class="n">b</span><span class="p">,</span>
                    <span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="n">slab_l</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span>
                    <span class="s2">&quot;beta&quot;</span><span class="p">:</span> <span class="n">slab_l</span><span class="o">.</span><span class="n">beta</span><span class="p">,</span>
                    <span class="s2">&quot;gamma&quot;</span><span class="p">:</span> <span class="n">slab_l</span><span class="o">.</span><span class="n">gamma</span><span class="p">,</span>
                <span class="p">}</span>
            <span class="p">)</span>

            <span class="c1"># Ensure lattice a and b are consistent between the OUC and the Slab</span>
            <span class="n">ouc</span> <span class="o">=</span> <span class="n">ouc</span> <span class="k">if</span> <span class="p">(</span><span class="n">slab_l</span><span class="o">.</span><span class="n">a</span> <span class="o">==</span> <span class="n">ouc</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">a</span> <span class="ow">and</span> <span class="n">slab_l</span><span class="o">.</span><span class="n">b</span> <span class="o">==</span> <span class="n">ouc</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">b</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">oriented_unit_cell</span>

        <span class="k">return</span> <span class="n">Slab</span><span class="p">(</span>
            <span class="n">struct</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span>
            <span class="n">struct</span><span class="o">.</span><span class="n">species_and_occu</span><span class="p">,</span>
            <span class="n">struct</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">miller_index</span><span class="p">,</span>
            <span class="n">ouc</span><span class="p">,</span>
            <span class="n">shift</span><span class="p">,</span>
            <span class="n">scale_factor</span><span class="p">,</span>
            <span class="n">reorient_lattice</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reorient_lattice</span><span class="p">,</span>
            <span class="n">site_properties</span><span class="o">=</span><span class="n">struct</span><span class="o">.</span><span class="n">site_properties</span><span class="p">,</span>
            <span class="n">energy</span><span class="o">=</span><span class="n">energy</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="SlabGenerator.get_slabs">
<a class="viewcode-back" href="../../../pymatgen.core.html#pymatgen.core.surface.SlabGenerator.get_slabs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_slabs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">bonds</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">Species</span> <span class="o">|</span> <span class="n">Element</span><span class="p">,</span> <span class="n">Species</span> <span class="o">|</span> <span class="n">Element</span><span class="p">],</span> <span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ftol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">max_broken_bonds</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">symmetrize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">repair</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">ztol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">filter_out_sym_slabs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Slab</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate slabs with shift values calculated from the internal</span>
<span class="sd">        gen_possible_terminations func. If the user decide to avoid breaking</span>
<span class="sd">        any polyhedral bond (by setting `bonds`), any shift value that do so</span>
<span class="sd">        would be filtered out.</span>

<span class="sd">        Args:</span>
<span class="sd">            bonds (dict): A {(species1, species2): max_bond_dist} dict.</span>
<span class="sd">                For example, PO4 groups may be defined as {(&quot;P&quot;, &quot;O&quot;): 3}.</span>
<span class="sd">            tol (float): Fractional tolerance for getting primitive cells</span>
<span class="sd">                and matching structures.</span>
<span class="sd">            ftol (float): Threshold for fcluster to check if two atoms are</span>
<span class="sd">                on the same plane. Default to 0.1 Angstrom in the direction of</span>
<span class="sd">                the surface normal.</span>
<span class="sd">            max_broken_bonds (int): Maximum number of allowable broken bonds</span>
<span class="sd">                for the slab. Use this to limit number of slabs. Defaults to 0,</span>
<span class="sd">                which means no bonds could be broken.</span>
<span class="sd">            symmetrize (bool): Whether to enforce the equivalency of slab surfaces.</span>
<span class="sd">            repair (bool): Whether to repair terminations with broken bonds (True)</span>
<span class="sd">                or just omit them (False). Default to False as repairing terminations</span>
<span class="sd">                can lead to many more possible slabs.</span>
<span class="sd">            ztol (float): Fractional tolerance for determine overlapping z-ranges,</span>
<span class="sd">                smaller ztol might result in more possible Slabs.</span>
<span class="sd">            filter_out_sym_slabs (bool): If True filter out identical slabs with different terminations.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[Slab]: All possible Slabs of a particular surface,</span>
<span class="sd">                sorted by the number of bonds broken.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">gen_possible_terminations</span><span class="p">(</span><span class="n">ftol</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Generate possible terminations by clustering z coordinates.</span>

<span class="sd">            Args:</span>
<span class="sd">                ftol (float): Threshold for fcluster to check if</span>
<span class="sd">                    two atoms are on the same plane.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">frac_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">oriented_unit_cell</span><span class="o">.</span><span class="n">frac_coords</span>
            <span class="n">n_atoms</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">frac_coords</span><span class="p">)</span>

            <span class="c1"># Skip clustering when there is only one atom</span>
            <span class="k">if</span> <span class="n">n_atoms</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Put the atom to the center</span>
                <span class="n">termination</span> <span class="o">=</span> <span class="n">frac_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">termination</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">termination</span><span class="p">)]</span>

            <span class="c1"># Compute a Cartesian z-coordinate distance matrix</span>
            <span class="c1"># TODO (@DanielYang59): account for periodic boundary condition</span>
            <span class="n">dist_matrix</span><span class="p">:</span> <span class="n">NDArray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_atoms</span><span class="p">,</span> <span class="n">n_atoms</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_atoms</span><span class="p">)),</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">z_dist</span> <span class="o">=</span> <span class="n">frac_coords</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">frac_coords</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">z_dist</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">z_dist</span> <span class="o">-</span> <span class="nb">round</span><span class="p">(</span><span class="n">z_dist</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_proj_height</span>
                    <span class="n">dist_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">z_dist</span>
                    <span class="n">dist_matrix</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">z_dist</span>

            <span class="c1"># Cluster the sites by z coordinates</span>
            <span class="n">z_matrix</span> <span class="o">=</span> <span class="n">linkage</span><span class="p">(</span><span class="n">squareform</span><span class="p">(</span><span class="n">dist_matrix</span><span class="p">))</span>
            <span class="n">clusters</span> <span class="o">=</span> <span class="n">fcluster</span><span class="p">(</span><span class="n">z_matrix</span><span class="p">,</span> <span class="n">ftol</span><span class="p">,</span> <span class="n">criterion</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span><span class="p">)</span>

            <span class="c1"># Generate cluster to z-coordinate mapping</span>
            <span class="n">clst_loc</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">clst</span><span class="p">:</span> <span class="n">frac_coords</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">clst</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">clusters</span><span class="p">)}</span>

            <span class="c1"># Wrap all clusters into the unit cell ([0, 1) range)</span>
            <span class="n">possible_clst</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">clst_loc</span><span class="o">.</span><span class="n">values</span><span class="p">())]</span>

            <span class="c1"># Calculate terminations</span>
            <span class="n">n_terms</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_clst</span><span class="p">)</span>
            <span class="n">terminations</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_terms</span><span class="p">):</span>
                <span class="c1"># Handle the special case for the first-last pair of</span>
                <span class="c1"># z coordinates (because of periodic boundary condition)</span>
                <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">n_terms</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">termination</span> <span class="o">=</span> <span class="p">(</span><span class="n">possible_clst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">possible_clst</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.5</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">termination</span> <span class="o">=</span> <span class="p">(</span><span class="n">possible_clst</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">possible_clst</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.5</span>

                <span class="c1"># Wrap termination to [0, 1) range</span>
                <span class="n">terminations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">termination</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">termination</span><span class="p">))</span>

            <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">terminations</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">get_z_ranges</span><span class="p">(</span>
            <span class="n">bonds</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">Species</span> <span class="o">|</span> <span class="n">Element</span><span class="p">,</span> <span class="n">Species</span> <span class="o">|</span> <span class="n">Element</span><span class="p">],</span> <span class="nb">float</span><span class="p">],</span>
            <span class="n">ztol</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Collect occupied z ranges where each range is a (lower_z, upper_z) tuple.</span>

<span class="sd">            This method examines all sites in the oriented unit cell (OUC)</span>
<span class="sd">            and considers all neighboring sites within the specified bond distance</span>
<span class="sd">            for each site. If a site and its neighbor meet bonding and species</span>
<span class="sd">            requirements, their respective z-ranges will be collected.</span>

<span class="sd">            Args:</span>
<span class="sd">                bonds (dict): A {(species1, species2): max_bond_dist} dict.</span>
<span class="sd">                ztol (float): Fractional tolerance for determine overlapping z-ranges.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># Sanitize species in dict keys</span>
            <span class="n">bonds</span> <span class="o">=</span> <span class="p">{(</span><span class="n">get_el_sp</span><span class="p">(</span><span class="n">s1</span><span class="p">),</span> <span class="n">get_el_sp</span><span class="p">(</span><span class="n">s2</span><span class="p">)):</span> <span class="n">dist</span> <span class="k">for</span> <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">),</span> <span class="n">dist</span> <span class="ow">in</span> <span class="n">bonds</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

            <span class="n">z_ranges</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">sp1</span><span class="p">,</span> <span class="n">sp2</span><span class="p">),</span> <span class="n">bond_dist</span> <span class="ow">in</span> <span class="n">bonds</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">oriented_unit_cell</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">sp1</span> <span class="ow">in</span> <span class="n">site</span><span class="o">.</span><span class="n">species</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">oriented_unit_cell</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">site</span><span class="p">,</span> <span class="n">bond_dist</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">sp2</span> <span class="ow">in</span> <span class="n">nn</span><span class="o">.</span><span class="n">species</span><span class="p">:</span>
                                <span class="n">z_range</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">site</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">nn</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">]]))</span>

                                <span class="c1"># Handle cases when z coordinate of site goes</span>
                                <span class="c1"># beyond the upper boundary</span>
                                <span class="k">if</span> <span class="n">z_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                                    <span class="n">z_ranges</span><span class="o">.</span><span class="n">extend</span><span class="p">([(</span><span class="n">z_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">z_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)])</span>

                                <span class="c1"># When z coordinate is below the lower boundary</span>
                                <span class="k">elif</span> <span class="n">z_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                                    <span class="n">z_ranges</span><span class="o">.</span><span class="n">extend</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="n">z_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">z_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>

                                <span class="c1"># Neglect overlapping positions</span>
                                <span class="k">elif</span> <span class="ow">not</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">z_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">z_range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">abs_tol</span><span class="o">=</span><span class="n">ztol</span><span class="p">):</span>
                                    <span class="n">z_ranges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z_range</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">z_ranges</span>

        <span class="c1"># Get occupied z_ranges</span>
        <span class="n">z_ranges</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">bonds</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">get_z_ranges</span><span class="p">(</span><span class="n">bonds</span><span class="p">,</span> <span class="n">ztol</span><span class="p">)</span>

        <span class="n">slabs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">termination</span> <span class="ow">in</span> <span class="n">gen_possible_terminations</span><span class="p">(</span><span class="n">ftol</span><span class="o">=</span><span class="n">ftol</span><span class="p">):</span>
            <span class="c1"># Calculate total number of bonds broken (how often the</span>
            <span class="c1"># termination fall within the z_range occupied by a bond)</span>
            <span class="n">bonds_broken</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">z_range</span> <span class="ow">in</span> <span class="n">z_ranges</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">z_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">termination</span> <span class="o">&lt;=</span> <span class="n">z_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">bonds_broken</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># DEBUG(@DanielYang59): number of bonds broken passed to energy</span>
            <span class="c1"># As per the docstring this is to sort final Slabs by number</span>
            <span class="c1"># of bonds broken, but this may very likely lead to errors</span>
            <span class="c1"># if the &quot;energy&quot; is used literally (Maybe reset energy to None?)</span>
            <span class="n">slab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_slab</span><span class="p">(</span><span class="n">shift</span><span class="o">=</span><span class="n">termination</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">energy</span><span class="o">=</span><span class="n">bonds_broken</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">bonds_broken</span> <span class="o">&lt;=</span> <span class="n">max_broken_bonds</span><span class="p">:</span>
                <span class="n">slabs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slab</span><span class="p">)</span>

            <span class="c1"># If the number of broken bonds is exceeded, repair the broken bonds</span>
            <span class="k">elif</span> <span class="n">repair</span> <span class="ow">and</span> <span class="n">bonds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">slabs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">repair_broken_bonds</span><span class="p">(</span><span class="n">slab</span><span class="o">=</span><span class="n">slab</span><span class="p">,</span> <span class="n">bonds</span><span class="o">=</span><span class="n">bonds</span><span class="p">))</span>

        <span class="c1"># Filter out surfaces that might be the same</span>
        <span class="k">if</span> <span class="n">filter_out_sym_slabs</span><span class="p">:</span>
            <span class="n">matcher</span> <span class="o">=</span> <span class="n">StructureMatcher</span><span class="p">(</span><span class="n">ltol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">stol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">primitive_cell</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">final_slabs</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Slab</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">matcher</span><span class="o">.</span><span class="n">group_structures</span><span class="p">(</span><span class="n">slabs</span><span class="p">):</span>
                <span class="c1"># For each unique slab, symmetrize the</span>
                <span class="c1"># surfaces by removing sites from the bottom</span>
                <span class="k">if</span> <span class="n">symmetrize</span><span class="p">:</span>
                    <span class="n">sym_slabs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonstoichiometric_symmetrized_slab</span><span class="p">(</span><span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">final_slabs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sym_slabs</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">final_slabs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># Filter out similar surfaces generated by symmetrization</span>
            <span class="k">if</span> <span class="n">symmetrize</span><span class="p">:</span>
                <span class="n">matcher_sym</span> <span class="o">=</span> <span class="n">StructureMatcher</span><span class="p">(</span><span class="n">ltol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">stol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">primitive_cell</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">final_slabs</span> <span class="o">=</span> <span class="p">[</span><span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">matcher_sym</span><span class="o">.</span><span class="n">group_structures</span><span class="p">(</span><span class="n">final_slabs</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">final_slabs</span> <span class="o">=</span> <span class="n">slabs</span>

        <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="nb">list</span><span class="p">[</span><span class="n">Slab</span><span class="p">],</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">final_slabs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">slab</span><span class="p">:</span> <span class="n">slab</span><span class="o">.</span><span class="n">energy</span><span class="p">))</span></div>


<div class="viewcode-block" id="SlabGenerator.repair_broken_bonds">
<a class="viewcode-back" href="../../../pymatgen.core.html#pymatgen.core.surface.SlabGenerator.repair_broken_bonds">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">repair_broken_bonds</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">slab</span><span class="p">:</span> <span class="n">Slab</span><span class="p">,</span>
        <span class="n">bonds</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">Species</span> <span class="o">|</span> <span class="n">Element</span><span class="p">,</span> <span class="n">Species</span> <span class="o">|</span> <span class="n">Element</span><span class="p">],</span> <span class="nb">float</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Slab</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Repair broken bonds (specified by the bonds parameter) due to</span>
<span class="sd">        slab cleaving, and repair them by moving undercoordinated atoms</span>
<span class="sd">        to the other surface.</span>

<span class="sd">        How it works:</span>
<span class="sd">            For example a P-O4 bond may have P and O(4-x) on one side</span>
<span class="sd">            of the surface, and Ox on the other side, this method would</span>
<span class="sd">            first move P (the reference atom) to the other side,</span>
<span class="sd">            find its missing nearest neighbours (Ox), and move P</span>
<span class="sd">            and Ox back together.</span>

<span class="sd">        Args:</span>
<span class="sd">            slab (Slab): The Slab to repair.</span>
<span class="sd">            bonds (dict): A {(species1, species2): max_bond_dist} dict.</span>
<span class="sd">                For example, PO4 groups may be defined as {(&quot;P&quot;, &quot;O&quot;): 3}.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Slab: The repaired Slab.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">species_pair</span><span class="p">,</span> <span class="n">bond_dist</span> <span class="ow">in</span> <span class="n">bonds</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Determine which element should be the reference (center)</span>
            <span class="c1"># element for determining broken bonds, e.g. P for PO4 bond.</span>
            <span class="n">cn_dict</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">ele</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">species_pair</span><span class="p">):</span>
                <span class="n">cn_list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">oriented_unit_cell</span><span class="p">:</span>
                    <span class="c1"># Find integer coordination numbers for element pairs</span>
                    <span class="n">ref_cn</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="n">site</span><span class="o">.</span><span class="n">species_string</span> <span class="o">==</span> <span class="n">ele</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">oriented_unit_cell</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">site</span><span class="p">,</span> <span class="n">bond_dist</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">nn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">species_string</span> <span class="o">==</span> <span class="n">species_pair</span><span class="p">[</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                                <span class="n">ref_cn</span> <span class="o">+=</span> <span class="mi">1</span>

                    <span class="n">cn_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref_cn</span><span class="p">)</span>
                <span class="n">cn_dict</span><span class="p">[</span><span class="n">ele</span><span class="p">]</span> <span class="o">=</span> <span class="n">cn_list</span>

            <span class="c1"># Make the element with higher coordination the reference</span>
            <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">cn_dict</span><span class="p">[</span><span class="n">species_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">(</span><span class="n">cn_dict</span><span class="p">[</span><span class="n">species_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]]):</span>
                <span class="n">ele_ref</span><span class="p">,</span> <span class="n">ele_other</span> <span class="o">=</span> <span class="n">species_pair</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ele_other</span><span class="p">,</span> <span class="n">ele_ref</span> <span class="o">=</span> <span class="n">species_pair</span>

            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">site</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">slab</span><span class="p">):</span>
                <span class="c1"># Determine the coordination of the reference</span>
                <span class="k">if</span> <span class="n">site</span><span class="o">.</span><span class="n">species_string</span> <span class="o">==</span> <span class="n">ele_ref</span><span class="p">:</span>
                    <span class="n">ref_cn</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
                        <span class="mi">1</span> <span class="k">if</span> <span class="n">neighbor</span><span class="o">.</span><span class="n">species_string</span> <span class="o">==</span> <span class="n">ele_other</span> <span class="k">else</span> <span class="mi">0</span>
                        <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">slab</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">site</span><span class="p">,</span> <span class="n">bond_dist</span><span class="p">)</span>
                    <span class="p">)</span>

                    <span class="c1"># Suppose we find an undercoordinated reference atom</span>
                    <span class="c1"># TODO (@DanielYang59): maybe use the following to</span>
                    <span class="c1"># check if the reference atom is &quot;undercoordinated&quot;</span>
                    <span class="c1"># if ref_cn &lt; min(cn_dict[ele_ref]):</span>
                    <span class="k">if</span> <span class="n">ref_cn</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cn_dict</span><span class="p">[</span><span class="n">ele_ref</span><span class="p">]:</span>
                        <span class="c1"># Move this reference atom to the other side</span>
                        <span class="n">slab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">move_to_other_side</span><span class="p">(</span><span class="n">slab</span><span class="p">,</span> <span class="p">[</span><span class="n">idx</span><span class="p">])</span>

                        <span class="c1"># Find its NNs (with right species) it should bond to</span>
                        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">slab</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">slab</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">r</span><span class="o">=</span><span class="n">bond_dist</span><span class="p">)</span>
                        <span class="n">to_move</span> <span class="o">=</span> <span class="p">[</span><span class="n">nn</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="n">neighbors</span> <span class="k">if</span> <span class="n">nn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">species_string</span> <span class="o">==</span> <span class="n">ele_other</span><span class="p">]</span>
                        <span class="n">to_move</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

                        <span class="c1"># Move those NNs along with the reference</span>
                        <span class="c1"># atom back to the other side of the slab</span>
                        <span class="n">slab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">move_to_other_side</span><span class="p">(</span><span class="n">slab</span><span class="p">,</span> <span class="n">to_move</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">slab</span></div>


<div class="viewcode-block" id="SlabGenerator.move_to_other_side">
<a class="viewcode-back" href="../../../pymatgen.core.html#pymatgen.core.surface.SlabGenerator.move_to_other_side">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">move_to_other_side</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">init_slab</span><span class="p">:</span> <span class="n">Slab</span><span class="p">,</span>
        <span class="n">index_of_sites</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Slab</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Move surface sites to the opposite surface of the Slab.</span>

<span class="sd">        If a selected site resides on the top half of the Slab,</span>
<span class="sd">        it would be moved to the bottom side, and vice versa.</span>
<span class="sd">        The distance moved is equal to the thickness of the Slab.</span>

<span class="sd">        Note:</span>
<span class="sd">            You should only use this method on sites close to the</span>
<span class="sd">            surface, otherwise it would end up deep inside the</span>
<span class="sd">            vacuum layer.</span>

<span class="sd">        Args:</span>
<span class="sd">            init_slab (Slab): The Slab whose sites would be moved.</span>
<span class="sd">            index_of_sites (list[int]): Indices representing</span>
<span class="sd">                the sites to move.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Slab: The Slab with selected sites moved.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate Slab height</span>
        <span class="n">height</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_proj_height</span>
        <span class="c1"># Scale height if using number of hkl planes</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_unit_planes</span><span class="p">:</span>
            <span class="n">height</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">d_hkl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">miller_index</span><span class="p">)</span>

        <span class="c1"># Calculate the moving distance as the fractional height</span>
        <span class="c1"># of the Slab inside the cell</span>
        <span class="c1"># DEBUG(@DanielYang59): use actual sizes for slab/vac</span>
        <span class="c1"># instead of the input arg (min_slab/vac_size)</span>
        <span class="n">n_layers_slab</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_slab_size</span> <span class="o">/</span> <span class="n">height</span><span class="p">)</span>
        <span class="n">n_layers_vac</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_vac_size</span> <span class="o">/</span> <span class="n">height</span><span class="p">)</span>
        <span class="n">n_layers</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">n_layers_slab</span> <span class="o">+</span> <span class="n">n_layers_vac</span>

        <span class="n">frac_dist</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">n_layers_slab</span> <span class="o">/</span> <span class="n">n_layers</span>

        <span class="c1"># Separate selected sites into top and bottom</span>
        <span class="n">top_site_index</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">bottom_site_index</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">index_of_sites</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">init_slab</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">init_slab</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                <span class="n">top_site_index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bottom_site_index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

        <span class="c1"># Move sites to the opposite surface</span>
        <span class="n">slab</span> <span class="o">=</span> <span class="n">init_slab</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">slab</span><span class="o">.</span><span class="n">translate_sites</span><span class="p">(</span><span class="n">top_site_index</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">frac_dist</span><span class="p">],</span> <span class="n">frac_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">slab</span><span class="o">.</span><span class="n">translate_sites</span><span class="p">(</span><span class="n">bottom_site_index</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">frac_dist</span><span class="p">],</span> <span class="n">frac_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Slab</span><span class="p">(</span>
            <span class="n">init_slab</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span>
            <span class="n">slab</span><span class="o">.</span><span class="n">species</span><span class="p">,</span>
            <span class="n">slab</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">,</span>
            <span class="n">init_slab</span><span class="o">.</span><span class="n">miller_index</span><span class="p">,</span>
            <span class="n">init_slab</span><span class="o">.</span><span class="n">oriented_unit_cell</span><span class="p">,</span>
            <span class="n">init_slab</span><span class="o">.</span><span class="n">shift</span><span class="p">,</span>
            <span class="n">init_slab</span><span class="o">.</span><span class="n">scale_factor</span><span class="p">,</span>
            <span class="n">energy</span><span class="o">=</span><span class="n">init_slab</span><span class="o">.</span><span class="n">energy</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="SlabGenerator.nonstoichiometric_symmetrized_slab">
<a class="viewcode-back" href="../../../pymatgen.core.html#pymatgen.core.surface.SlabGenerator.nonstoichiometric_symmetrized_slab">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">nonstoichiometric_symmetrized_slab</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">init_slab</span><span class="p">:</span> <span class="n">Slab</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Slab</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Symmetrize the two surfaces of a Slab, but may break the stoichiometry.</span>

<span class="sd">        How it works:</span>
<span class="sd">            1. Check whether two surfaces of the slab are equivalent.</span>
<span class="sd">            If the point group of the slab has an inversion symmetry (</span>
<span class="sd">            ie. belong to one of the Laue groups), then it&#39;s assumed that the</span>
<span class="sd">            surfaces are equivalent.</span>

<span class="sd">            2.If not symmetrical, sites at the bottom of the slab will be removed</span>
<span class="sd">            until the slab is symmetric, which may break the stoichiometry.</span>

<span class="sd">        Args:</span>
<span class="sd">            init_slab (Slab): The initial Slab.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[Slabs]: The symmetrized Slabs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">init_slab</span><span class="o">.</span><span class="n">is_symmetric</span><span class="p">():</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">init_slab</span><span class="p">]</span>

        <span class="n">non_stoich_slabs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Build a symmetrical surface slab for each of the different surfaces</span>
        <span class="k">for</span> <span class="n">surface</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;top&quot;</span><span class="p">,</span> <span class="s2">&quot;bottom&quot;</span><span class="p">):</span>
            <span class="n">is_sym</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">slab</span> <span class="o">=</span> <span class="n">init_slab</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">slab</span><span class="o">.</span><span class="n">energy</span> <span class="o">=</span> <span class="n">init_slab</span><span class="o">.</span><span class="n">energy</span>

            <span class="k">while</span> <span class="ow">not</span> <span class="n">is_sym</span><span class="p">:</span>
                <span class="c1"># Keep removing sites from the bottom until surfaces are</span>
                <span class="c1"># symmetric or the number of sites removed has</span>
                <span class="c1"># exceeded 10 percent of the original slab</span>
                <span class="c1"># TODO: (@DanielYang59) comment differs from implementation:</span>
                <span class="c1"># no &quot;exceeded 10 percent&quot; check</span>
                <span class="n">z_coords</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">site</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">slab</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">surface</span> <span class="o">==</span> <span class="s2">&quot;top&quot;</span><span class="p">:</span>
                    <span class="n">slab</span><span class="o">.</span><span class="n">remove_sites</span><span class="p">([</span><span class="n">z_coords</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">z_coords</span><span class="p">))])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">slab</span><span class="o">.</span><span class="n">remove_sites</span><span class="p">([</span><span class="n">z_coords</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">z_coords</span><span class="p">))])</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">slab</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">):</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Too many sites removed, please use a larger slab.&quot;</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                    <span class="k">break</span>

                <span class="c1"># Check if the new Slab is symmetric</span>
                <span class="c1"># TODO: (@DanielYang59): should have some feedback (warning)</span>
                <span class="c1"># if cannot symmetrize the Slab</span>
                <span class="k">if</span> <span class="n">slab</span><span class="o">.</span><span class="n">is_symmetric</span><span class="p">():</span>
                    <span class="n">is_sym</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">non_stoich_slabs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slab</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">non_stoich_slabs</span></div>
</div>



<div class="viewcode-block" id="generate_all_slabs">
<a class="viewcode-back" href="../../../pymatgen.core.html#pymatgen.core.surface.generate_all_slabs">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">generate_all_slabs</span><span class="p">(</span>
    <span class="n">structure</span><span class="p">:</span> <span class="n">Structure</span><span class="p">,</span>
    <span class="n">max_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">min_slab_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">min_vacuum_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">bonds</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
    <span class="n">ftol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
    <span class="n">max_broken_bonds</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">lll_reduce</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">center_slab</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">primitive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">max_normal_search</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">symmetrize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">repair</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">include_reconstructions</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">in_unit_planes</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Slab</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find all unique Slabs up to a given Miller index.</span>

<span class="sd">    Slabs oriented along certain Miller indices may be equivalent to</span>
<span class="sd">    other Miller indices under symmetry operations. To avoid</span>
<span class="sd">    duplication, such equivalent slabs would be filtered out.</span>
<span class="sd">    For instance, CsCl has equivalent slabs in the (0,0,1),</span>
<span class="sd">    (0,1,0), and (1,0,0) directions under symmetry operations.</span>

<span class="sd">    Args:</span>
<span class="sd">        structure (Structure): Initial input structure. To</span>
<span class="sd">            ensure that the Miller indices correspond to usual</span>
<span class="sd">            crystallographic definitions, you should supply a</span>
<span class="sd">            conventional unit cell.</span>
<span class="sd">        max_index (int): The maximum Miller index to go up to.</span>
<span class="sd">        min_slab_size (float): The minimum slab size in Angstrom.</span>
<span class="sd">        min_vacuum_size (float): The minimum vacuum layer thickness in Angstrom.</span>
<span class="sd">        bonds (dict): A {(species1, species2): max_bond_dist} dict.</span>
<span class="sd">                For example, PO4 groups may be defined as {(&quot;P&quot;, &quot;O&quot;): 3}.</span>
<span class="sd">        tol (float): Tolerance for getting primitive cells and</span>
<span class="sd">            matching structures.</span>
<span class="sd">        ftol (float): Tolerance in Angstrom for fcluster to check</span>
<span class="sd">            if two atoms are on the same plane. Default to 0.1 Angstrom</span>
<span class="sd">            in the direction of the surface normal.</span>
<span class="sd">        max_broken_bonds (int): Maximum number of allowable broken bonds</span>
<span class="sd">            for the slab. Use this to limit the number of slabs.</span>
<span class="sd">            Defaults to zero, which means no bond can be broken.</span>
<span class="sd">        lll_reduce (bool): Whether to perform an LLL reduction on the</span>
<span class="sd">            final Slab.</span>
<span class="sd">        center_slab (bool): Whether to center the slab in the cell with</span>
<span class="sd">            equal vacuum spacing from the top and bottom.</span>
<span class="sd">        primitive (bool): Whether to reduce generated slabs to</span>
<span class="sd">            primitive cell. Note this does NOT generate a slab</span>
<span class="sd">            from a primitive cell, it means that after slab</span>
<span class="sd">            generation, we attempt to reduce the generated slab to</span>
<span class="sd">            primitive cell.</span>
<span class="sd">        max_normal_search (int): If set to a positive integer, the code</span>
<span class="sd">            will search for a normal lattice vector that is as</span>
<span class="sd">            perpendicular to the surface as possible, by considering</span>
<span class="sd">            multiple linear combinations of lattice vectors up to</span>
<span class="sd">            this value. This has no bearing on surface energies,</span>
<span class="sd">            but may be useful as a preliminary step to generate slabs</span>
<span class="sd">            for absorption or other sizes. It may not be the smallest possible</span>
<span class="sd">            cell for simulation. Normality is not guaranteed, but the oriented</span>
<span class="sd">            cell will have the c vector as normal as possible to the surface.</span>
<span class="sd">            The max absolute Miller index is usually sufficient.</span>
<span class="sd">        symmetrize (bool): Whether to ensure the surfaces of the</span>
<span class="sd">            slabs are equivalent.</span>
<span class="sd">        repair (bool): Whether to repair terminations with broken bonds</span>
<span class="sd">            or just omit them.</span>
<span class="sd">        include_reconstructions (bool): Whether to include reconstructed</span>
<span class="sd">            slabs available in the reconstructions_archive.json file. Defaults to False.</span>
<span class="sd">        in_unit_planes (bool): Whether to set min_slab_size and min_vac_size</span>
<span class="sd">            in number of hkl planes or Angstrom (default).</span>
<span class="sd">            Setting in units of planes is useful to ensure some slabs</span>
<span class="sd">            to have a certain number of layers, e.g. for Cs(100), 10 Ang</span>
<span class="sd">            will result in a slab with only 2 layers, whereas</span>
<span class="sd">            Fe(100) will have more layers. The slab thickness</span>
<span class="sd">            will be in min_slab_size/math.ceil(self._proj_height/dhkl)</span>
<span class="sd">            multiples of oriented unit cells.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">all_slabs</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Slab</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">miller</span> <span class="ow">in</span> <span class="n">get_symmetrically_distinct_miller_indices</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">max_index</span><span class="p">):</span>
        <span class="n">gen</span> <span class="o">=</span> <span class="n">SlabGenerator</span><span class="p">(</span>
            <span class="n">structure</span><span class="p">,</span>
            <span class="n">miller</span><span class="p">,</span>
            <span class="n">min_slab_size</span><span class="p">,</span>
            <span class="n">min_vacuum_size</span><span class="p">,</span>
            <span class="n">lll_reduce</span><span class="o">=</span><span class="n">lll_reduce</span><span class="p">,</span>
            <span class="n">center_slab</span><span class="o">=</span><span class="n">center_slab</span><span class="p">,</span>
            <span class="n">primitive</span><span class="o">=</span><span class="n">primitive</span><span class="p">,</span>
            <span class="n">max_normal_search</span><span class="o">=</span><span class="n">max_normal_search</span><span class="p">,</span>
            <span class="n">in_unit_planes</span><span class="o">=</span><span class="n">in_unit_planes</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">slabs</span> <span class="o">=</span> <span class="n">gen</span><span class="o">.</span><span class="n">get_slabs</span><span class="p">(</span>
            <span class="n">bonds</span><span class="o">=</span><span class="n">bonds</span><span class="p">,</span>
            <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span>
            <span class="n">ftol</span><span class="o">=</span><span class="n">ftol</span><span class="p">,</span>
            <span class="n">symmetrize</span><span class="o">=</span><span class="n">symmetrize</span><span class="p">,</span>
            <span class="n">max_broken_bonds</span><span class="o">=</span><span class="n">max_broken_bonds</span><span class="p">,</span>
            <span class="n">repair</span><span class="o">=</span><span class="n">repair</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">slabs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">miller</span><span class="si">}</span><span class="s2"> has </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">slabs</span><span class="p">)</span><span class="si">}</span><span class="s2"> slabs... &quot;</span><span class="p">)</span>
            <span class="n">all_slabs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">slabs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">include_reconstructions</span><span class="p">:</span>
        <span class="n">symbol</span> <span class="o">=</span> <span class="n">SpacegroupAnalyzer</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span><span class="o">.</span><span class="n">get_space_group_symbol</span><span class="p">()</span>
        <span class="c1"># Enumerate through all reconstructions in the</span>
        <span class="c1"># archive available for this particular spacegroup</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">instructions</span> <span class="ow">in</span> <span class="n">RECONSTRUCTIONS_ARCHIVE</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="s2">&quot;base_reconstruction&quot;</span> <span class="ow">in</span> <span class="n">instructions</span><span class="p">:</span>
                <span class="n">instructions</span> <span class="o">=</span> <span class="n">RECONSTRUCTIONS_ARCHIVE</span><span class="p">[</span><span class="n">instructions</span><span class="p">[</span><span class="s2">&quot;base_reconstruction&quot;</span><span class="p">]]</span>

            <span class="k">if</span> <span class="n">instructions</span><span class="p">[</span><span class="s2">&quot;spacegroup&quot;</span><span class="p">][</span><span class="s2">&quot;symbol&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">symbol</span><span class="p">:</span>
                <span class="c1"># Make sure this reconstruction has a max index</span>
                <span class="c1"># equal or less than the given max index</span>
                <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">instructions</span><span class="p">[</span><span class="s2">&quot;miller_index&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">max_index</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">recon</span> <span class="o">=</span> <span class="n">ReconstructionGenerator</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">min_slab_size</span><span class="p">,</span> <span class="n">min_vacuum_size</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="n">all_slabs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">recon</span><span class="o">.</span><span class="n">build_slabs</span><span class="p">())</span>

    <span class="k">return</span> <span class="n">all_slabs</span></div>



<span class="c1"># Load the reconstructions_archive JSON file</span>
<span class="n">MODULE_DIR</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">))</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">MODULE_DIR</span><span class="si">}</span><span class="s2">/reconstructions_archive.json&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">data_file</span><span class="p">:</span>
    <span class="n">RECONSTRUCTIONS_ARCHIVE</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">data_file</span><span class="p">)</span>


<div class="viewcode-block" id="get_d">
<a class="viewcode-back" href="../../../pymatgen.core.html#pymatgen.core.surface.get_d">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_d</span><span class="p">(</span><span class="n">slab</span><span class="p">:</span> <span class="n">Slab</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Determine the z-spacing between the bottom two layers for a Slab.&quot;&quot;&quot;</span>
    <span class="c1"># Sort all sites by z-coordinates</span>
    <span class="n">sorted_sites</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">slab</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">site</span><span class="p">:</span> <span class="n">site</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

    <span class="n">distance</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">site</span><span class="p">,</span> <span class="n">next_site</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">pairwise</span><span class="p">(</span><span class="n">sorted_sites</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">math</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">next_site</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">abs_tol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">):</span>
            <span class="n">distance</span> <span class="o">=</span> <span class="n">next_site</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">site</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">break</span>

    <span class="k">if</span> <span class="n">distance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot identify any layer.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">slab</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">get_cartesian_coords</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">distance</span><span class="p">])[</span><span class="mi">2</span><span class="p">]</span></div>



<div class="viewcode-block" id="ReconstructionGenerator">
<a class="viewcode-back" href="../../../pymatgen.core.html#pymatgen.core.surface.ReconstructionGenerator">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ReconstructionGenerator</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Build a reconstructed Slab from a given initial Structure.</span>

<span class="sd">    This class needs a pre-defined dictionary specifying the parameters</span>
<span class="sd">    needed such as the SlabGenerator parameters, transformation matrix,</span>
<span class="sd">    sites to remove/add and slab/vacuum sizes.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        slabgen_params (dict): Parameters for the SlabGenerator.</span>
<span class="sd">        trans_matrix (np.ndarray): A 3x3 transformation matrix to generate</span>
<span class="sd">            the reconstructed slab. Only the a and b lattice vectors are</span>
<span class="sd">            actually changed while the c vector remains the same.</span>
<span class="sd">            This matrix is what the Wood&#39;s notation is based on.</span>
<span class="sd">        reconstruction_json (dict): The full JSON or dictionary containing</span>
<span class="sd">            the instructions for building the slab.</span>

<span class="sd">    Todo:</span>
<span class="sd">        - Right now there is no way to specify what atom is being added.</span>
<span class="sd">            Use basis sets in the future?</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">initial_structure</span><span class="p">:</span> <span class="n">Structure</span><span class="p">,</span>
        <span class="n">min_slab_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">min_vacuum_size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">reconstruction_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate reconstructed slabs from a set of instructions.</span>

<span class="sd">        Args:</span>
<span class="sd">            initial_structure (Structure): Initial input structure. Note</span>
<span class="sd">                that to ensure that the Miller indices correspond to usual</span>
<span class="sd">                crystallographic definitions, you should supply a conventional</span>
<span class="sd">                unit cell structure.</span>
<span class="sd">            min_slab_size (float): Minimum Slab size in Angstrom.</span>
<span class="sd">            min_vacuum_size (float): Minimum vacuum layer size in Angstrom.</span>
<span class="sd">            reconstruction_name (str): Name of the dict containing the build</span>
<span class="sd">                instructions. The dictionary can contain any item, however</span>
<span class="sd">                any instructions archived in pymatgen for public use need</span>
<span class="sd">                to contain the following keys and items to ensure</span>
<span class="sd">                compatibility with the ReconstructionGenerator:</span>

<span class="sd">                    &quot;name&quot; (str): A descriptive name for the reconstruction,</span>
<span class="sd">                        typically including the type of structure,</span>
<span class="sd">                        the Miller index, the Wood&#39;s notation and additional</span>
<span class="sd">                        descriptors for the reconstruction.</span>
<span class="sd">                        Example: &quot;fcc_110_missing_row_1x2&quot;</span>
<span class="sd">                    &quot;description&quot; (str): A detailed description of the</span>
<span class="sd">                        reconstruction, intended to assist future contributors</span>
<span class="sd">                        in avoiding duplicate entries. Please read the description</span>
<span class="sd">                        carefully before adding to prevent duplications.</span>
<span class="sd">                    &quot;reference&quot; (str): Optional reference to the source of</span>
<span class="sd">                        the reconstruction.</span>
<span class="sd">                    &quot;spacegroup&quot; (dict): A dictionary indicating the space group</span>
<span class="sd">                        of the reconstruction. e.g. {&quot;symbol&quot;: &quot;Fm-3m&quot;, &quot;number&quot;: 225}.</span>
<span class="sd">                    &quot;miller_index&quot; ([h, k, l]): Miller index of the reconstruction</span>
<span class="sd">                    &quot;Woods_notation&quot; (str): For a reconstruction, the a and b</span>
<span class="sd">                        lattice may change to accommodate the symmetry.</span>
<span class="sd">                        This notation indicates the change in</span>
<span class="sd">                        the vectors relative to the primitive (p) or</span>
<span class="sd">                        conventional (c) slab cell. E.g. p(2x1).</span>

<span class="sd">                        Reference: Wood, E. A. (1964). Vocabulary of surface</span>
<span class="sd">                        crystallography. Journal of Applied Physics, 35(4),</span>
<span class="sd">                        1306-1312.</span>
<span class="sd">                    &quot;transformation_matrix&quot; (numpy array): A 3x3 matrix to</span>
<span class="sd">                        transform the slab. Only the a and b lattice vectors</span>
<span class="sd">                        should change while the c vector remains the same.</span>
<span class="sd">                    &quot;SlabGenerator_parameters&quot; (dict): A dictionary containing</span>
<span class="sd">                        the parameters for the SlabGenerator, excluding the</span>
<span class="sd">                        miller_index, min_slab_size and min_vac_size. As the</span>
<span class="sd">                        Miller index is already specified and the min_slab_size</span>
<span class="sd">                        and min_vac_size can be changed regardless of the</span>
<span class="sd">                        reconstruction type. Having a consistent set of</span>
<span class="sd">                        SlabGenerator parameters allows for the instructions to</span>
<span class="sd">                        be reused.</span>
<span class="sd">                    &quot;points_to_remove&quot; (list[site]): A list of sites to</span>
<span class="sd">                        remove where the first two indices are fractional (in a</span>
<span class="sd">                        and b) and the third index is in units of 1/d (in c),</span>
<span class="sd">                        see the below &quot;Notes&quot; for details.</span>
<span class="sd">                    &quot;points_to_add&quot; (list[site]): A list of sites to add</span>
<span class="sd">                        where the first two indices are fractional (in a an b) and</span>
<span class="sd">                        the third index is in units of 1/d (in c), see the below</span>
<span class="sd">                        &quot;Notes&quot; for details.</span>
<span class="sd">                    &quot;base_reconstruction&quot; (dict, Optional): A dictionary specifying</span>
<span class="sd">                        an existing reconstruction model upon which the current</span>
<span class="sd">                        reconstruction is built to avoid repetition. E.g. the</span>
<span class="sd">                        alpha reconstruction of halites is based on the octopolar</span>
<span class="sd">                        reconstruction but with the topmost atom removed. The dictionary</span>
<span class="sd">                        for the alpha reconstruction would therefore contain the item</span>
<span class="sd">                        &quot;reconstruction_base&quot;: &quot;halite_111_octopolar_2x2&quot;, and</span>
<span class="sd">                        additional sites can be added by &quot;points_to_add&quot;.</span>

<span class="sd">        Notes:</span>
<span class="sd">            1. For &quot;points_to_remove&quot; and &quot;points_to_add&quot;, the third index</span>
<span class="sd">                for the c vector is specified in units of 1/d, where d represents</span>
<span class="sd">                the spacing between atoms along the hkl (the c vector), relative</span>
<span class="sd">                to the topmost site in the unreconstructed slab. For instance,</span>
<span class="sd">                a point of [0.5, 0.25, 1] corresponds to the 0.5 fractional</span>
<span class="sd">                coordinate of a, 0.25 fractional coordinate of b, and a</span>
<span class="sd">                distance of 1 atomic layer above the topmost site. Similarly,</span>
<span class="sd">                [0.5, 0.25, -0.5] corresponds to a point half an atomic layer</span>
<span class="sd">                below the topmost site, and [0.5, 0.25, 0] corresponds to a</span>
<span class="sd">                point at the same position along c as the topmost site.</span>
<span class="sd">                This approach is employed because while the primitive units</span>
<span class="sd">                of a and b remain constant, the user can vary the length</span>
<span class="sd">                of the c direction by adjusting the slab layer or the vacuum layer.</span>

<span class="sd">            2. The dictionary should only provide &quot;points_to_remove&quot; and</span>
<span class="sd">                &quot;points_to_add&quot; for the top surface. The ReconstructionGenerator</span>
<span class="sd">                will modify the bottom surface accordingly to return a symmetric Slab.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">build_recon_json</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Build reconstruction instructions, optionally upon a base instruction set.&quot;&quot;&quot;</span>
            <span class="c1"># Check if reconstruction instruction exists</span>
            <span class="c1"># TODO (@DanielYang59): can we avoid asking user to modify the source file?</span>
            <span class="k">if</span> <span class="n">reconstruction_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">RECONSTRUCTIONS_ARCHIVE</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">reconstruction_name</span><span class="si">=}</span><span class="s2"> does not exist in the archive. &quot;</span>
                    <span class="s2">&quot;Please select from one of the following: &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">RECONSTRUCTIONS_ARCHIVE</span><span class="p">)</span><span class="si">}</span><span class="s2"> or add it to the &quot;</span>
                    <span class="s2">&quot;archive file &#39;reconstructions_archive.json&#39;.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># Get the reconstruction instructions from the archive file</span>
            <span class="n">recon_json</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">RECONSTRUCTIONS_ARCHIVE</span><span class="p">[</span><span class="n">reconstruction_name</span><span class="p">])</span>

            <span class="c1"># Build new instructions from a base reconstruction</span>
            <span class="k">if</span> <span class="s2">&quot;base_reconstruction&quot;</span> <span class="ow">in</span> <span class="n">recon_json</span><span class="p">:</span>
                <span class="n">new_points_to_add</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">new_points_to_remove</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">if</span> <span class="s2">&quot;points_to_add&quot;</span> <span class="ow">in</span> <span class="n">recon_json</span><span class="p">:</span>
                    <span class="n">new_points_to_add</span> <span class="o">=</span> <span class="n">recon_json</span><span class="p">[</span><span class="s2">&quot;points_to_add&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="s2">&quot;points_to_remove&quot;</span> <span class="ow">in</span> <span class="n">recon_json</span><span class="p">:</span>
                    <span class="n">new_points_to_remove</span> <span class="o">=</span> <span class="n">recon_json</span><span class="p">[</span><span class="s2">&quot;points_to_remove&quot;</span><span class="p">]</span>

                <span class="c1"># DEBUG (@DanielYang59): the following overwrites previously</span>
                <span class="c1"># loaded &quot;recon_json&quot;, use condition to avoid this</span>
                <span class="n">recon_json</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">RECONSTRUCTIONS_ARCHIVE</span><span class="p">[</span><span class="n">recon_json</span><span class="p">[</span><span class="s2">&quot;base_reconstruction&quot;</span><span class="p">]])</span>

                <span class="c1"># TODO (@DanielYang59): use &quot;site&quot; over &quot;point&quot; for consistency?</span>
                <span class="k">if</span> <span class="s2">&quot;points_to_add&quot;</span> <span class="ow">in</span> <span class="n">recon_json</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">recon_json</span><span class="p">[</span><span class="s2">&quot;points_to_add&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">new_points_to_add</span><span class="p">:</span>
                    <span class="n">recon_json</span><span class="p">[</span><span class="s2">&quot;points_to_add&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_points_to_add</span>

                <span class="k">if</span> <span class="s2">&quot;points_to_remove&quot;</span> <span class="ow">in</span> <span class="n">recon_json</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">recon_json</span><span class="p">[</span><span class="s2">&quot;points_to_remove&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">new_points_to_remove</span><span class="p">:</span>
                    <span class="n">recon_json</span><span class="p">[</span><span class="s2">&quot;points_to_remove&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_points_to_remove</span>

            <span class="k">return</span> <span class="n">recon_json</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">build_slabgen_params</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Build SlabGenerator parameters.&quot;&quot;&quot;</span>
            <span class="n">slabgen_params</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">recon_json</span><span class="p">[</span><span class="s2">&quot;SlabGenerator_parameters&quot;</span><span class="p">])</span>
            <span class="n">slabgen_params</span><span class="p">[</span><span class="s2">&quot;initial_structure&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">initial_structure</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">slabgen_params</span><span class="p">[</span><span class="s2">&quot;miller_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">recon_json</span><span class="p">[</span><span class="s2">&quot;miller_index&quot;</span><span class="p">]</span>
            <span class="n">slabgen_params</span><span class="p">[</span><span class="s2">&quot;min_slab_size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_slab_size</span>
            <span class="n">slabgen_params</span><span class="p">[</span><span class="s2">&quot;min_vacuum_size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_vacuum_size</span>

            <span class="k">return</span> <span class="n">slabgen_params</span>

        <span class="c1"># Build reconstruction instructions</span>
        <span class="n">recon_json</span> <span class="o">=</span> <span class="n">build_recon_json</span><span class="p">()</span>

        <span class="c1"># Build SlabGenerator parameters</span>
        <span class="n">slabgen_params</span> <span class="o">=</span> <span class="n">build_slabgen_params</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">reconstruction_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slabgen_params</span> <span class="o">=</span> <span class="n">slabgen_params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reconstruction_json</span> <span class="o">=</span> <span class="n">recon_json</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trans_matrix</span> <span class="o">=</span> <span class="n">recon_json</span><span class="p">[</span><span class="s2">&quot;transformation_matrix&quot;</span><span class="p">]</span>

<div class="viewcode-block" id="ReconstructionGenerator.build_slabs">
<a class="viewcode-back" href="../../../pymatgen.core.html#pymatgen.core.surface.ReconstructionGenerator.build_slabs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">build_slabs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Slab</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build reconstructed Slabs by:</span>
<span class="sd">            (1) Obtaining the unreconstructed Slab using the specified</span>
<span class="sd">                parameters for the SlabGenerator.</span>
<span class="sd">            (2) Applying the appropriate lattice transformation to the</span>
<span class="sd">                a and b lattice vectors.</span>
<span class="sd">            (3) Remove and then add specified sites from both surfaces.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[Slab]: The reconstructed slabs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">slabs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_unreconstructed_slabs</span><span class="p">()</span>

        <span class="n">recon_slabs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">slab</span> <span class="ow">in</span> <span class="n">slabs</span><span class="p">:</span>
            <span class="n">z_spacing</span> <span class="o">=</span> <span class="n">get_d</span><span class="p">(</span><span class="n">slab</span><span class="p">)</span>
            <span class="n">top_site</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">slab</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">site</span><span class="p">:</span> <span class="n">site</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">coords</span>

            <span class="c1"># Remove specified sites</span>
            <span class="k">if</span> <span class="s2">&quot;points_to_remove&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">reconstruction_json</span><span class="p">:</span>
                <span class="n">sites_to_rm</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reconstruction_json</span><span class="p">[</span><span class="s2">&quot;points_to_remove&quot;</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">sites_to_rm</span><span class="p">:</span>
                    <span class="n">site</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">slab</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">get_fractional_coords</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">top_site</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">top_site</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">top_site</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">site</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">z_spacing</span><span class="p">]</span>
                    <span class="p">)[</span><span class="mi">2</span><span class="p">]</span>

                    <span class="c1"># Find and remove nearest site</span>
                    <span class="n">cart_point</span> <span class="o">=</span> <span class="n">slab</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">get_cartesian_coords</span><span class="p">(</span><span class="n">site</span><span class="p">)</span>
                    <span class="n">distances</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">site</span><span class="o">.</span><span class="n">distance_from_point</span><span class="p">(</span><span class="n">cart_point</span><span class="p">)</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">slab</span><span class="p">]</span>
                    <span class="n">nearest_site</span> <span class="o">=</span> <span class="n">distances</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">distances</span><span class="p">))</span>
                    <span class="n">slab</span><span class="o">.</span><span class="n">symmetrically_remove_atoms</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="p">[</span><span class="n">nearest_site</span><span class="p">])</span>

            <span class="c1"># Add specified sites</span>
            <span class="k">if</span> <span class="s2">&quot;points_to_add&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">reconstruction_json</span><span class="p">:</span>
                <span class="n">sites_to_add</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reconstruction_json</span><span class="p">[</span><span class="s2">&quot;points_to_add&quot;</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">sites_to_add</span><span class="p">:</span>
                    <span class="n">site</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">slab</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">get_fractional_coords</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">top_site</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">top_site</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">top_site</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">site</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">z_spacing</span><span class="p">]</span>
                    <span class="p">)[</span><span class="mi">2</span><span class="p">]</span>
                    <span class="c1"># TODO: see ReconstructionGenerator docstring:</span>
                    <span class="c1"># cannot specify species to add</span>
                    <span class="n">slab</span><span class="o">.</span><span class="n">symmetrically_add_atom</span><span class="p">(</span><span class="n">species</span><span class="o">=</span><span class="n">slab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">specie</span><span class="p">,</span> <span class="n">point</span><span class="o">=</span><span class="n">site</span><span class="p">)</span>

            <span class="n">slab</span><span class="o">.</span><span class="n">reconstruction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
            <span class="n">slab</span><span class="o">.</span><span class="n">recon_trans_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trans_matrix</span>

            <span class="c1"># Get the oriented unit cell with the same a*b area</span>
            <span class="n">ouc</span> <span class="o">=</span> <span class="n">slab</span><span class="o">.</span><span class="n">oriented_unit_cell</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">ouc</span><span class="o">.</span><span class="n">make_supercell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trans_matrix</span><span class="p">)</span>
            <span class="n">slab</span><span class="o">.</span><span class="n">oriented_unit_cell</span> <span class="o">=</span> <span class="n">ouc</span>
            <span class="n">recon_slabs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slab</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">recon_slabs</span></div>


<div class="viewcode-block" id="ReconstructionGenerator.get_unreconstructed_slabs">
<a class="viewcode-back" href="../../../pymatgen.core.html#pymatgen.core.surface.ReconstructionGenerator.get_unreconstructed_slabs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_unreconstructed_slabs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Slab</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate the unreconstructed (super) Slabs.</span>

<span class="sd">        TODO (@DanielYang59): this should be a private method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">slab</span><span class="o">.</span><span class="n">make_supercell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trans_matrix</span><span class="p">)</span> <span class="k">for</span> <span class="n">slab</span> <span class="ow">in</span> <span class="n">SlabGenerator</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">slabgen_params</span><span class="p">)</span><span class="o">.</span><span class="n">get_slabs</span><span class="p">()]</span></div>
</div>



<div class="viewcode-block" id="get_symmetrically_equivalent_miller_indices">
<a class="viewcode-back" href="../../../pymatgen.core.html#pymatgen.core.surface.get_symmetrically_equivalent_miller_indices">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_symmetrically_equivalent_miller_indices</span><span class="p">(</span>
    <span class="n">structure</span><span class="p">:</span> <span class="n">Structure</span><span class="p">,</span>
    <span class="n">miller_index</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
    <span class="n">return_hkil</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">system</span><span class="p">:</span> <span class="n">CrystalSystem</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get indices for all equivalent sites within a given structure.</span>
<span class="sd">    Analysis is based on the symmetry of its reciprocal lattice.</span>

<span class="sd">    Args:</span>
<span class="sd">        structure (Structure): Structure to analyze.</span>
<span class="sd">        miller_index (tuple): Designates the family of Miller indices</span>
<span class="sd">            to find. Can be hkl or hkil for hexagonal systems.</span>
<span class="sd">        return_hkil (bool): Whether to return hkil (True) form of Miller</span>
<span class="sd">            index for hexagonal systems, or hkl (False).</span>
<span class="sd">        system: The crystal system of the structure.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Convert to hkl if hkil, because in_coord_list only handles tuples of 3</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">miller_index</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">_miller_index</span><span class="p">:</span> <span class="n">MillerIndex</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">miller_index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">miller_index</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">miller_index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_miller_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">miller_index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">miller_index</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">miller_index</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

    <span class="n">max_idx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">miller_index</span><span class="p">))</span>
    <span class="n">idx_range</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">max_idx</span><span class="p">,</span> <span class="n">max_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">idx_range</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

    <span class="c1"># Skip crystal system analysis if already given</span>
    <span class="k">if</span> <span class="n">system</span><span class="p">:</span>
        <span class="n">spg_analyzer</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">spg_analyzer</span> <span class="o">=</span> <span class="n">SpacegroupAnalyzer</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span>
        <span class="n">system</span> <span class="o">=</span> <span class="n">spg_analyzer</span><span class="o">.</span><span class="n">get_crystal_system</span><span class="p">()</span>

    <span class="c1"># Get distinct hkl planes from the rhombohedral setting if trigonal</span>
    <span class="k">if</span> <span class="n">system</span> <span class="o">==</span> <span class="s2">&quot;trigonal&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">spg_analyzer</span><span class="p">:</span>
            <span class="n">spg_analyzer</span> <span class="o">=</span> <span class="n">SpacegroupAnalyzer</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span>
        <span class="n">prim_structure</span> <span class="o">=</span> <span class="n">spg_analyzer</span><span class="o">.</span><span class="n">get_primitive_standard_structure</span><span class="p">()</span>
        <span class="n">symm_ops</span> <span class="o">=</span> <span class="n">prim_structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">get_recp_symmetry_operation</span><span class="p">()</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">symm_ops</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">get_recp_symmetry_operation</span><span class="p">()</span>

    <span class="n">equivalent_millers</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Tuple3Ints</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">_miller_index</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">miller</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">idx_range</span><span class="p">,</span> <span class="n">idx_range</span><span class="p">,</span> <span class="n">idx_range</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">miller</span> <span class="o">==</span> <span class="n">_miller_index</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">idx</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">miller</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">_is_in_miller_family</span><span class="p">(</span><span class="n">miller</span><span class="p">,</span> <span class="n">equivalent_millers</span><span class="p">,</span> <span class="n">symm_ops</span><span class="p">):</span>
                <span class="n">equivalent_millers</span> <span class="o">+=</span> <span class="p">[</span><span class="n">miller</span><span class="p">]</span>

            <span class="c1"># Include larger Miller indices in the family of planes</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">all</span><span class="p">(</span><span class="n">max_idx</span> <span class="o">&gt;</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">miller</span><span class="p">))</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">in_coord_list</span><span class="p">(</span><span class="n">equivalent_millers</span><span class="p">,</span> <span class="n">miller</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">_is_in_miller_family</span><span class="p">(</span><span class="n">max_idx</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">miller</span><span class="p">),</span> <span class="n">equivalent_millers</span><span class="p">,</span> <span class="n">symm_ops</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">equivalent_millers</span> <span class="o">+=</span> <span class="p">[</span><span class="n">miller</span><span class="p">]</span>

    <span class="c1"># Convert hkl to hkil if necessary</span>
    <span class="k">if</span> <span class="n">return_hkil</span> <span class="ow">and</span> <span class="n">system</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;trigonal&quot;</span><span class="p">,</span> <span class="s2">&quot;hexagonal&quot;</span><span class="p">}:</span>
        <span class="k">return</span> <span class="p">[(</span><span class="n">hkl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">hkl</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">hkl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">hkl</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">hkl</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="k">for</span> <span class="n">hkl</span> <span class="ow">in</span> <span class="n">equivalent_millers</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">equivalent_millers</span></div>



<div class="viewcode-block" id="get_symmetrically_distinct_miller_indices">
<a class="viewcode-back" href="../../../pymatgen.core.html#pymatgen.core.surface.get_symmetrically_distinct_miller_indices">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_symmetrically_distinct_miller_indices</span><span class="p">(</span>
    <span class="n">structure</span><span class="p">:</span> <span class="n">Structure</span><span class="p">,</span>
    <span class="n">max_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">return_hkil</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find all symmetrically distinct indices below a certain max-index</span>
<span class="sd">    for a given structure. Analysis is based on the symmetry of the</span>
<span class="sd">    reciprocal lattice of the structure.</span>

<span class="sd">    Args:</span>
<span class="sd">        structure (Structure): The input structure.</span>
<span class="sd">        max_index (int): The maximum index. For example, 1 means that</span>
<span class="sd">            (100), (110), and (111) are returned for the cubic structure.</span>
<span class="sd">            All other indices are equivalent to one of these.</span>
<span class="sd">        return_hkil (bool): Whether to return hkil (True) form of Miller</span>
<span class="sd">            index for hexagonal systems, or hkl (False).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get a list of all hkls for conventional (including equivalent)</span>
    <span class="n">rng</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">max_index</span><span class="p">,</span> <span class="n">max_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">conv_hkl_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">miller</span> <span class="k">for</span> <span class="n">miller</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span> <span class="n">rng</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span> <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">miller</span><span class="p">)]</span>

    <span class="c1"># Sort by the maximum absolute values of Miller indices so that</span>
    <span class="c1"># low-index planes come first. This is important for trigonal systems.</span>
    <span class="n">conv_hkl_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">conv_hkl_list</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>

    <span class="c1"># Get distinct hkl planes from the rhombohedral setting if trigonal</span>
    <span class="n">spg_analyzer</span> <span class="o">=</span> <span class="n">SpacegroupAnalyzer</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">spg_analyzer</span><span class="o">.</span><span class="n">get_crystal_system</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;trigonal&quot;</span><span class="p">:</span>
        <span class="n">transf</span> <span class="o">=</span> <span class="n">spg_analyzer</span><span class="o">.</span><span class="n">get_conventional_to_primitive_transformation_matrix</span><span class="p">()</span>
        <span class="n">miller_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Tuple3Ints</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">hkl_transformation</span><span class="p">(</span><span class="n">transf</span><span class="p">,</span> <span class="n">hkl</span><span class="p">)</span> <span class="k">for</span> <span class="n">hkl</span> <span class="ow">in</span> <span class="n">conv_hkl_list</span><span class="p">]</span>
        <span class="n">prim_structure</span> <span class="o">=</span> <span class="n">SpacegroupAnalyzer</span><span class="p">(</span><span class="n">structure</span><span class="p">)</span><span class="o">.</span><span class="n">get_primitive_standard_structure</span><span class="p">()</span>
        <span class="n">symm_ops</span> <span class="o">=</span> <span class="n">prim_structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">get_recp_symmetry_operation</span><span class="p">()</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">miller_list</span> <span class="o">=</span> <span class="n">conv_hkl_list</span>
        <span class="n">symm_ops</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">get_recp_symmetry_operation</span><span class="p">()</span>

    <span class="n">unique_millers</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">unique_millers_conv</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">miller</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">miller_list</span><span class="p">):</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">reduce</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">gcd</span><span class="p">,</span> <span class="n">miller</span><span class="p">))</span>  <span class="c1"># type: ignore[arg-type]</span>
        <span class="n">miller</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Tuple3Ints</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">idx</span> <span class="o">/</span> <span class="n">denom</span><span class="p">)</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">miller</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_in_miller_family</span><span class="p">(</span><span class="n">miller</span><span class="p">,</span> <span class="n">unique_millers</span><span class="p">,</span> <span class="n">symm_ops</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">spg_analyzer</span><span class="o">.</span><span class="n">get_crystal_system</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;trigonal&quot;</span><span class="p">:</span>
                <span class="c1"># Now we find the distinct primitive hkls using</span>
                <span class="c1"># the primitive symmetry operations and their</span>
                <span class="c1"># corresponding hkls in the conventional setting</span>
                <span class="n">unique_millers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">miller</span><span class="p">)</span>
                <span class="n">denom</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">reduce</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">gcd</span><span class="p">,</span> <span class="n">conv_hkl_list</span><span class="p">[</span><span class="n">idx</span><span class="p">]))</span>  <span class="c1"># type: ignore[arg-type]</span>
                <span class="n">cmiller</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">idx</span> <span class="o">/</span> <span class="n">denom</span><span class="p">)</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">conv_hkl_list</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
                <span class="n">unique_millers_conv</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cmiller</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unique_millers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">miller</span><span class="p">)</span>
                <span class="n">unique_millers_conv</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">miller</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_hkil</span> <span class="ow">and</span> <span class="n">spg_analyzer</span><span class="o">.</span><span class="n">get_crystal_system</span><span class="p">()</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;trigonal&quot;</span><span class="p">,</span> <span class="s2">&quot;hexagonal&quot;</span><span class="p">}:</span>
        <span class="k">return</span> <span class="p">[(</span><span class="n">hkl</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">hkl</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">hkl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">hkl</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">hkl</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="k">for</span> <span class="n">hkl</span> <span class="ow">in</span> <span class="n">unique_millers_conv</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">unique_millers_conv</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_is_in_miller_family</span><span class="p">(</span>
    <span class="n">miller_index</span><span class="p">:</span> <span class="n">MillerIndex</span><span class="p">,</span>
    <span class="n">miller_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">MillerIndex</span><span class="p">],</span>
    <span class="n">symm_ops</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper function to check if the given Miller index belongs</span>
<span class="sd">    to the same family of any index in the provided list.</span>

<span class="sd">    Args:</span>
<span class="sd">        miller_index (MillerIndex): The Miller index to analyze.</span>
<span class="sd">        miller_list (list): List of Miller indices.</span>
<span class="sd">        symm_ops (list): Symmetry operations for a lattice,</span>
<span class="sd">            used to define the indices family.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">in_coord_list</span><span class="p">(</span><span class="n">miller_list</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">operate</span><span class="p">(</span><span class="n">miller_index</span><span class="p">))</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">symm_ops</span><span class="p">)</span>


<div class="viewcode-block" id="hkl_transformation">
<a class="viewcode-back" href="../../../pymatgen.core.html#pymatgen.core.surface.hkl_transformation">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">hkl_transformation</span><span class="p">(</span>
    <span class="n">transf</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">miller_index</span><span class="p">:</span> <span class="n">MillerIndex</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple3Ints</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Transform the Miller index from setting A to B with a transformation matrix.</span>

<span class="sd">    Args:</span>
<span class="sd">        transf (3x3 array): The matrix that transforms a lattice from A to B.</span>
<span class="sd">        miller_index (MillerIndex): The Miller index [h, k, l] to transform.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">math_lcm</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the least common multiple.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span> <span class="o">//</span> <span class="n">math</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="c1"># Convert the elements of the transformation matrix to integers</span>
    <span class="n">reduced_transf</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">math_lcm</span><span class="p">,</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">transf</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">transf</span>
    <span class="n">reduced_transf</span> <span class="o">=</span> <span class="n">reduced_transf</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># Perform the transformation</span>
    <span class="n">transf_hkl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">reduced_transf</span><span class="p">,</span> <span class="n">miller_index</span><span class="p">)</span>
    <span class="n">divisor</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">reduce</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">gcd</span><span class="p">,</span> <span class="n">transf_hkl</span><span class="p">))</span>  <span class="c1"># type: ignore[arg-type]</span>
    <span class="n">transf_hkl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">idx</span> <span class="o">//</span> <span class="n">divisor</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">transf_hkl</span><span class="p">])</span>

    <span class="c1"># Get positive Miller index</span>
    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">transf_hkl</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">transf_hkl</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">transf_hkl</span><span class="p">)</span></div>



<div class="viewcode-block" id="miller_index_from_sites">
<a class="viewcode-back" href="../../../pymatgen.core.html#pymatgen.core.surface.miller_index_from_sites">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">miller_index_from_sites</span><span class="p">(</span>
    <span class="n">lattice</span><span class="p">:</span> <span class="n">Lattice</span> <span class="o">|</span> <span class="n">ArrayLike</span><span class="p">,</span>
    <span class="n">coords</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
    <span class="n">coords_are_cartesian</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">round_dp</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple3Ints</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the Miller index of a plane, determined by a given set of coordinates.</span>

<span class="sd">    A minimum of 3 sets of coordinates are required. If more than 3</span>
<span class="sd">    coordinates are given, the plane that minimises the distance to all</span>
<span class="sd">    sites will be calculated.</span>

<span class="sd">    Args:</span>
<span class="sd">        lattice (matrix or Lattice): A 3x3 lattice matrix or `Lattice` object.</span>
<span class="sd">        coords (ArrayLike): A list or numpy array of coordinates. Can be</span>
<span class="sd">            Cartesian or fractional coordinates.</span>
<span class="sd">        coords_are_cartesian (bool, optional): Whether the coordinates are</span>
<span class="sd">            in Cartesian coordinates, or fractional (False).</span>
<span class="sd">        round_dp (int, optional): The number of decimal places to round the</span>
<span class="sd">            Miller index to.</span>
<span class="sd">        verbose (bool, optional): Whether to print warnings.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple[int]: The Miller index.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lattice</span><span class="p">,</span> <span class="n">Lattice</span><span class="p">):</span>
        <span class="n">lattice</span> <span class="o">=</span> <span class="n">Lattice</span><span class="p">(</span><span class="n">lattice</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">lattice</span><span class="o">.</span><span class="n">get_miller_index_from_coords</span><span class="p">(</span>
        <span class="n">coords</span><span class="p">,</span>
        <span class="n">coords_are_cartesian</span><span class="o">=</span><span class="n">coords_are_cartesian</span><span class="p">,</span>
        <span class="n">round_dp</span><span class="o">=</span><span class="n">round_dp</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
    <span class="p">)</span></div>

</pre></div>

            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">pymatgen 2025.1.24 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">pymatgen.core.surface</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2011, Pymatgen Development Team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    </div>
  </body>
</html>