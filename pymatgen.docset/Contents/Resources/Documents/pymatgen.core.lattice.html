
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta charset="utf-8"/>
<title>pymatgen.core.lattice module — pymatgen 2021.2.8.1 documentation</title>
<link href="_static/basic.css" rel="stylesheet" type="text/css"/>
<link href="_static/pygments.css" rel="stylesheet" type="text/css"/>
<script data-url_root="./" id="documentation_options" src="_static/documentation_options.js" type="text/javascript"></script>
<script src="_static/jquery.js" type="text/javascript"></script>
<script src="_static/underscore.js" type="text/javascript"></script>
<script src="_static/doctools.js" type="text/javascript"></script>
<script src="_static/language_data.js" type="text/javascript"></script>
<script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
<link href="genindex.html" rel="index" title="Index"/>
<link href="search.html" rel="search" title="Search"/>
<link href="pymatgen.core.libxcfunc.html" rel="next" title="pymatgen.core.libxcfunc module"/>
<link href="pymatgen.core.ion.html" rel="prev" title="pymatgen.core.ion module"/>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33990148-1']);
  _gaq.push(['_trackPageview']);
</script>
</head><body>
<div aria-label="related navigation" class="related" role="navigation">
<h3>Navigation</h3>
<ul>
<li class="right" style="margin-right: 10px">
<a accesskey="I" href="genindex.html" title="General Index">index</a></li>
<li class="right">
<a href="py-modindex.html" title="Python Module Index">modules</a> |</li>
<li class="right">
<a accesskey="N" href="pymatgen.core.libxcfunc.html" title="pymatgen.core.libxcfunc module">next</a> |</li>
<li class="right">
<a accesskey="P" href="pymatgen.core.ion.html" title="pymatgen.core.ion module">previous</a> |</li>
<li class="nav-item nav-item-0"><a href="index.html">pymatgen 2021.2.8.1 documentation</a> »</li>
<li class="nav-item nav-item-1"><a href="modules.html">pymatgen</a> »</li>
<li class="nav-item nav-item-2"><a href="pymatgen.html">pymatgen namespace</a> »</li>
<li class="nav-item nav-item-3"><a accesskey="U" href="pymatgen.core.html">pymatgen.core package</a> »</li>
</ul>
</div>
<div class="document">
<div class="documentwrapper">
<div class="body" role="main">
<div class="section" id="module-pymatgen.core.lattice">
<span id="pymatgen-core-lattice-module"></span><h1><a name="//apple_ref/cpp/Module/pymatgen.core.lattice"></a>pymatgen.core.lattice module<a class="headerlink" href="#module-pymatgen.core.lattice" title="Permalink to this headline">¶</a></h1>
<p>Defines the classes relating to 3D lattices.</p>
<dl class="class">
<dt id="pymatgen.core.lattice.Lattice"><a name="//apple_ref/cpp/Class/pymatgen.core.lattice.Lattice"></a>
<em class="property">class </em><code class="sig-name descname">Lattice</code><span class="sig-paren">(</span><em class="sig-param">matrix: Union[Sequence[float], Sequence[Sequence[float]], Sequence[numpy.ndarray], numpy.ndarray]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/core/lattice.html#Lattice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.core.lattice.Lattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">monty.json.MSONable</span></code></p>
<p>A lattice object.  Essentially a matrix with conversion matrices. In
general, it is assumed that length units are in Angstroms and angles are in
degrees unless otherwise stated.</p>
<p>Create a lattice from any sequence of 9 numbers. Note that the sequence
is assumed to be read one row at a time. Each row represents one
lattice vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>matrix</strong> – Sequence of numbers in any form. Examples of acceptable
input.
i) An actual numpy array.
ii) [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
iii) [1, 0, 0 , 0, 1, 0, 0, 0, 1]
iv) (1, 0, 0, 0, 1, 0, 0, 0, 1)
Each row should correspond to a lattice vector.
E.g., [[10, 0, 0], [20, 10, 0], [0, 0, 30]] specifies a lattice
with lattice vectors [10, 0, 0], [20, 10, 0] and [0, 0, 30].</p>
</dd>
</dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.a"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.a"></a>
<em class="property">property </em><code class="sig-name descname">a</code><a class="headerlink" href="#pymatgen.core.lattice.Lattice.a" title="Permalink to this definition">¶</a></dt>
<dd><p><em>a</em> lattice parameter.</p>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.abc"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.abc"></a>
<em class="property">property </em><code class="sig-name descname">abc</code><a class="headerlink" href="#pymatgen.core.lattice.Lattice.abc" title="Permalink to this definition">¶</a></dt>
<dd><p>Lengths of the lattice vectors, i.e. (a, b, c)</p>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.alpha"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.alpha"></a>
<em class="property">property </em><code class="sig-name descname">alpha</code><a class="headerlink" href="#pymatgen.core.lattice.Lattice.alpha" title="Permalink to this definition">¶</a></dt>
<dd><p>Angle alpha of lattice in degrees.</p>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.angles"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.angles"></a>
<em class="property">property </em><code class="sig-name descname">angles</code><a class="headerlink" href="#pymatgen.core.lattice.Lattice.angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the angles (alpha, beta, gamma) of the lattice.</p>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.as_dict"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.as_dict"></a>
<code class="sig-name descname">as_dict</code><span class="sig-paren">(</span><em class="sig-param">verbosity: int = 0</em><span class="sig-paren">)</span> → Dict<a class="reference internal" href="_modules/pymatgen/core/lattice.html#Lattice.as_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.core.lattice.Lattice.as_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Json-serialization dict representation of the Lattice.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>verbosity</strong> (<em>int</em>) – Verbosity level. Default of 0 only includes the
matrix representation. Set to 1 for more details.</p>
</dd>
</dl>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.b"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.b"></a>
<em class="property">property </em><code class="sig-name descname">b</code><a class="headerlink" href="#pymatgen.core.lattice.Lattice.b" title="Permalink to this definition">¶</a></dt>
<dd><p><em>b</em> lattice parameter.</p>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.beta"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.beta"></a>
<em class="property">property </em><code class="sig-name descname">beta</code><a class="headerlink" href="#pymatgen.core.lattice.Lattice.beta" title="Permalink to this definition">¶</a></dt>
<dd><p>Angle beta of lattice in degrees.</p>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.c"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.c"></a>
<em class="property">property </em><code class="sig-name descname">c</code><a class="headerlink" href="#pymatgen.core.lattice.Lattice.c" title="Permalink to this definition">¶</a></dt>
<dd><p><em>c</em> lattice parameter.</p>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.copy"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.copy"></a>
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/core/lattice.html#Lattice.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.core.lattice.Lattice.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Deep copy of self.</p>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.cubic"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.cubic"></a>
<em class="property">static </em><code class="sig-name descname">cubic</code><span class="sig-paren">(</span><em class="sig-param">a: float</em><span class="sig-paren">)</span> → pymatgen.core.lattice.Lattice<a class="reference internal" href="_modules/pymatgen/core/lattice.html#Lattice.cubic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.core.lattice.Lattice.cubic" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience constructor for a cubic lattice.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>a</strong> (<em>float</em>) – The <em>a</em> lattice parameter of the cubic cell.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Cubic lattice of dimensions a x a x a.</p>
</dd>
</dl>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.d_hkl"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.d_hkl"></a>
<code class="sig-name descname">d_hkl</code><span class="sig-paren">(</span><em class="sig-param">miller_index: Union[Sequence[float], Sequence[Sequence[float]], Sequence[numpy.ndarray], numpy.ndarray]</em><span class="sig-paren">)</span> → float<a class="reference internal" href="_modules/pymatgen/core/lattice.html#Lattice.d_hkl"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.core.lattice.Lattice.d_hkl" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the distance between the hkl plane and the origin</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>miller_index</strong> (<em>[</em><em>h</em><em>,</em><em>k</em><em>,</em><em>l</em><em>]</em>) – Miller index of plane</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>d_hkl (float)</p>
</dd>
</dl>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.dot"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.dot"></a>
<code class="sig-name descname">dot</code><span class="sig-paren">(</span><em class="sig-param">coords_a: Union[Sequence[float], Sequence[Sequence[float]], Sequence[numpy.ndarray], numpy.ndarray], coords_b: Union[Sequence[float], Sequence[Sequence[float]], Sequence[numpy.ndarray], numpy.ndarray], frac_coords: bool = False</em><span class="sig-paren">)</span> → numpy.ndarray<a class="reference internal" href="_modules/pymatgen/core/lattice.html#Lattice.dot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.core.lattice.Lattice.dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the scalar product of vector(s).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coords_b</strong> (<em>coords_a</em><em>,</em>) – Array-like objects with the coordinates.</p></li>
<li><p><strong>frac_coords</strong> (<em>bool</em>) – Boolean stating whether the vector
corresponds to fractional or cartesian coordinates.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>one-dimensional <cite>numpy</cite> array.</p>
</dd>
</dl>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.find_all_mappings"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.find_all_mappings"></a>
<code class="sig-name descname">find_all_mappings</code><span class="sig-paren">(</span><em class="sig-param">other_lattice: pymatgen.core.lattice.Lattice</em>, <em class="sig-param">ltol: float = 1e-05</em>, <em class="sig-param">atol: float = 1</em>, <em class="sig-param">skip_rotation_matrix: bool = False</em><span class="sig-paren">)</span> → Iterator[Tuple[pymatgen.core.lattice.Lattice, Optional[numpy.ndarray], numpy.ndarray]]<a class="reference internal" href="_modules/pymatgen/core/lattice.html#Lattice.find_all_mappings"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.core.lattice.Lattice.find_all_mappings" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds all mappings between current lattice and another lattice.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>other_lattice</strong> (<a class="reference internal" href="#pymatgen.core.lattice.Lattice" title="pymatgen.core.lattice.Lattice"><em>Lattice</em></a>) – Another lattice that is equivalent to
this one.</p></li>
<li><p><strong>ltol</strong> (<em>float</em>) – Tolerance for matching lengths. Defaults to 1e-5.</p></li>
<li><p><strong>atol</strong> (<em>float</em>) – Tolerance for matching angles. Defaults to 1.</p></li>
<li><p><strong>skip_rotation_matrix</strong> (<em>bool</em>) – Whether to skip calculation of the
rotation matrix</p></li>
</ul>
</dd>
<dt class="field-even">Yields</dt>
<dd class="field-even"><p>(aligned_lattice, rotation_matrix, scale_matrix) if a mapping is
found. aligned_lattice is a rotated version of other_lattice that
has the same lattice parameters, but which is aligned in the
coordinate system of this lattice so that translational points
match up in 3D. rotation_matrix is the rotation that has to be
applied to other_lattice to obtain aligned_lattice, i.e.,
aligned_matrix = np.inner(other_lattice, rotation_matrix) and
op = SymmOp.from_rotation_and_translation(rotation_matrix)
aligned_matrix = op.operate_multi(latt.matrix)
Finally, scale_matrix is the integer matrix that expresses
aligned_matrix as a linear combination of this
lattice, i.e., aligned_matrix = np.dot(scale_matrix, self.matrix)</p>
<p>None is returned if no matches are found.</p>
</dd>
</dl>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.find_mapping"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.find_mapping"></a>
<code class="sig-name descname">find_mapping</code><span class="sig-paren">(</span><em class="sig-param">other_lattice: pymatgen.core.lattice.Lattice</em>, <em class="sig-param">ltol: float = 1e-05</em>, <em class="sig-param">atol: float = 1</em>, <em class="sig-param">skip_rotation_matrix: bool = False</em><span class="sig-paren">)</span> → Optional[Tuple[pymatgen.core.lattice.Lattice, Optional[numpy.ndarray], numpy.ndarray]]<a class="reference internal" href="_modules/pymatgen/core/lattice.html#Lattice.find_mapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.core.lattice.Lattice.find_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds a mapping between current lattice and another lattice. There
are an infinite number of choices of basis vectors for two entirely
equivalent lattices. This method returns a mapping that maps
other_lattice to this lattice.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>other_lattice</strong> (<a class="reference internal" href="#pymatgen.core.lattice.Lattice" title="pymatgen.core.lattice.Lattice"><em>Lattice</em></a>) – Another lattice that is equivalent to
this one.</p></li>
<li><p><strong>ltol</strong> (<em>float</em>) – Tolerance for matching lengths. Defaults to 1e-5.</p></li>
<li><p><strong>atol</strong> (<em>float</em>) – Tolerance for matching angles. Defaults to 1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>(aligned_lattice, rotation_matrix, scale_matrix) if a mapping is
found. aligned_lattice is a rotated version of other_lattice that
has the same lattice parameters, but which is aligned in the
coordinate system of this lattice so that translational points
match up in 3D. rotation_matrix is the rotation that has to be
applied to other_lattice to obtain aligned_lattice, i.e.,
aligned_matrix = np.inner(other_lattice, rotation_matrix) and
op = SymmOp.from_rotation_and_translation(rotation_matrix)
aligned_matrix = op.operate_multi(latt.matrix)
Finally, scale_matrix is the integer matrix that expresses
aligned_matrix as a linear combination of this
lattice, i.e., aligned_matrix = np.dot(scale_matrix, self.matrix)</p>
<p>None is returned if no matches are found.</p>
</p>
</dd>
</dl>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.from_dict"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.from_dict"></a>
<em class="property">classmethod </em><code class="sig-name descname">from_dict</code><span class="sig-paren">(</span><em class="sig-param">d: Dict</em>, <em class="sig-param">fmt: str = None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/core/lattice.html#Lattice.from_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.core.lattice.Lattice.from_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Lattice from a dictionary containing the a, b, c, alpha, beta,
and gamma parameters if fmt is None.</p>
<p>If fmt == “abivars”, the function build a <cite>Lattice</cite> object from a
dictionary with the Abinit variables <cite>acell</cite> and <cite>rprim</cite> in Bohr.
If acell is not given, the Abinit default is used i.e. [1,1,1] Bohr</p>
<p class="rubric">Example</p>
<p>Lattice.from_dict(fmt=”abivars”, acell=3*[10], rprim=np.eye(3))</p>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.from_lengths_and_angles"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.from_lengths_and_angles"></a>
<em class="property">static </em><code class="sig-name descname">from_lengths_and_angles</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pymatgen.core.lattice.Lattice.from_lengths_and_angles" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.from_parameters"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.from_parameters"></a>
<em class="property">classmethod </em><code class="sig-name descname">from_parameters</code><span class="sig-paren">(</span><em class="sig-param">a: float</em>, <em class="sig-param">b: float</em>, <em class="sig-param">c: float</em>, <em class="sig-param">alpha: float</em>, <em class="sig-param">beta: float</em>, <em class="sig-param">gamma: float</em>, <em class="sig-param">vesta: bool = False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pymatgen/core/lattice.html#Lattice.from_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.core.lattice.Lattice.from_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Lattice using unit cell lengths and angles (in degrees).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>float</em>) – <em>a</em> lattice parameter.</p></li>
<li><p><strong>b</strong> (<em>float</em>) – <em>b</em> lattice parameter.</p></li>
<li><p><strong>c</strong> (<em>float</em>) – <em>c</em> lattice parameter.</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – <em>alpha</em> angle in degrees.</p></li>
<li><p><strong>beta</strong> (<em>float</em>) – <em>beta</em> angle in degrees.</p></li>
<li><p><strong>gamma</strong> (<em>float</em>) – <em>gamma</em> angle in degrees.</p></li>
<li><p><strong>vesta</strong> – True if you import Cartesian coordinates from VESTA.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Lattice with the specified lattice parameters.</p>
</dd>
</dl>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.gamma"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.gamma"></a>
<em class="property">property </em><code class="sig-name descname">gamma</code><a class="headerlink" href="#pymatgen.core.lattice.Lattice.gamma" title="Permalink to this definition">¶</a></dt>
<dd><p>Angle gamma of lattice in degrees.</p>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.get_all_distances"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.get_all_distances"></a>
<code class="sig-name descname">get_all_distances</code><span class="sig-paren">(</span><em class="sig-param">fcoords1: Union[Sequence[float], Sequence[Sequence[float]], Sequence[numpy.ndarray], numpy.ndarray], fcoords2: Union[Sequence[float], Sequence[Sequence[float]], Sequence[numpy.ndarray], numpy.ndarray]</em><span class="sig-paren">)</span> → numpy.ndarray<a class="reference internal" href="_modules/pymatgen/core/lattice.html#Lattice.get_all_distances"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.core.lattice.Lattice.get_all_distances" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the distances between two lists of coordinates taking into
account periodic boundary conditions and the lattice. Note that this
computes an MxN array of distances (i.e. the distance between each
point in fcoords1 and every coordinate in fcoords2). This is
different functionality from pbc_diff.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fcoords1</strong> – First set of fractional coordinates. e.g., [0.5, 0.6,
0.7] or [[1.1, 1.2, 4.3], [0.5, 0.6, 0.7]]. It can be a single
coord or any array of coords.</p></li>
<li><p><strong>fcoords2</strong> – Second set of fractional coordinates.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>2d array of cartesian distances. E.g the distance between
fcoords1[i] and fcoords2[j] is distances[i,j]</p>
</dd>
</dl>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.get_brillouin_zone"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.get_brillouin_zone"></a>
<code class="sig-name descname">get_brillouin_zone</code><span class="sig-paren">(</span><span class="sig-paren">)</span> → List[List[numpy.ndarray]]<a class="reference internal" href="_modules/pymatgen/core/lattice.html#Lattice.get_brillouin_zone"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.core.lattice.Lattice.get_brillouin_zone" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Wigner-Seitz cell for the reciprocal lattice, aka the
Brillouin Zone.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A list of list of coordinates.
Each element in the list is a “facet” of the boundary of the
Brillouin Zone. For instance, a list of four coordinates will
represent a square facet.</p>
</dd>
</dl>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.get_cartesian_coords"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.get_cartesian_coords"></a>
<code class="sig-name descname">get_cartesian_coords</code><span class="sig-paren">(</span><em class="sig-param">fractional_coords: Union[Sequence[float], Sequence[Sequence[float]], Sequence[numpy.ndarray], numpy.ndarray]</em><span class="sig-paren">)</span> → numpy.ndarray<a class="reference internal" href="_modules/pymatgen/core/lattice.html#Lattice.get_cartesian_coords"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.core.lattice.Lattice.get_cartesian_coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the cartesian coordinates given fractional coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>fractional_coords</strong> (<em>3x1 array</em>) – Fractional coords.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Cartesian coordinates</p>
</dd>
</dl>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.get_distance_and_image"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.get_distance_and_image"></a>
<code class="sig-name descname">get_distance_and_image</code><span class="sig-paren">(</span><em class="sig-param">frac_coords1: Union[Sequence[float], Sequence[Sequence[float]], Sequence[numpy.ndarray], numpy.ndarray], frac_coords2: Union[Sequence[float], Sequence[Sequence[float]], Sequence[numpy.ndarray], numpy.ndarray], jimage: Union[Sequence[float], Sequence[Sequence[float]], Sequence[numpy.ndarray], numpy.ndarray, None] = None</em><span class="sig-paren">)</span> → Tuple[float, numpy.ndarray]<a class="reference internal" href="_modules/pymatgen/core/lattice.html#Lattice.get_distance_and_image"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.core.lattice.Lattice.get_distance_and_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets distance between two frac_coords assuming periodic boundary
conditions. If the index jimage is not specified it selects the j
image nearest to the i atom and returns the distance and jimage
indices in terms of lattice vector translations. If the index jimage
is specified it returns the distance between the frac_coords1 and
the specified jimage of frac_coords2, and the given jimage is also
returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frac_coords1</strong> (<em>3x1 array</em>) – Reference fcoords to get distance from.</p></li>
<li><p><strong>frac_coords2</strong> (<em>3x1 array</em>) – fcoords to get distance from.</p></li>
<li><p><strong>jimage</strong> (<em>3x1 array</em>) – Specific periodic image in terms of
lattice translations, e.g., [1,0,0] implies to take periodic
image that is one a-lattice vector away. If jimage is None,
the image that is nearest to the site is found.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>distance and periodic lattice translations
of the other site for which the distance applies. This means that
the distance between frac_coords1 and (jimage + frac_coords2) is
equal to distance.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(distance, jimage)</p>
</dd>
</dl>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.get_frac_coords_from_lll"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.get_frac_coords_from_lll"></a>
<code class="sig-name descname">get_frac_coords_from_lll</code><span class="sig-paren">(</span><em class="sig-param">lll_frac_coords: Union[Sequence[float], Sequence[Sequence[float]], Sequence[numpy.ndarray], numpy.ndarray]</em><span class="sig-paren">)</span> → numpy.ndarray<a class="reference internal" href="_modules/pymatgen/core/lattice.html#Lattice.get_frac_coords_from_lll"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.core.lattice.Lattice.get_frac_coords_from_lll" title="Permalink to this definition">¶</a></dt>
<dd><p>Given fractional coordinates in the lll basis, returns corresponding
fractional coordinates in the lattice basis.</p>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.get_fractional_coords"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.get_fractional_coords"></a>
<code class="sig-name descname">get_fractional_coords</code><span class="sig-paren">(</span><em class="sig-param">cart_coords: Union[Sequence[float], Sequence[Sequence[float]], Sequence[numpy.ndarray], numpy.ndarray]</em><span class="sig-paren">)</span> → numpy.ndarray<a class="reference internal" href="_modules/pymatgen/core/lattice.html#Lattice.get_fractional_coords"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.core.lattice.Lattice.get_fractional_coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the fractional coordinates given cartesian coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>cart_coords</strong> (<em>3x1 array</em>) – Cartesian coords.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Fractional coordinates.</p>
</dd>
</dl>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.get_lll_frac_coords"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.get_lll_frac_coords"></a>
<code class="sig-name descname">get_lll_frac_coords</code><span class="sig-paren">(</span><em class="sig-param">frac_coords: Union[Sequence[float], Sequence[Sequence[float]], Sequence[numpy.ndarray], numpy.ndarray]</em><span class="sig-paren">)</span> → numpy.ndarray<a class="reference internal" href="_modules/pymatgen/core/lattice.html#Lattice.get_lll_frac_coords"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.core.lattice.Lattice.get_lll_frac_coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Given fractional coordinates in the lattice basis, returns corresponding
fractional coordinates in the lll basis.</p>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.get_lll_reduced_lattice"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.get_lll_reduced_lattice"></a>
<code class="sig-name descname">get_lll_reduced_lattice</code><span class="sig-paren">(</span><em class="sig-param">delta: float = 0.75</em><span class="sig-paren">)</span> → pymatgen.core.lattice.Lattice<a class="reference internal" href="_modules/pymatgen/core/lattice.html#Lattice.get_lll_reduced_lattice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.core.lattice.Lattice.get_lll_reduced_lattice" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>delta</strong> – Delta parameter.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>LLL reduced Lattice.</p>
</dd>
</dl>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.get_miller_index_from_coords"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.get_miller_index_from_coords"></a>
<code class="sig-name descname">get_miller_index_from_coords</code><span class="sig-paren">(</span><em class="sig-param">coords: Union[Sequence[float], Sequence[Sequence[float]], Sequence[numpy.ndarray], numpy.ndarray], coords_are_cartesian: bool = True, round_dp: int = 4, verbose: bool = True</em><span class="sig-paren">)</span> → Tuple[int, int, int]<a class="reference internal" href="_modules/pymatgen/core/lattice.html#Lattice.get_miller_index_from_coords"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.core.lattice.Lattice.get_miller_index_from_coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the Miller index of a plane from a list of site coordinates.</p>
<p>A minimum of 3 sets of coordinates are required. If more than 3 sets of
coordinates are given, the best plane that minimises the distance to all
points will be calculated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coords</strong> (<em>iterable</em>) – A list or numpy array of coordinates. Can be
cartesian or fractional coordinates. If more than three sets of
coordinates are provided, the best plane that minimises the
distance to all sites will be calculated.</p></li>
<li><p><strong>coords_are_cartesian</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether the coordinates are
in cartesian space. If using fractional coordinates set to
False.</p></li>
<li><p><strong>round_dp</strong> (<em>int</em><em>, </em><em>optional</em>) – The number of decimal places to round the
miller index to.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to print warnings.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Miller index.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(tuple)</p>
</dd>
</dl>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.get_niggli_reduced_lattice"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.get_niggli_reduced_lattice"></a>
<code class="sig-name descname">get_niggli_reduced_lattice</code><span class="sig-paren">(</span><em class="sig-param">tol: float = 1e-05</em><span class="sig-paren">)</span> → pymatgen.core.lattice.Lattice<a class="reference internal" href="_modules/pymatgen/core/lattice.html#Lattice.get_niggli_reduced_lattice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.core.lattice.Lattice.get_niggli_reduced_lattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the Niggli reduced lattice using the numerically stable algo
proposed by R. W. Grosse-Kunstleve, N. K. Sauter, &amp; P. D. Adams,
Acta Crystallographica Section A Foundations of Crystallography, 2003,
60(1), 1-6. doi:10.1107/S010876730302186X</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>tol</strong> (<em>float</em>) – The numerical tolerance. The default of 1e-5 should
result in stable behavior for most cases.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Niggli-reduced lattice.</p>
</dd>
</dl>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.get_points_in_sphere"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.get_points_in_sphere"></a>
<code class="sig-name descname">get_points_in_sphere</code><span class="sig-paren">(</span><em class="sig-param">frac_points: Union[Sequence[float], Sequence[Sequence[float]], Sequence[numpy.ndarray], numpy.ndarray], center: Union[Sequence[float], Sequence[Sequence[float]], Sequence[numpy.ndarray], numpy.ndarray], r: float, zip_results=True</em><span class="sig-paren">)</span> → List<a class="reference internal" href="_modules/pymatgen/core/lattice.html#Lattice.get_points_in_sphere"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.core.lattice.Lattice.get_points_in_sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all points within a sphere from the point taking into account
periodic boundary conditions. This includes sites in other periodic
images.</p>
<p>Algorithm:</p>
<ol class="arabic">
<li><p>place sphere of radius r in crystal and determine minimum supercell
(parallelpiped) which would contain a sphere of radius r. for this
we need the projection of a_1 on a unit vector perpendicular
to a_2 &amp; a_3 (i.e. the unit vector in the direction b_1) to
determine how many a_1”s it will take to contain the sphere.</p>
<p>Nxmax = r * length_of_b_1 / (2 Pi)</p>
</li>
<li><p>keep points falling within r.</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frac_points</strong> – All points in the lattice in fractional coordinates.</p></li>
<li><p><strong>center</strong> – Cartesian coordinates of center of sphere.</p></li>
<li><p><strong>r</strong> – radius of sphere.</p></li>
<li><p><strong>zip_results</strong> (<em>bool</em>) – Whether to zip the results together to group by
point, or return the raw fcoord, dist, index arrays</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>[(fcoord, dist, index, supercell_image) …] since most of the time, subsequent</dt><dd><p>processing requires the distance, index number of the atom, or index of the image</p>
</dd>
<dt>else:</dt><dd><p>fcoords, dists, inds, image</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>if zip_results</p>
</dd>
</dl>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.get_points_in_sphere_old"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.get_points_in_sphere_old"></a>
<code class="sig-name descname">get_points_in_sphere_old</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pymatgen.core.lattice.Lattice.get_points_in_sphere_old" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.get_points_in_sphere_py"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.get_points_in_sphere_py"></a>
<code class="sig-name descname">get_points_in_sphere_py</code><span class="sig-paren">(</span><em class="sig-param">frac_points: Union[Sequence[float], Sequence[Sequence[float]], Sequence[numpy.ndarray], numpy.ndarray], center: Union[Sequence[float], Sequence[Sequence[float]], Sequence[numpy.ndarray], numpy.ndarray], r: float, zip_results=True</em><span class="sig-paren">)</span> → Union[List[Tuple[numpy.ndarray, float, int, numpy.ndarray]], List[numpy.ndarray]]<a class="reference internal" href="_modules/pymatgen/core/lattice.html#Lattice.get_points_in_sphere_py"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.core.lattice.Lattice.get_points_in_sphere_py" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all points within a sphere from the point taking into account
periodic boundary conditions. This includes sites in other periodic
images.</p>
<p>Algorithm:</p>
<ol class="arabic">
<li><p>place sphere of radius r in crystal and determine minimum supercell
(parallelpiped) which would contain a sphere of radius r. for this
we need the projection of a_1 on a unit vector perpendicular
to a_2 &amp; a_3 (i.e. the unit vector in the direction b_1) to
determine how many a_1”s it will take to contain the sphere.</p>
<p>Nxmax = r * length_of_b_1 / (2 Pi)</p>
</li>
<li><p>keep points falling within r.</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frac_points</strong> – All points in the lattice in fractional coordinates.</p></li>
<li><p><strong>center</strong> – Cartesian coordinates of center of sphere.</p></li>
<li><p><strong>r</strong> – radius of sphere.</p></li>
<li><p><strong>zip_results</strong> (<em>bool</em>) – Whether to zip the results together to group by
point, or return the raw fcoord, dist, index arrays</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>[(fcoord, dist, index, supercell_image) …] since most of the time, subsequent</dt><dd><p>processing requires the distance, index number of the atom, or index of the image</p>
</dd>
<dt>else:</dt><dd><p>fcoords, dists, inds, image</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>if zip_results</p>
</dd>
</dl>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.get_recp_symmetry_operation"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.get_recp_symmetry_operation"></a>
<code class="sig-name descname">get_recp_symmetry_operation</code><span class="sig-paren">(</span><em class="sig-param">symprec: float = 0.01</em><span class="sig-paren">)</span> → List<a class="reference internal" href="_modules/pymatgen/core/lattice.html#Lattice.get_recp_symmetry_operation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.core.lattice.Lattice.get_recp_symmetry_operation" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the symmetric operations of the reciprocal lattice,
to be used for hkl transformations
:param symprec: default is 0.001</p>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.get_vector_along_lattice_directions"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.get_vector_along_lattice_directions"></a>
<code class="sig-name descname">get_vector_along_lattice_directions</code><span class="sig-paren">(</span><em class="sig-param">cart_coords: Union[Sequence[float], Sequence[Sequence[float]], Sequence[numpy.ndarray], numpy.ndarray]</em><span class="sig-paren">)</span> → numpy.ndarray<a class="reference internal" href="_modules/pymatgen/core/lattice.html#Lattice.get_vector_along_lattice_directions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.core.lattice.Lattice.get_vector_along_lattice_directions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the coordinates along lattice directions given cartesian coordinates.</p>
<p>Note, this is different than a projection of the cartesian vector along the
lattice parameters. It is simply the fractional coordinates multiplied by the
lattice vector magnitudes.</p>
<p>For example, this method is helpful when analyzing the dipole moment (in
units of electron Angstroms) of a ferroelectric crystal. See the <cite>Polarization</cite>
class in <cite>pymatgen.analysis.ferroelectricity.polarization</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>cart_coords</strong> (<em>3x1 array</em>) – Cartesian coords.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Lattice coordinates.</p>
</dd>
</dl>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.get_wigner_seitz_cell"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.get_wigner_seitz_cell"></a>
<code class="sig-name descname">get_wigner_seitz_cell</code><span class="sig-paren">(</span><span class="sig-paren">)</span> → List[List[numpy.ndarray]]<a class="reference internal" href="_modules/pymatgen/core/lattice.html#Lattice.get_wigner_seitz_cell"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.core.lattice.Lattice.get_wigner_seitz_cell" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Wigner-Seitz cell for the given lattice.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A list of list of coordinates.
Each element in the list is a “facet” of the boundary of the
Wigner Seitz cell. For instance, a list of four coordinates will
represent a square facet.</p>
</dd>
</dl>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.hexagonal"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.hexagonal"></a>
<em class="property">static </em><code class="sig-name descname">hexagonal</code><span class="sig-paren">(</span><em class="sig-param">a: float</em>, <em class="sig-param">c: float</em><span class="sig-paren">)</span> → pymatgen.core.lattice.Lattice<a class="reference internal" href="_modules/pymatgen/core/lattice.html#Lattice.hexagonal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.core.lattice.Lattice.hexagonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience constructor for a hexagonal lattice.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>float</em>) – <em>a</em> lattice parameter of the hexagonal cell.</p></li>
<li><p><strong>c</strong> (<em>float</em>) – <em>c</em> lattice parameter of the hexagonal cell.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Hexagonal lattice of dimensions a x a x c.</p>
</dd>
</dl>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.inv_matrix"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.inv_matrix"></a>
<em class="property">property </em><code class="sig-name descname">inv_matrix</code><a class="headerlink" href="#pymatgen.core.lattice.Lattice.inv_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse of lattice matrix.</p>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.is_hexagonal"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.is_hexagonal"></a>
<code class="sig-name descname">is_hexagonal</code><span class="sig-paren">(</span><em class="sig-param">hex_angle_tol: float = 5</em>, <em class="sig-param">hex_length_tol: float = 0.01</em><span class="sig-paren">)</span> → bool<a class="reference internal" href="_modules/pymatgen/core/lattice.html#Lattice.is_hexagonal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.core.lattice.Lattice.is_hexagonal" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hex_angle_tol</strong> – Angle tolerance</p></li>
<li><p><strong>hex_length_tol</strong> – Length tolerance</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Whether lattice corresponds to hexagonal lattice.</p>
</dd>
</dl>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.is_orthogonal"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.is_orthogonal"></a>
<em class="property">property </em><code class="sig-name descname">is_orthogonal</code><a class="headerlink" href="#pymatgen.core.lattice.Lattice.is_orthogonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether all angles are 90 degrees.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>return</p>
</dd>
</dl>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.lengths"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.lengths"></a>
<em class="property">property </em><code class="sig-name descname">lengths</code><a class="headerlink" href="#pymatgen.core.lattice.Lattice.lengths" title="Permalink to this definition">¶</a></dt>
<dd><p>The lengths (a, b, c) of the lattice.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>return</p>
</dd>
</dl>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.lengths_and_angles"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.lengths_and_angles"></a>
<em class="property">property </em><code class="sig-name descname">lengths_and_angles</code><a class="headerlink" href="#pymatgen.core.lattice.Lattice.lengths_and_angles" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.lll_inverse"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.lll_inverse"></a>
<em class="property">property </em><code class="sig-name descname">lll_inverse</code><a class="headerlink" href="#pymatgen.core.lattice.Lattice.lll_inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse of self.lll_mapping.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>return</p>
</dd>
</dl>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.lll_mapping"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.lll_mapping"></a>
<em class="property">property </em><code class="sig-name descname">lll_mapping</code><a class="headerlink" href="#pymatgen.core.lattice.Lattice.lll_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>The mapping between the LLL reduced lattice and the original
lattice.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>return</p>
</dd>
</dl>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.lll_matrix"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.lll_matrix"></a>
<em class="property">property </em><code class="sig-name descname">lll_matrix</code><a class="headerlink" href="#pymatgen.core.lattice.Lattice.lll_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>The matrix for LLL reduction</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>return</p>
</dd>
</dl>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.matrix"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.matrix"></a>
<em class="property">property </em><code class="sig-name descname">matrix</code><a class="headerlink" href="#pymatgen.core.lattice.Lattice.matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy of matrix representing the Lattice</p>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.metric_tensor"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.metric_tensor"></a>
<em class="property">property </em><code class="sig-name descname">metric_tensor</code><a class="headerlink" href="#pymatgen.core.lattice.Lattice.metric_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>The metric tensor of the lattice.</p>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.monoclinic"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.monoclinic"></a>
<em class="property">static </em><code class="sig-name descname">monoclinic</code><span class="sig-paren">(</span><em class="sig-param">a: float</em>, <em class="sig-param">b: float</em>, <em class="sig-param">c: float</em>, <em class="sig-param">beta: float</em><span class="sig-paren">)</span> → pymatgen.core.lattice.Lattice<a class="reference internal" href="_modules/pymatgen/core/lattice.html#Lattice.monoclinic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.core.lattice.Lattice.monoclinic" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience constructor for a monoclinic lattice.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>float</em>) – <em>a</em> lattice parameter of the monoclinc cell.</p></li>
<li><p><strong>b</strong> (<em>float</em>) – <em>b</em> lattice parameter of the monoclinc cell.</p></li>
<li><p><strong>c</strong> (<em>float</em>) – <em>c</em> lattice parameter of the monoclinc cell.</p></li>
<li><p><strong>beta</strong> (<em>float</em>) – <em>beta</em> angle between lattice vectors b and c in
degrees.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Monoclinic lattice of dimensions a x b x c with non right-angle
beta between lattice vectors a and c.</p>
</dd>
</dl>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.norm"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.norm"></a>
<code class="sig-name descname">norm</code><span class="sig-paren">(</span><em class="sig-param">coords: Union[Sequence[float], Sequence[Sequence[float]], Sequence[numpy.ndarray], numpy.ndarray], frac_coords: bool = True</em><span class="sig-paren">)</span> → float<a class="reference internal" href="_modules/pymatgen/core/lattice.html#Lattice.norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.core.lattice.Lattice.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the norm of vector(s).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coords</strong> – Array-like object with the coordinates.</p></li>
<li><p><strong>frac_coords</strong> – Boolean stating whether the vector corresponds to fractional or
cartesian coordinates.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>one-dimensional <cite>numpy</cite> array.</p>
</dd>
</dl>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.orthorhombic"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.orthorhombic"></a>
<em class="property">static </em><code class="sig-name descname">orthorhombic</code><span class="sig-paren">(</span><em class="sig-param">a: float</em>, <em class="sig-param">b: float</em>, <em class="sig-param">c: float</em><span class="sig-paren">)</span> → pymatgen.core.lattice.Lattice<a class="reference internal" href="_modules/pymatgen/core/lattice.html#Lattice.orthorhombic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.core.lattice.Lattice.orthorhombic" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience constructor for an orthorhombic lattice.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>float</em>) – <em>a</em> lattice parameter of the orthorhombic cell.</p></li>
<li><p><strong>b</strong> (<em>float</em>) – <em>b</em> lattice parameter of the orthorhombic cell.</p></li>
<li><p><strong>c</strong> (<em>float</em>) – <em>c</em> lattice parameter of the orthorhombic cell.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Orthorhombic lattice of dimensions a x b x c.</p>
</dd>
</dl>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.parameters"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.parameters"></a>
<em class="property">property </em><code class="sig-name descname">parameters</code><a class="headerlink" href="#pymatgen.core.lattice.Lattice.parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>(a, b, c, alpha, beta, gamma).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>Returns</p>
</dd>
</dl>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.reciprocal_lattice"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.reciprocal_lattice"></a>
<em class="property">property </em><code class="sig-name descname">reciprocal_lattice</code><a class="headerlink" href="#pymatgen.core.lattice.Lattice.reciprocal_lattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the reciprocal lattice. Note that this is the standard
reciprocal lattice used for solid state physics with a factor of 2 *
pi. If you are looking for the crystallographic reciprocal lattice,
use the reciprocal_lattice_crystallographic property.
The property is lazily generated for efficiency.</p>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.reciprocal_lattice_crystallographic"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.reciprocal_lattice_crystallographic"></a>
<em class="property">property </em><code class="sig-name descname">reciprocal_lattice_crystallographic</code><a class="headerlink" href="#pymatgen.core.lattice.Lattice.reciprocal_lattice_crystallographic" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <em>crystallographic</em> reciprocal lattice, i.e., no factor of
2 * pi.</p>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.rhombohedral"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.rhombohedral"></a>
<em class="property">static </em><code class="sig-name descname">rhombohedral</code><span class="sig-paren">(</span><em class="sig-param">a: float</em>, <em class="sig-param">alpha: float</em><span class="sig-paren">)</span> → pymatgen.core.lattice.Lattice<a class="reference internal" href="_modules/pymatgen/core/lattice.html#Lattice.rhombohedral"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.core.lattice.Lattice.rhombohedral" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience constructor for a rhombohedral lattice.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>float</em>) – <em>a</em> lattice parameter of the rhombohedral cell.</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – Angle for the rhombohedral lattice in degrees.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Rhombohedral lattice of dimensions a x a x a.</p>
</dd>
</dl>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.scale"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.scale"></a>
<code class="sig-name descname">scale</code><span class="sig-paren">(</span><em class="sig-param">new_volume: float</em><span class="sig-paren">)</span> → pymatgen.core.lattice.Lattice<a class="reference internal" href="_modules/pymatgen/core/lattice.html#Lattice.scale"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.core.lattice.Lattice.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new Lattice with volume new_volume by performing a
scaling of the lattice vectors so that length proportions and angles
are preserved.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>new_volume</strong> – New volume to scale to.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>New lattice with desired volume.</p>
</dd>
</dl>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.tetragonal"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.tetragonal"></a>
<em class="property">static </em><code class="sig-name descname">tetragonal</code><span class="sig-paren">(</span><em class="sig-param">a: float</em>, <em class="sig-param">c: float</em><span class="sig-paren">)</span> → pymatgen.core.lattice.Lattice<a class="reference internal" href="_modules/pymatgen/core/lattice.html#Lattice.tetragonal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.core.lattice.Lattice.tetragonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience constructor for a tetragonal lattice.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>float</em>) – <em>a</em> lattice parameter of the tetragonal cell.</p></li>
<li><p><strong>c</strong> (<em>float</em>) – <em>c</em> lattice parameter of the tetragonal cell.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Tetragonal lattice of dimensions a x a x c.</p>
</dd>
</dl>
</dd></dl>
<dl class="method">
<dt id="pymatgen.core.lattice.Lattice.volume"><a name="//apple_ref/cpp/Method/pymatgen.core.lattice.Lattice.volume"></a>
<em class="property">property </em><code class="sig-name descname">volume</code><a class="headerlink" href="#pymatgen.core.lattice.Lattice.volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Volume of the unit cell.</p>
</dd></dl>
</dd></dl>
<dl class="function">
<dt id="pymatgen.core.lattice.find_neighbors"><a name="//apple_ref/cpp/Function/pymatgen.core.lattice.find_neighbors"></a>
<code class="sig-name descname">find_neighbors</code><span class="sig-paren">(</span><em class="sig-param">label: numpy.ndarray</em>, <em class="sig-param">nx: int</em>, <em class="sig-param">ny: int</em>, <em class="sig-param">nz: int</em><span class="sig-paren">)</span> → List[numpy.ndarray]<a class="reference internal" href="_modules/pymatgen/core/lattice.html#find_neighbors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.core.lattice.find_neighbors" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a cube index, find the neighbor cube indices</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>label</strong> – (array) (n,) or (n x 3) indice array</p></li>
<li><p><strong>nx</strong> – (int) number of cells in y direction</p></li>
<li><p><strong>ny</strong> – (int) number of cells in y direction</p></li>
<li><p><strong>nz</strong> – (int) number of cells in z direction</p></li>
</ul>
</dd>
</dl>
<p>Returns: neighbor cell indices</p>
</dd></dl>
<dl class="function">
<dt id="pymatgen.core.lattice.get_integer_index"><a name="//apple_ref/cpp/Function/pymatgen.core.lattice.get_integer_index"></a>
<code class="sig-name descname">get_integer_index</code><span class="sig-paren">(</span><em class="sig-param">miller_index: Sequence[float], round_dp: int = 4, verbose: bool = True</em><span class="sig-paren">)</span> → Tuple[int, int, int]<a class="reference internal" href="_modules/pymatgen/core/lattice.html#get_integer_index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.core.lattice.get_integer_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempt to convert a vector of floats to whole numbers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>miller_index</strong> (<em>list of float</em>) – A list miller indexes.</p></li>
<li><p><strong>round_dp</strong> (<em>int</em><em>, </em><em>optional</em>) – The number of decimal places to round the
miller index to.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to print warnings.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Miller index.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(tuple)</p>
</dd>
</dl>
</dd></dl>
<dl class="function">
<dt id="pymatgen.core.lattice.get_points_in_spheres"><a name="//apple_ref/cpp/Function/pymatgen.core.lattice.get_points_in_spheres"></a>
<code class="sig-name descname">get_points_in_spheres</code><span class="sig-paren">(</span><em class="sig-param">all_coords: numpy.ndarray</em>, <em class="sig-param">center_coords: numpy.ndarray</em>, <em class="sig-param">r: float</em>, <em class="sig-param">pbc: Union[bool</em>, <em class="sig-param">List[bool]] = True</em>, <em class="sig-param">numerical_tol: float = 1e-08</em>, <em class="sig-param">lattice: pymatgen.core.lattice.Lattice = None</em>, <em class="sig-param">return_fcoords: bool = False</em><span class="sig-paren">)</span> → List[List[Tuple[numpy.ndarray, float, int, numpy.ndarray]]]<a class="reference internal" href="_modules/pymatgen/core/lattice.html#get_points_in_spheres"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pymatgen.core.lattice.get_points_in_spheres" title="Permalink to this definition">¶</a></dt>
<dd><p>For each point in <cite>center_coords</cite>, get all the neighboring points in <cite>all_coords</cite> that are within the
cutoff radius <cite>r</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>all_coords</strong> – (list of cartesian coordinates) all available points</p></li>
<li><p><strong>center_coords</strong> – (list of cartesian coordinates) all centering points</p></li>
<li><p><strong>r</strong> – (float) cutoff radius</p></li>
<li><p><strong>pbc</strong> – (bool or a list of bool) whether to set periodic boundaries</p></li>
<li><p><strong>numerical_tol</strong> – (float) numerical tolerance</p></li>
<li><p><strong>lattice</strong> – (Lattice) lattice to consider when PBC is enabled</p></li>
<li><p><strong>return_fcoords</strong> – (bool) whether to return fractional coords when pbc is set.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>List[List[Tuple[coords, distance, index, image]]]</p>
</dd>
</dl>
</dd></dl>
</div>
</div>
</div>
<div class="clearer"></div>
</div>
<div aria-label="related navigation" class="related" role="navigation">
<h3>Navigation</h3>
<ul>
<li class="right" style="margin-right: 10px">
<a href="genindex.html" title="General Index">index</a></li>
<li class="right">
<a href="py-modindex.html" title="Python Module Index">modules</a> |</li>
<li class="right">
<a href="pymatgen.core.libxcfunc.html" title="pymatgen.core.libxcfunc module">next</a> |</li>
<li class="right">
<a href="pymatgen.core.ion.html" title="pymatgen.core.ion module">previous</a> |</li>
<li class="nav-item nav-item-0"><a href="index.html">pymatgen 2021.2.8.1 documentation</a> »</li>
<li class="nav-item nav-item-1"><a href="modules.html">pymatgen</a> »</li>
<li class="nav-item nav-item-2"><a href="pymatgen.html">pymatgen namespace</a> »</li>
<li class="nav-item nav-item-3"><a href="pymatgen.core.html">pymatgen.core package</a> »</li>
</ul>
</div>
<div class="footer" role="contentinfo">
        © Copyright 2011, Pymatgen Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.0.
    </div>
<div class="footer">This page uses <a href="http://analytics.google.com/">
Google Analytics</a> to collect statistics. You can disable it by blocking
the JavaScript coming from www.google-analytics.com.
<script type="text/javascript">
  (function() {
    var ga = document.createElement('script');
    ga.src = ('https:' == document.location.protocol ?
              'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    ga.setAttribute('async', 'true');
    document.documentElement.firstChild.appendChild(ga);
  })();
</script>
</div>
</body>
</html>